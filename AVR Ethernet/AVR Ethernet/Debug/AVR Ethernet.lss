
AVR Ethernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005988  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000020  00800060  00005988  00005a1c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000678  00800080  00800080  00005a3c  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00005a3c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000090  00000000  00000000  00006108  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000180  00000000  00000000  00006198  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000953  00000000  00000000  00006318  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00003473  00000000  00000000  00006c6b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000e64  00000000  00000000  0000a0de  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000031dc  00000000  00000000  0000af42  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000006e0  00000000  00000000  0000e120  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000d65  00000000  00000000  0000e800  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002c1a  00000000  00000000  0000f565  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 000003ad  00000000  00000000  0001217f  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000030  00000000  00000000  0001252c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 c0 09 	jmp	0x1380	; 0x1380 <__ctors_end>
       4:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
       8:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
       c:	0c 94 62 15 	jmp	0x2ac4	; 0x2ac4 <__vector_3>
      10:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
      14:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
      18:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
      1c:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
      20:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
      24:	0c 94 bc 29 	jmp	0x5378	; 0x5378 <__vector_9>
      28:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
      2c:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
      30:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
      34:	0c 94 72 2a 	jmp	0x54e4	; 0x54e4 <__vector_13>
      38:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
      3c:	0c 94 46 2a 	jmp	0x548c	; 0x548c <__vector_15>
      40:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
      44:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
      48:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
      4c:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>
      50:	0c 94 dd 09 	jmp	0x13ba	; 0x13ba <__bad_interrupt>

00000054 <__c.1728>:
      54:	0a 0d 00                                            ...

00000057 <__c.1726>:
      57:	44 48 43 50 3a 20 53 65 6e 64 69 6e 67 20 52 65     DHCP: Sending Re
      67:	6c 65 61 73 65 20 74 6f 20 00                       lease to .

00000071 <__c.1718>:
      71:	4c 65 61 73 65 54 6d 20 3a 20 25 64 0a 0d 00        LeaseTm : %d...

00000080 <__c.1716>:
      80:	44 48 43 50 3a 20 47 6f 74 20 72 65 71 75 65 73     DHCP: Got reques
      90:	74 20 41 43 4b 2c 20 62 69 6e 64 20 63 6f 6d 70     t ACK, bind comp
      a0:	6c 65 74 65 0d 0a 00                                lete...

000000a7 <__c.1714>:
      a7:	0a 0d 00                                            ...

000000aa <__c.1712>:
      aa:	44 48 43 50 3a 20 47 6f 74 20 6f 66 66 65 72 20     DHCP: Got offer 
      ba:	66 72 6f 6d 20 73 65 72 76 65 72 20 00              from server .

000000c7 <__c.1710>:
      c7:	44 48 43 50 3a 20 52 65 63 65 69 76 65 64 20 6d     DHCP: Received m
      d7:	73 67 74 79 70 65 20 3d 20 25 64 0d 0a 00           sgtype = %d...

000000e5 <__c.1699>:
      e5:	44 48 43 50 3a 20 53 65 6e 64 69 6e 67 20 72 65     DHCP: Sending re
      f5:	71 75 65 73 74 20 69 6e 20 72 65 73 70 6f 6e 73     quest in respons
     105:	65 20 74 6f 20 6f 66 66 65 72 0d 0a 00              e to offer...

00000112 <__c.1691>:
     112:	44 48 43 50 3a 20 53 65 6e 64 69 6e 67 20 51 75     DHCP: Sending Qu
     122:	65 72 79 0d 0a 00                                   ery...

00000128 <__c.1683>:
     128:	0a 0d 00                                            ...

0000012b <__c.1681>:
     12b:	43 6c 48 77 41 64 64 72 3a 20 00                    ClHwAddr: .

00000136 <__c.1679>:
     136:	0a 0d 00                                            ...

00000139 <__c.1677>:
     139:	47 77 49 70 41 64 64 72 3a 20 00                    GwIpAddr: .

00000144 <__c.1675>:
     144:	0a 0d 00                                            ...

00000147 <__c.1673>:
     147:	53 76 49 70 41 64 64 72 3a 20 00                    SvIpAddr: .

00000152 <__c.1671>:
     152:	0a 0d 00                                            ...

00000155 <__c.1669>:
     155:	59 72 49 70 41 64 64 72 3a 20 00                    YrIpAddr: .

00000160 <__c.1667>:
     160:	0a 0d 00                                            ...

00000163 <__c.1665>:
     163:	43 6c 49 70 41 64 64 72 3a 20 00                    ClIpAddr: .

0000016e <__c.1663>:
     16e:	0a 0d 00                                            ...

00000171 <__c.1661>:
     171:	58 49 44 20 20 20 20 20 3a 20 30 78 00              XID     : 0x.

0000017e <__c.1659>:
     17e:	0a 0d 00                                            ...

00000181 <__c.1657>:
     181:	55 4e 4b 4e 4f 57 4e 00                             UNKNOWN.

00000189 <__c.1654>:
     189:	42 4f 4f 54 52 45 50 4c 59 00                       BOOTREPLY.

00000193 <__c.1650>:
     193:	42 4f 4f 54 52 45 51 55 45 53 54 00                 BOOTREQUEST.

0000019f <__c.1647>:
     19f:	4f 70 20 20 20 20 20 20 3a 20 00                    Op      : .

000001aa <__c.1645>:
     1aa:	44 48 43 50 20 50 61 63 6b 65 74 3a 0d 0a 00        DHCP Packet:...

000001b9 <enc28j60_config>:
     1b9:	04 00 05 00 06 ff 07 05 08 00 09 06 0a ff 0b 1f     ................
     1c9:	c1 00 c0 0d c2 32 ca ee cb 05 c4 12 c6 12 c7 0c     .....2..........
     1d9:	e4 30 e5 46 e2 46 e3 49 e0 43 e1 45                 .0.F.F.I.C.E

000001e5 <Page1>:
     1e5:	3c 21 44 4f 43 54 59 50 45 20 68 74 6d 6c 20 50     <!DOCTYPE html P
     1f5:	55 42 4c 49 43 20 22 2d 2f 2f 57 33 43 2f 2f 44     UBLIC "-//W3C//D
     205:	54 44 20 58 48 54 4d 4c 20 31 2e 30 20 54 72 61     TD XHTML 1.0 Tra
     215:	6e 73 69 74 69 6f 6e 61 6c 2f 2f 45 4e 22 20 22     nsitional//EN" "
     225:	68 74 74 70 3a 2f 2f 77 77 77 2e 77 33 2e 6f 72     http://www.w3.or
     235:	67 2f 54 52 2f 78 68 74 6d 6c 31 2f 44 54 44 2f     g/TR/xhtml1/DTD/
     245:	78 68 74 6d 6c 31 2d 74 72 61 6e 73 69 74 69 6f     xhtml1-transitio
     255:	6e 61 6c 2e 64 74 64 22 3e 3c 68 74 6d 6c 20 78     nal.dtd"><html x
     265:	6d 6c 6e 73 3d 22 68 74 74 70 3a 2f 2f 77 77 77     mlns="http://www
     275:	2e 77 33 2e 6f 72 67 2f 31 39 39 39 2f 78 68 74     .w3.org/1999/xht
     285:	6d 6c 22 20 64 69 72 3d 22 6c 74 72 22 20 6c 61     ml" dir="ltr" la
     295:	6e 67 3d 22 65 6e 22 3e 3c 68 65 61 64 3e 3c 6d     ng="en"><head><m
     2a5:	65 74 61 20 68 74 74 70 2d 65 71 75 69 76 3d 22     eta http-equiv="
     2b5:	43 6f 6e 74 65 6e 74 2d 54 79 70 65 22 20 63 6f     Content-Type" co
     2c5:	6e 74 65 6e 74 3d 22 74 65 78 74 2f 68 74 6d 6c     ntent="text/html
     2d5:	3b 20 63 68 61 72 73 65 74 3d 55 54 46 2d 38 22     ; charset=UTF-8"
     2e5:	3e 3c 74 69 74 6c 65 3e 41 56 52 20 77 65 62 20     ><title>AVR web 
     2f5:	73 65 72 76 65 72 3c 2f 74 69 74 6c 65 3e 3c 73     server</title><s
     305:	74 79 6c 65 20 74 79 70 65 3d 22 74 65 78 74 2f     tyle type="text/
     315:	63 73 73 22 3e 20 2e 6f 6e 20 7b 20 62 6f 72 64     css"> .on { bord
     325:	65 72 3a 31 3b 20 77 69 64 74 68 3a 20 32 30 70     er:1; width: 20p
     335:	78 3b 20 68 65 69 67 68 74 3a 20 32 30 70 78 3b     x; height: 20px;
     345:	20 62 61 63 6b 67 72 6f 75 6e 64 3a 20 62 6c 75      background: blu
     355:	65 3b 20 74 65 78 74 2d 61 6c 69 67 6e 3a 20 63     e; text-align: c
     365:	65 6e 74 65 72 3b 20 70 61 64 64 69 6e 67 3a 20     enter; padding: 
     375:	30 70 78 3b 20 63 6f 6c 6f 72 3a 20 23 66 66 66     0px; color: #fff
     385:	3b 20 2d 6d 6f 7a 2d 62 6f 72 64 65 72 2d 72 61     ; -moz-border-ra
     395:	64 69 75 73 3a 20 31 30 70 78 3b 20 2d 77 65 62     dius: 10px; -web
     3a5:	6b 69 74 2d 62 6f 72 64 65 72 2d 72 61 64 69 75     kit-border-radiu
     3b5:	73 3a 20 31 30 70 78 3b 20 62 6f 72 64 65 72 2d     s: 10px; border-
     3c5:	72 61 64 69 75 73 3a 20 31 30 70 78 3b 7d 2e 6f     radius: 10px;}.o
     3d5:	66 66 20 7b 20 62 6f 72 64 65 72 3a 31 3b 20 77     ff { border:1; w
     3e5:	69 64 74 68 3a 20 32 30 70 78 3b 20 68 65 69 67     idth: 20px; heig
     3f5:	68 74 3a 20 32 30 70 78 3b 20 62 61 63 6b 67 72     ht: 20px; backgr
     405:	6f 75 6e 64 3a 20 77 68 69 74 65 3b 20 74 65 78     ound: white; tex
     415:	74 2d 61 6c 69 67 6e 3a 20 63 65 6e 74 65 72 3b     t-align: center;
     425:	20 70 61 64 64 69 6e 67 3a 20 30 70 78 3b 20 63      padding: 0px; c
     435:	6f 6c 6f 72 3a 20 23 66 66 66 3b 20 2d 6d 6f 7a     olor: #fff; -moz
     445:	2d 62 6f 72 64 65 72 2d 72 61 64 69 75 73 3a 20     -border-radius: 
     455:	31 30 70 78 3b 20 2d 77 65 62 6b 69 74 2d 62 6f     10px; -webkit-bo
     465:	72 64 65 72 2d 72 61 64 69 75 73 3a 20 31 30 70     rder-radius: 10p
     475:	78 3b 20 62 6f 72 64 65 72 2d 72 61 64 69 75 73     x; border-radius
     485:	3a 20 31 30 70 78 3b 20 62 6f 72 64 65 72 3a 20     : 10px; border: 
     495:	31 70 78 20 73 6f 6c 69 64 20 23 61 34 61 34 61     1px solid #a4a4a
     4a5:	34 3b 7d 3c 2f 73 74 79 6c 65 3e 3c 2f 68 65 61     4;}</style></hea
     4b5:	64 3e 3c 62 6f 64 79 20 62 67 63 6f 6c 6f 72 3d     d><body bgcolor=
     4c5:	22 23 64 30 64 30 64 30 22 20 61 6c 69 67 6e 3d     "#d0d0d0" align=
     4d5:	22 63 65 6e 74 65 72 22 20 73 74 79 6c 65 3d 22     "center" style="
     4e5:	70 61 64 64 69 6e 67 3a 20 31 35 70 78 20 30 70     padding: 15px 0p
     4f5:	78 20 30 70 78 20 30 70 78 3b 22 3e 3c 74 61 62     x 0px 0px;"><tab
     505:	6c 65 20 62 67 63 6f 6c 6f 72 3d 22 23 32 46 34     le bgcolor="#2F4
     515:	46 34 46 22 20 69 64 3d 22 72 6f 6f 74 22 20 62     F4F" id="root" b
     525:	6f 72 64 65 72 3d 22 31 22 20 61 6c 69 67 6e 3d     order="1" align=
     535:	22 63 65 6e 74 65 72 22 20 20 77 69 64 74 68 3d     "center"  width=
     545:	22 38 33 38 70 78 22 3c 74 62 6f 64 79 3e 3c 74     "838px"<tbody><t
     555:	72 3e 3c 74 64 20 63 6f 6c 73 70 61 6e 3d 22 34     r><td colspan="4
     565:	22 20 68 65 69 67 68 74 3d 22 31 32 35 22 3e 3c     " height="125"><
     575:	62 3e 3c 64 69 76 20 61 6c 69 67 6e 3d 22 63 65     b><div align="ce
     585:	6e 74 65 72 22 20 73 74 79 6c 65 3d 22 66 6f 6e     nter" style="fon
     595:	74 2d 73 69 7a 65 3a 32 34 70 74 3b 20 63 6f 6c     t-size:24pt; col
     5a5:	6f 72 3a 23 46 46 46 46 46 46 22 3e 52 45 4d 4f     or:#FFFFFF">REMO
     5b5:	54 45 20 43 4f 4e 54 52 4f 4c 20 41 56 52 20 57     TE CONTROL AVR W
     5c5:	45 42 53 45 52 56 45 52 3c 2f 64 69 76 3e 3c 2f     EBSERVER</div></
     5d5:	62 3e 3c 2f 74 64 3e 3c 2f 74 72 3e 3c 74 72 20     b></td></tr><tr 
     5e5:	61 6c 69 67 6e 3d 22 6c 65 66 74 22 3e 3c 74 64     align="left"><td
     5f5:	20 62 67 63 6f 6c 6f 72 3d 22 23 64 30 64 30 64      bgcolor="#d0d0d
     605:	30 22 20 63 6f 6c 73 70 61 6e 3d 22 34 22 20 68     0" colspan="4" h
     615:	65 69 67 68 74 3d 22 32 30 22 20 76 61 6c 69 67     eight="20" valig
     625:	6e 3d 22 74 6f 70 22 20 77 69 64 74 68 3d 22 36     n="top" width="6
     635:	39 34 22 3e 3c 62 3e 3c 64 69 76 3e 26 6e 62 73     94"><b><div>&nbs
     645:	70 3b 52 65 6d 6f 74 65 20 63 6f 6e 74 72 6f 6c     p;Remote control
     655:	20 77 65 62 73 65 72 76 65 72 20 77 69 74 68 20      webserver with 
     665:	41 54 6d 65 67 61 33 32 3c 2f 64 69 76 3e 3c 2f     ATmega32</div></
     675:	62 3e 3c 2f 74 64 3e 3c 2f 74 72 3e 3c 74 72 20     b></td></tr><tr 
     685:	61 6c 69 67 6e 3d 22 6c 65 66 74 22 3e 3c 74 64     align="left"><td
     695:	20 68 65 69 67 68 74 3d 22 32 30 22 20 76 61 6c      height="20" val
     6a5:	69 67 6e 3d 22 74 6f 70 22 20 77 69 64 74 68 3d     ign="top" width=
     6b5:	22 37 35 25 22 3e 3c 62 3e 3c 64 69 76 20 73 74     "75%"><b><div st
     6c5:	79 6c 65 3d 22 63 6f 6c 6f 72 3a 23 46 46 46 46     yle="color:#FFFF
     6d5:	46 46 22 3e 26 6e 62 73 70 3b 44 65 76 69 63 65     FF">&nbsp;Device
     6e5:	73 3c 2f 64 69 76 3e 3c 2f 62 3e 3c 2f 74 64 3e     s</div></b></td>
     6f5:	3c 74 64 20 68 65 69 67 68 74 3d 22 32 30 22 20     <td height="20" 
     705:	76 61 6c 69 67 6e 3d 22 74 6f 70 22 20 77 69 64     valign="top" wid
     715:	74 68 3d 22 61 75 74 6f 22 3e 3c 62 3e 3c 64 69     th="auto"><b><di
     725:	76 20 73 74 79 6c 65 3d 22 63 6f 6c 6f 72 3a 23     v style="color:#
     735:	46 46 46 46 46 46 22 3e 26 6e 62 73 70 3b 53 65     FFFFFF">&nbsp;Se
     745:	6e 73 6f 72 73 3c 2f 64 69 76 3e 3c 2f 62 3e 3c     nsors</div></b><
     755:	2f 74 64 3e 3c 2f 74 72 3e 3c 74 72 3e 3c 74 64     /td></tr><tr><td
     765:	20 68 65 69 67 68 74 3d 22 61 75 74 6f 22 20 76      height="auto" v
     775:	61 6c 69 67 6e 3d 22 74 6f 70 22 20 77 69 64 74     align="top" widt
     785:	68 3d 22 32 30 30 22 3e 3c 70 3e 3c 2f 70 3e 3c     h="200"><p></p><
     795:	64 69 76 3e 3c 66 6f 72 6d 20 6d 65 74 68 6f 64     div><form method
     7a5:	3d 22 50 4f 53 54 22 20 61 63 74 69 6f 6e 3d 22     ="POST" action="
     7b5:	22 3e 3c 73 74 72 6f 6e 67 3e 3c 74 61 62 6c 65     "><strong><table
     7c5:	20 62 67 63 6f 6c 6f 72 3d 22 23 64 30 64 30 64      bgcolor="#d0d0d
     7d5:	30 22 20 77 69 64 74 68 3d 22 39 35 25 22 20 62     0" width="95%" b
     7e5:	6f 72 64 65 72 3d 22 31 22 20 61 6c 69 67 6e 3d     order="1" align=
     7f5:	22 63 65 6e 74 65 72 22 20 69 64 3d 22 74 61 62     "center" id="tab
     805:	6c 65 5f 64 65 76 69 63 65 22 3e 3c 74 72 20 61     le_device"><tr a
     815:	6c 69 67 6e 3d 22 63 65 6e 74 65 72 22 3e 3c 74     lign="center"><t
     825:	64 20 77 69 64 74 68 3d 22 31 35 25 22 3e 4e 61     d width="15%">Na
     835:	6d 65 73 3c 2f 74 64 3e 3c 74 64 20 77 69 64 74     mes</td><td widt
     845:	68 3d 22 39 25 22 3e 4e 6f 77 20 53 74 61 74 65     h="9%">Now State
     855:	73 3c 2f 74 64 3e 3c 74 64 20 77 69 64 74 68 3d     s</td><td width=
     865:	22 31 31 25 22 3e 43 6f 6e 74 72 6f 6c 20 50 61     "11%">Control Pa
     875:	6e 65 6c 3c 2f 74 64 3e 3c 74 64 3e 43 6f 6d 6d     nel</td><td>Comm
     885:	61 6e 64 3c 2f 74 64 3e 3c 74 64 20 77 69 64 74     and</td><td widt
     895:	68 3d 22 31 35 25 22 3e 43 6f 75 6e 74 64 6f 77     h="15%">Countdow
     8a5:	6e 20 28 4d 69 6e 75 74 65 73 29 3c 2f 74 64 3e     n (Minutes)</td>
     8b5:	3c 74 64 20 77 69 64 74 68 3d 22 31 31 25 22 3e     <td width="11%">
     8c5:	54 69 6d 65 72 20 53 74 61 74 75 73 3c 2f 74 64     Timer Status</td
     8d5:	3e 3c 74 64 20 77 69 64 74 68 3d 22 31 35 25 22     ><td width="15%"
     8e5:	3e 41 75 74 6f 20 4f 4e 20 28 3c 73 75 70 3e 6f     >Auto ON (<sup>o
     8f5:	3c 2f 73 75 70 3e 43 29 3c 2f 74 64 3e 3c 2f 74     </sup>C)</td></t
     905:	72 3e 3c 74 72 20 61 6c 69 67 6e 3d 22 63 65 6e     r><tr align="cen
     915:	74 65 72 22 3e 3c 74 64 3e 44 65 76 69 63 65 20     ter"><td>Device 
     925:	31 3c 2f 74 64 3e 3c 74 64 3e 3c 64 69 76 20 63     1</td><td><div c
     935:	6c 61 73 73 3d 22 25 43 4c 31 22 3e 3c 2f 74 64     lass="%CL1"></td
     945:	3e 3c 74 64 3e 3c 69 6e 70 75 74 20 74 79 70 65     ><td><input type
     955:	3d 22 63 68 65 63 6b 62 6f 78 22 20 6e 61 6d 65     ="checkbox" name
     965:	3d 22 52 45 4c 41 59 31 22 20 76 61 6c 75 65 3d     ="RELAY1" value=
     975:	22 4f 4e 22 25 52 4c 31 3e 3c 2f 64 69 76 3e 3c     "ON"%RL1></div><
     985:	2f 74 64 3e 3c 74 64 3e 3c 69 6e 70 75 74 20 74     /td><td><input t
     995:	79 70 65 3d 22 74 65 78 74 22 20 6e 61 6d 65 3d     ype="text" name=
     9a5:	22 41 75 74 6f 31 22 2f 3e 3c 2f 74 64 3e 3c 74     "Auto1"/></td><t
     9b5:	64 3e 25 43 44 31 3c 2f 74 64 3e 3c 74 64 3e 25     d>%CD1</td><td>%
     9c5:	54 53 31 3c 2f 74 64 3e 3c 74 64 3e 25 54 41 31     TS1</td><td>%TA1
     9d5:	3c 2f 74 64 3e 3c 2f 74 72 3e 3c 74 72 20 61 6c     </td></tr><tr al
     9e5:	69 67 6e 3d 22 63 65 6e 74 65 72 22 3e 3c 74 64     ign="center"><td
     9f5:	3e 44 65 76 69 63 65 20 32 3c 2f 74 64 3e 3c 74     >Device 2</td><t
     a05:	64 3e 3c 64 69 76 20 63 6c 61 73 73 3d 22 25 43     d><div class="%C
     a15:	4c 32 22 3e 3c 2f 74 64 3e 3c 74 64 3e 3c 69 6e     L2"></td><td><in
     a25:	70 75 74 20 74 79 70 65 3d 22 63 68 65 63 6b 62     put type="checkb
     a35:	6f 78 22 20 6e 61 6d 65 3d 22 52 45 4c 41 59 32     ox" name="RELAY2
     a45:	22 20 76 61 6c 75 65 3d 22 4f 4e 22 25 52 4c 32     " value="ON"%RL2
     a55:	3e 3c 2f 64 69 76 3e 3c 2f 74 64 3e 3c 74 64 3e     ></div></td><td>
     a65:	3c 69 6e 70 75 74 20 74 79 70 65 3d 22 74 65 78     <input type="tex
     a75:	74 22 20 6e 61 6d 65 3d 22 41 75 74 6f 32 22 2f     t" name="Auto2"/
     a85:	3e 3c 2f 74 64 3e 3c 74 64 3e 25 43 44 32 3c 2f     ></td><td>%CD2</
     a95:	74 64 3e 3c 74 64 3e 25 54 53 32 3c 2f 74 64 3e     td><td>%TS2</td>
     aa5:	3c 74 64 3e 25 54 41 32 3c 2f 74 64 3e 3c 2f 74     <td>%TA2</td></t
     ab5:	72 3e 3c 74 72 20 61 6c 69 67 6e 3d 22 63 65 6e     r><tr align="cen
     ac5:	74 65 72 22 3e 3c 74 64 3e 44 65 76 69 63 65 20     ter"><td>Device 
     ad5:	33 3c 2f 74 64 3e 3c 74 64 3e 3c 64 69 76 20 63     3</td><td><div c
     ae5:	6c 61 73 73 3d 22 25 43 4c 33 22 3e 3c 2f 74 64     lass="%CL3"></td
     af5:	3e 3c 74 64 3e 3c 69 6e 70 75 74 20 74 79 70 65     ><td><input type
     b05:	3d 22 63 68 65 63 6b 62 6f 78 22 20 6e 61 6d 65     ="checkbox" name
     b15:	3d 22 52 45 4c 41 59 33 22 20 76 61 6c 75 65 3d     ="RELAY3" value=
     b25:	22 4f 4e 22 25 52 4c 33 3e 3c 2f 64 69 76 3e 3c     "ON"%RL3></div><
     b35:	2f 74 64 3e 3c 74 64 3e 3c 69 6e 70 75 74 20 74     /td><td><input t
     b45:	79 70 65 3d 22 74 65 78 74 22 20 6e 61 6d 65 3d     ype="text" name=
     b55:	22 41 75 74 6f 33 22 2f 3e 3c 2f 74 64 3e 3c 74     "Auto3"/></td><t
     b65:	64 3e 25 43 44 33 3c 2f 74 64 3e 3c 74 64 3e 25     d>%CD3</td><td>%
     b75:	54 53 33 3c 2f 74 64 3e 3c 74 64 3e 25 54 41 33     TS3</td><td>%TA3
     b85:	3c 2f 74 64 3e 3c 2f 74 72 3e 3c 74 72 20 61 6c     </td></tr><tr al
     b95:	69 67 6e 3d 22 63 65 6e 74 65 72 22 3e 3c 74 64     ign="center"><td
     ba5:	3e 44 65 76 69 63 65 20 34 3c 2f 74 64 3e 3c 74     >Device 4</td><t
     bb5:	64 3e 3c 64 69 76 20 63 6c 61 73 73 3d 22 25 43     d><div class="%C
     bc5:	4c 34 22 3e 3c 2f 74 64 3e 3c 74 64 3e 3c 69 6e     L4"></td><td><in
     bd5:	70 75 74 20 74 79 70 65 3d 22 63 68 65 63 6b 62     put type="checkb
     be5:	6f 78 22 20 6e 61 6d 65 3d 22 52 45 4c 41 59 34     ox" name="RELAY4
     bf5:	22 20 76 61 6c 75 65 3d 22 4f 4e 22 25 52 4c 34     " value="ON"%RL4
     c05:	3e 3c 2f 64 69 76 3e 3c 2f 74 64 3e 3c 74 64 3e     ></div></td><td>
     c15:	3c 69 6e 70 75 74 20 74 79 70 65 3d 22 74 65 78     <input type="tex
     c25:	74 22 20 6e 61 6d 65 3d 22 41 75 74 6f 34 22 2f     t" name="Auto4"/
     c35:	3e 3c 2f 74 64 3e 3c 74 64 3e 25 43 44 34 3c 2f     ></td><td>%CD4</
     c45:	74 64 3e 3c 74 64 3e 25 54 53 34 3c 2f 74 64 3e     td><td>%TS4</td>
     c55:	3c 74 64 3e 25 54 41 34 3c 2f 74 64 3e 3c 2f 74     <td>%TA4</td></t
     c65:	72 3e 3c 2f 73 74 72 6f 6e 67 3e 3c 2f 74 61 62     r></strong></tab
     c75:	6c 65 3e 3c 70 20 61 6c 69 67 6e 3d 22 63 65 6e     le><p align="cen
     c85:	74 65 72 22 3e 3c 69 6e 70 75 74 20 74 79 70 65     ter"><input type
     c95:	3d 22 73 75 62 6d 69 74 22 20 76 61 6c 75 65 3d     ="submit" value=
     ca5:	22 53 75 62 6d 69 74 22 20 6e 61 6d 65 3d 22 53     "Submit" name="S
     cb5:	55 42 22 3e 3c 2f 70 3e 3c 2f 66 6f 72 6d 3e 3c     UB"></p></form><
     cc5:	2f 64 69 76 3e 3c 2f 74 64 3e 3c 74 64 20 68 65     /div></td><td he
     cd5:	69 67 68 74 3d 22 61 75 74 6f 22 20 61 6c 69 67     ight="auto" alig
     ce5:	6e 3d 22 63 65 6e 74 65 72 22 20 76 61 6c 69 67     n="center" valig
     cf5:	6e 3d 22 63 65 6e 74 65 72 22 20 77 69 64 74 68     n="center" width
     d05:	3d 22 61 75 74 6f 22 3e 3c 64 69 76 20 73 74 79     ="auto"><div sty
     d15:	6c 65 3d 22 66 6f 6e 74 2d 73 69 7a 65 3a 35 35     le="font-size:55
     d25:	70 74 3b 20 63 6f 6c 6f 72 3a 23 46 46 46 46 46     pt; color:#FFFFF
     d35:	46 20 22 3e 25 41 44 3c 73 75 70 3e 6f 3c 2f 73     F ">%AD<sup>o</s
     d45:	75 70 3e 43 3c 2f 64 69 76 3e 3c 2f 74 64 3e 3c     up>C</div></td><
     d55:	2f 74 72 3e 3c 74 72 20 61 6c 69 67 6e 3d 22 6c     /tr><tr align="l
     d65:	65 66 74 22 3e 3c 74 64 20 63 6f 6c 73 70 61 6e     eft"><td colspan
     d75:	3d 22 34 22 20 68 65 69 67 68 74 3d 22 61 75 74     ="4" height="aut
     d85:	6f 22 20 76 61 6c 69 67 6e 3d 22 74 6f 70 22 20     o" valign="top" 
     d95:	77 69 64 74 68 3d 22 61 75 74 6f 22 3e 3c 62 3e     width="auto"><b>
     da5:	3c 64 69 76 20 73 74 79 6c 65 3d 22 63 6f 6c 6f     <div style="colo
     db5:	72 3a 23 46 46 46 46 46 46 22 3e 26 6e 62 73 70     r:#FFFFFF">&nbsp
     dc5:	3b 4d 61 6e 75 61 6c 73 3c 2f 64 69 76 3e 3c 2f     ;Manuals</div></
     dd5:	62 3e 3c 2f 74 64 3e 3c 2f 74 72 3e 3c 74 72 20     b></td></tr><tr 
     de5:	61 6c 69 67 6e 3d 22 6c 65 66 74 22 3e 3c 74 64     align="left"><td
     df5:	20 62 67 63 6f 6c 6f 72 3d 22 23 64 30 64 30 64      bgcolor="#d0d0d
     e05:	30 22 63 6f 6c 73 70 61 6e 3d 22 34 22 20 68 65     0"colspan="4" he
     e15:	69 67 68 74 3d 22 61 75 74 6f 22 20 76 61 6c 69     ight="auto" vali
     e25:	67 6e 3d 22 74 6f 70 22 20 77 69 64 74 68 3d 22     gn="top" width="
     e35:	61 75 74 6f 22 3e 3c 64 69 76 3e 26 6e 62 73 70     auto"><div>&nbsp
     e45:	3b 43 6f 6d 6d 61 6e 64 20 3a 26 6e 62 73 70 3b     ;Command :&nbsp;
     e55:	20 3c 62 3e 26 6c 74 3b 53 74 61 74 65 73 26 67      <b>&lt;States&g
     e65:	74 3b 26 6c 74 3b 4d 69 6e 75 74 65 73 26 67 74     t;&lt;Minutes&gt
     e75:	3b 3c 2f 62 3e 20 61 6e 64 20 3c 62 3e 26 6c 74     ;</b> and <b>&lt
     e85:	3b 54 65 6d 70 65 72 61 74 75 72 65 20 56 61 6c     ;Temperature Val
     e95:	75 65 26 67 74 3b 26 6c 74 3b 53 74 61 74 65 73     ue&gt;&lt;States
     ea5:	26 67 74 3b 3c 2f 62 3e 2e 3c 62 72 2f 3e 26 6e     &gt;</b>.<br/>&n
     eb5:	62 73 70 3b 45 78 31 3a 20 4f 46 46 31 35 20 6d     bsp;Ex1: OFF15 m
     ec5:	65 61 6e 73 20 64 65 76 69 63 65 20 74 75 72 6e     eans device turn
     ed5:	20 6f 66 66 20 61 66 74 65 72 20 31 35 20 6d 69      off after 15 mi
     ee5:	6e 75 74 65 73 2e 3c 62 72 2f 3e 26 6e 62 73 70     nutes.<br/>&nbsp
     ef5:	3b 45 78 32 3a 20 33 35 4f 4e 20 6d 65 61 6e 73     ;Ex2: 35ON means
     f05:	20 69 66 20 74 65 6d 70 65 72 61 74 75 72 65 20      if temperature 
     f15:	68 69 67 68 65 72 20 33 35 20 43 65 6c 73 69 75     higher 35 Celsiu
     f25:	73 2c 20 64 65 76 69 63 65 20 69 73 20 6f 6e 20     s, device is on 
     f35:	61 6e 64 20 72 65 76 65 72 73 65 2e 3c 2f 64 69     and reverse.</di
     f45:	76 3e 3c 2f 74 64 3e 3c 2f 74 72 3e 3c 74 72 3e     v></td></tr><tr>
     f55:	3c 74 64 20 63 6f 6c 73 70 61 6e 3d 22 34 22 20     <td colspan="4" 
     f65:	68 65 69 67 68 74 3d 22 61 75 74 6f 22 20 77 69     height="auto" wi
     f75:	64 74 68 3d 22 61 75 74 6f 22 3e 3c 64 69 76 20     dth="auto"><div 
     f85:	61 6c 69 67 6e 3d 22 63 65 6e 74 65 72 22 20 73     align="center" s
     f95:	74 79 6c 65 3d 22 63 6f 6c 6f 72 3a 23 46 46 46     tyle="color:#FFF
     fa5:	46 46 46 22 3e 44 65 73 69 67 6e 65 64 20 62 79     FFF">Designed by
     fb5:	20 4c 61 6d 20 4e 67 6f 63 20 43 68 69 65 6e 3c      Lam Ngoc Chien<
     fc5:	64 69 76 3e 54 69 6d 65 7a 6f 6e 65 3a 20 47 4d     div>Timezone: GM
     fd5:	54 2b 37 2e 20 43 75 72 72 65 6e 74 20 74 69 6d     T+7. Current tim
     fe5:	65 20 3c 73 70 61 6e 3e 25 54 49 3c 2f 73 70 61     e <span>%TI</spa
     ff5:	6e 3e 3c 2f 64 69 76 3e 3c 2f 64 69 76 3e 3c 2f     n></div></div></
    1005:	74 64 3e 3c 2f 74 72 3e 3c 2f 74 62 6f 64 79 3e     td></tr></tbody>
    1015:	3c 2f 74 61 62 6c 65 3e 3c 2f 62 6f 64 79 3e 3c     </table></body><
    1025:	2f 68 74 6d 6c 3e 00                                /html>.

0000102c <Auth_str>:
    102c:	41 75 74 68 6f 72 69 7a 61 74 69 6f 6e 00           Authorization.

0000103a <http_pageheader_ok>:
    103a:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 44 6f 63     HTTP/1.0 200 Doc
    104a:	75 6d 65 6e 74 20 66 6f 6c 6c 6f 77 73 0d 0a 53     ument follows..S
    105a:	65 72 76 65 72 3a 20 41 56 52 5f 53 6d 61 6c 6c     erver: AVR_Small
    106a:	5f 57 65 62 73 65 72 76 65 72 0d 0a 43 6f 6e 74     _Webserver..Cont
    107a:	65 6e 74 2d 54 79 70 65 3a 20 74 65 78 74 2f 68     ent-Type: text/h
    108a:	74 6d 6c 0d 0a 0d 0a 00                             tml.....

00001092 <http_pageheader_unauth>:
    1092:	48 54 54 50 2f 31 2e 30 20 34 30 31 20 55 6e 61     HTTP/1.0 401 Una
    10a2:	75 74 68 6f 72 69 7a 65 64 0d 0a 53 65 72 76 65     uthorized..Serve
    10b2:	72 3a 20 41 56 52 5f 53 6d 61 6c 6c 5f 57 65 62     r: AVR_Small_Web
    10c2:	73 65 72 76 65 72 0d 0a 57 57 57 2d 41 75 74 68     server..WWW-Auth
    10d2:	65 6e 74 69 63 61 74 65 3a 20 42 61 73 69 63 20     enticate: Basic 
    10e2:	72 65 61 6c 6d 3d 22 4e 65 65 64 50 61 73 73 77     realm="NeedPassw
    10f2:	6f 72 64 22 0d 0a 43 6f 6e 74 65 6e 74 2d 54 79     ord"..Content-Ty
    1102:	70 65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 0d     pe: text/html...
    1112:	0a 00                                               ..

00001114 <http_pageheader_auth_error>:
    1114:	34 30 31 20 55 6e 61 75 74 68 6f 72 69 7a 65 64     401 Unauthorized
    1124:	25 45 4e 44 00                                      %END.

00001129 <http_error_notimp>:
    1129:	48 54 54 50 2f 31 2e 31 20 35 30 31 20 4e 6f 74     HTTP/1.1 501 Not
    1139:	20 49 6d 70 6c 65 6d 65 6e 74 65 64 0d 0a 53 65      Implemented..Se
    1149:	72 76 65 72 3a 20 41 56 52 5f 53 6d 61 6c 6c 5f     rver: AVR_Small_
    1159:	57 65 62 73 65 72 76 65 72 0d 0a 57 57 57 2d 41     Webserver..WWW-A
    1169:	75 74 68 65 6e 74 69 63 61 74 65 3a 20 42 61 73     uthenticate: Bas
    1179:	69 63 20 72 65 61 6c 6d 3d 22 4d 79 20 41 56 52     ic realm="My AVR
    1189:	20 77 65 62 20 73 65 72 76 65 72 22 0d 0a 43 6f      web server"..Co
    1199:	6e 74 65 6e 74 2d 54 79 70 65 3a 20 74 65 78 74     ntent-Type: text
    11a9:	2f 68 74 6d 6c 0d 0a 0d 0a 00                       /html.....

000011b3 <BASE64CODE>:
    11b3:	41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f 50     ABCDEFGHIJKLMNOP
    11c3:	51 52 53 54 55 56 57 58 59 5a 61 62 63 64 65 66     QRSTUVWXYZabcdef
    11d3:	67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76     ghijklmnopqrstuv
    11e3:	77 78 79 7a 30 31 32 33 34 35 36 37 38 39 2b 2f     wxyz0123456789+/
    11f3:	3d 00                                               =.

000011f5 <__c.1840>:
    11f5:	41 50 50 4c 59 3d 41 70 70 6c 79 00                 APPLY=Apply.

00001201 <__c.1838>:
    1201:	52 45 4c 41 59 34 3d 4f 4e 00                       RELAY4=ON.

0000120b <__c.1836>:
    120b:	52 45 4c 41 59 33 3d 4f 4e 00                       RELAY3=ON.

00001215 <__c.1834>:
    1215:	52 45 4c 41 59 32 3d 4f 4e 00                       RELAY2=ON.

0000121f <__c.1832>:
    121f:	52 45 4c 41 59 31 3d 4f 4e 00                       RELAY1=ON.

00001229 <__c.1830>:
    1229:	53 55 42 3d 53 75 62 6d 69 74 00                    SUB=Submit.

00001234 <__c.1691>:
    1234:	0a 0d 00                                            ...

00001237 <__c.1689>:
    1237:	0a 0d 4d 41 43 3a 20 00                             ..MAC: .

0000123f <__c.1687>:
    123f:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
    124f:	74 0d 0a 41 64 64 72 3a 20 00                       t..Addr: .

00001259 <__c.1677>:
    1259:	0a 0d 00                                            ...

0000125c <__c.1675>:
    125c:	47 61 74 65 77 61 79 20 3a 20 00                    Gateway : .

00001267 <__c.1673>:
    1267:	0a 0d 00                                            ...

0000126a <__c.1671>:
    126a:	4e 65 74 6d 61 73 6b 20 3a 20 00                    Netmask : .

00001275 <__c.1669>:
    1275:	0a 0d 00                                            ...

00001278 <__c.1667>:
    1278:	49 50 20 41 64 64 72 20 3a 20 00                    IP Addr : .

00001283 <__c.1662>:
    1283:	25 64 2e 25 64 2e 25 64 2e 25 64 00                 %d.%d.%d.%d.

0000128f <__c.1657>:
    128f:	25 78 3a 25 78 3a 25 78 3a 25 78 3a 25 78 3a 25     %x:%x:%x:%x:%x:%
    129f:	78 00                                               x.

000012a1 <__c.1844>:
    12a1:	47 65 74 74 69 6e 67 20 49 50 20 41 64 64 72 65     Getting IP Addre
    12b1:	73 73 2e 2e 2e 2e 0d 0a 00                          ss.......

000012ba <__c.1842>:
    12ba:	45 74 68 65 72 6e 65 74 20 63 68 69 70 20 69 6e     Ethernet chip in
    12ca:	69 74 0d 0a 00                                      it...

000012cf <__c.1840>:
    12cf:	49 6e 69 74 69 61 6c 69 7a 69 6e 67 20 4e 65 74     Initializing Net
    12df:	77 6f 72 6b 20 49 6e 74 65 72 66 61 63 65 20 61     work Interface a
    12ef:	6e 64 20 53 74 61 63 6b 0d 0a 00                    nd Stack...

000012fa <__c.1838>:
    12fa:	0d 0a 4e 54 54 61 6d 20 41 56 52 20 6e 65 74 77     ..NTTam AVR netw
    130a:	6f 72 6b 20 74 65 73 74 69 6e 67 20 77 69 74 68     ork testing with
    131a:	20 65 6e 63 32 38 6a 36 30 2e 0d 0a 00               enc28j60....

00001327 <__c.1832>:
    1327:	0a 0d 00                                            ...

0000132a <__c.1830>:
    132a:	44 65 66 61 75 6c 74 20 47 61 74 65 77 61 79 3a     Default Gateway:
    133a:	20 00                                                .

0000133c <__c.1828>:
    133c:	0a 0d 00                                            ...

0000133f <__c.1826>:
    133f:	53 75 62 6e 65 74 20 4d 61 73 6b 3a 20 00           Subnet Mask: .

0000134d <__c.1824>:
    134d:	0a 0d 00                                            ...

00001350 <__c.1822>:
    1350:	49 50 20 20 41 64 64 72 65 73 73 3a 20 00           IP  Address: .

0000135e <__c.1820>:
    135e:	0a 0d 00                                            ...

00001361 <__c.1818>:
    1361:	4d 41 43 20 41 64 64 72 65 73 73 3a 20 00           MAC Address: .

0000136f <HexTable>:
    136f:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

00001380 <__ctors_end>:
    1380:	11 24       	eor	r1, r1
    1382:	1f be       	out	0x3f, r1	; 63
    1384:	cf e5       	ldi	r28, 0x5F	; 95
    1386:	d8 e0       	ldi	r29, 0x08	; 8
    1388:	de bf       	out	0x3e, r29	; 62
    138a:	cd bf       	out	0x3d, r28	; 61

0000138c <__do_copy_data>:
    138c:	10 e0       	ldi	r17, 0x00	; 0
    138e:	a0 e6       	ldi	r26, 0x60	; 96
    1390:	b0 e0       	ldi	r27, 0x00	; 0
    1392:	e8 e8       	ldi	r30, 0x88	; 136
    1394:	f9 e5       	ldi	r31, 0x59	; 89
    1396:	02 c0       	rjmp	.+4      	; 0x139c <__do_copy_data+0x10>
    1398:	05 90       	lpm	r0, Z+
    139a:	0d 92       	st	X+, r0
    139c:	a0 38       	cpi	r26, 0x80	; 128
    139e:	b1 07       	cpc	r27, r17
    13a0:	d9 f7       	brne	.-10     	; 0x1398 <__do_copy_data+0xc>

000013a2 <__do_clear_bss>:
    13a2:	16 e0       	ldi	r17, 0x06	; 6
    13a4:	a0 e8       	ldi	r26, 0x80	; 128
    13a6:	b0 e0       	ldi	r27, 0x00	; 0
    13a8:	01 c0       	rjmp	.+2      	; 0x13ac <.do_clear_bss_start>

000013aa <.do_clear_bss_loop>:
    13aa:	1d 92       	st	X+, r1

000013ac <.do_clear_bss_start>:
    13ac:	a8 3f       	cpi	r26, 0xF8	; 248
    13ae:	b1 07       	cpc	r27, r17
    13b0:	e1 f7       	brne	.-8      	; 0x13aa <.do_clear_bss_loop>
    13b2:	0e 94 9a 20 	call	0x4134	; 0x4134 <main>
    13b6:	0c 94 c2 2c 	jmp	0x5984	; 0x5984 <_exit>

000013ba <__bad_interrupt>:
    13ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000013be <arpInit>:
//--------------------------------------------------------------------------------------
struct ARPentry ARPMyAddr;
struct ARPentry ARPTable[ARP_TABLE_SIZE];
//--------------------------------------------------------------------------------------
void arpInit(void)
{
    13be:	ee e8       	ldi	r30, 0x8E	; 142
    13c0:	f0 e0       	ldi	r31, 0x00	; 0
#include "ip.h"
//--------------------------------------------------------------------------------------
struct ARPentry ARPMyAddr;
struct ARPentry ARPTable[ARP_TABLE_SIZE];
//--------------------------------------------------------------------------------------
void arpInit(void)
    13c2:	86 ee       	ldi	r24, 0xE6	; 230
    13c4:	90 e0       	ldi	r25, 0x00	; 0
{
	unsigned char i;
	for(i=0; i<ARP_TABLE_SIZE; i++)
	{
		ARPTable[i].ipAddr = 0;
    13c6:	10 82       	st	Z, r1
    13c8:	11 82       	std	Z+1, r1	; 0x01
    13ca:	12 82       	std	Z+2, r1	; 0x02
    13cc:	13 82       	std	Z+3, r1	; 0x03
		ARPTable[i].time = 0;
    13ce:	12 86       	std	Z+10, r1	; 0x0a
    13d0:	3b 96       	adiw	r30, 0x0b	; 11
struct ARPentry ARPTable[ARP_TABLE_SIZE];
//--------------------------------------------------------------------------------------
void arpInit(void)
{
	unsigned char i;
	for(i=0; i<ARP_TABLE_SIZE; i++)
    13d2:	e8 17       	cp	r30, r24
    13d4:	f9 07       	cpc	r31, r25
    13d6:	b9 f7       	brne	.-18     	; 0x13c6 <arpInit+0x8>
	{
		ARPTable[i].ipAddr = 0;
		ARPTable[i].time = 0;
	}
}
    13d8:	08 95       	ret

000013da <arpSetAddress>:
//--------------------------------------------------------------------------------------
void arpSetAddress(struct ntEthAddr* ethAddr, unsigned long ipAddr)
{
	ARPMyAddr.ethAddr = *ethAddr;
    13da:	e7 e8       	ldi	r30, 0x87	; 135
    13dc:	f0 e0       	ldi	r31, 0x00	; 0
    13de:	28 2f       	mov	r18, r24
    13e0:	39 2f       	mov	r19, r25
    13e2:	d9 01       	movw	r26, r18
    13e4:	86 e0       	ldi	r24, 0x06	; 6
    13e6:	0d 90       	ld	r0, X+
    13e8:	01 92       	st	Z+, r0
    13ea:	81 50       	subi	r24, 0x01	; 1
    13ec:	e1 f7       	brne	.-8      	; 0x13e6 <arpSetAddress+0xc>
	ARPMyAddr.ipAddr = ipAddr;
    13ee:	40 93 83 00 	sts	0x0083, r20
    13f2:	50 93 84 00 	sts	0x0084, r21
    13f6:	60 93 85 00 	sts	0x0085, r22
    13fa:	70 93 86 00 	sts	0x0086, r23
}
    13fe:	08 95       	ret

00001400 <arpSearchIP>:
		if((ARPTable[i].ipAddr == ipaddr) && (ARPTable[i].time != 0))
		{
			return i;
		}
	}
	return -1;
    1400:	ee e8       	ldi	r30, 0x8E	; 142
    1402:	f0 e0       	ldi	r31, 0x00	; 0
}
//--------------------------------------------------------------------------------------
unsigned char arpSearchIP(unsigned long ipaddr)
{
	unsigned char i;
	for(i=0; i<ARP_TABLE_SIZE; i++)
    1404:	a0 e0       	ldi	r26, 0x00	; 0
	{
		if((ARPTable[i].ipAddr == ipaddr) && (ARPTable[i].time != 0))
    1406:	20 81       	ld	r18, Z
    1408:	31 81       	ldd	r19, Z+1	; 0x01
    140a:	42 81       	ldd	r20, Z+2	; 0x02
    140c:	53 81       	ldd	r21, Z+3	; 0x03
    140e:	26 17       	cp	r18, r22
    1410:	37 07       	cpc	r19, r23
    1412:	48 07       	cpc	r20, r24
    1414:	59 07       	cpc	r21, r25
    1416:	19 f4       	brne	.+6      	; 0x141e <arpSearchIP+0x1e>
    1418:	22 85       	ldd	r18, Z+10	; 0x0a
    141a:	22 23       	and	r18, r18
    141c:	29 f4       	brne	.+10     	; 0x1428 <arpSearchIP+0x28>
}
//--------------------------------------------------------------------------------------
unsigned char arpSearchIP(unsigned long ipaddr)
{
	unsigned char i;
	for(i=0; i<ARP_TABLE_SIZE; i++)
    141e:	af 5f       	subi	r26, 0xFF	; 255
    1420:	3b 96       	adiw	r30, 0x0b	; 11
    1422:	a8 30       	cpi	r26, 0x08	; 8
    1424:	81 f7       	brne	.-32     	; 0x1406 <arpSearchIP+0x6>
		if((ARPTable[i].ipAddr == ipaddr) && (ARPTable[i].time != 0))
		{
			return i;
		}
	}
	return -1;
    1426:	af ef       	ldi	r26, 0xFF	; 255
}
    1428:	8a 2f       	mov	r24, r26
    142a:	08 95       	ret

0000142c <arpUpdateEntry>:
//--------------------------------------------------------------------------------------
void arpUpdateEntry(struct ntEthAddr ethAddr,unsigned long ipAddr)
{
    142c:	ef 92       	push	r14
    142e:	ff 92       	push	r15
    1430:	0f 93       	push	r16
    1432:	1f 93       	push	r17
    1434:	df 93       	push	r29
    1436:	cf 93       	push	r28
    1438:	00 d0       	rcall	.+0      	; 0x143a <arpUpdateEntry+0xe>
    143a:	00 d0       	rcall	.+0      	; 0x143c <arpUpdateEntry+0x10>
    143c:	00 d0       	rcall	.+0      	; 0x143e <arpUpdateEntry+0x12>
    143e:	cd b7       	in	r28, 0x3d	; 61
    1440:	de b7       	in	r29, 0x3e	; 62
    1442:	49 83       	std	Y+1, r20	; 0x01
    1444:	5a 83       	std	Y+2, r21	; 0x02
    1446:	6b 83       	std	Y+3, r22	; 0x03
    1448:	7c 83       	std	Y+4, r23	; 0x04
    144a:	8d 83       	std	Y+5, r24	; 0x05
    144c:	9e 83       	std	Y+6, r25	; 0x06
    144e:	78 01       	movw	r14, r16
    1450:	89 01       	movw	r16, r18
	unsigned char index;
	index = arpSearchIP(ipAddr);
    1452:	c8 01       	movw	r24, r16
    1454:	b7 01       	movw	r22, r14
    1456:	0e 94 00 0a 	call	0x1400	; 0x1400 <arpSearchIP>
	if(index < ARP_TABLE_SIZE)
    145a:	88 30       	cpi	r24, 0x08	; 8
    145c:	28 f0       	brcs	.+10     	; 0x1468 <arpUpdateEntry+0x3c>
		#endif
		return;
	}
	for(index=0; index<ARP_TABLE_SIZE; index++)
	{
		if(!ARPTable[index].time)
    145e:	80 91 98 00 	lds	r24, 0x0098
    1462:	88 23       	and	r24, r24
    1464:	69 f5       	brne	.+90     	; 0x14c0 <arpUpdateEntry+0x94>
    1466:	36 c0       	rjmp	.+108    	; 0x14d4 <arpUpdateEntry+0xa8>
{
	unsigned char index;
	index = arpSearchIP(ipAddr);
	if(index < ARP_TABLE_SIZE)
	{
		ARPTable[index].ethAddr = ethAddr;
    1468:	90 e0       	ldi	r25, 0x00	; 0
    146a:	dc 01       	movw	r26, r24
    146c:	aa 0f       	add	r26, r26
    146e:	bb 1f       	adc	r27, r27
    1470:	9c 01       	movw	r18, r24
    1472:	22 0f       	add	r18, r18
    1474:	33 1f       	adc	r19, r19
    1476:	22 0f       	add	r18, r18
    1478:	33 1f       	adc	r19, r19
    147a:	22 0f       	add	r18, r18
    147c:	33 1f       	adc	r19, r19
    147e:	a2 0f       	add	r26, r18
    1480:	b3 1f       	adc	r27, r19
    1482:	a8 0f       	add	r26, r24
    1484:	b9 1f       	adc	r27, r25
    1486:	ae 56       	subi	r26, 0x6E	; 110
    1488:	bf 4f       	sbci	r27, 0xFF	; 255
    148a:	fe 01       	movw	r30, r28
    148c:	31 96       	adiw	r30, 0x01	; 1
    148e:	26 e0       	ldi	r18, 0x06	; 6
    1490:	01 90       	ld	r0, Z+
    1492:	0d 92       	st	X+, r0
    1494:	21 50       	subi	r18, 0x01	; 1
    1496:	e1 f7       	brne	.-8      	; 0x1490 <arpUpdateEntry+0x64>
		ARPTable[index].time = ARP_CACHE_TIME_TO_LIVE;
    1498:	fc 01       	movw	r30, r24
    149a:	ee 0f       	add	r30, r30
    149c:	ff 1f       	adc	r31, r31
    149e:	9c 01       	movw	r18, r24
    14a0:	22 0f       	add	r18, r18
    14a2:	33 1f       	adc	r19, r19
    14a4:	22 0f       	add	r18, r18
    14a6:	33 1f       	adc	r19, r19
    14a8:	22 0f       	add	r18, r18
    14aa:	33 1f       	adc	r19, r19
    14ac:	e2 0f       	add	r30, r18
    14ae:	f3 1f       	adc	r31, r19
    14b0:	8e 0f       	add	r24, r30
    14b2:	9f 1f       	adc	r25, r31
    14b4:	fc 01       	movw	r30, r24
    14b6:	e2 57       	subi	r30, 0x72	; 114
    14b8:	ff 4f       	sbci	r31, 0xFF	; 255
    14ba:	8a ef       	ldi	r24, 0xFA	; 250
    14bc:	82 87       	std	Z+10, r24	; 0x0a
		#ifdef ARP_DEBUG
		printf("Update ARP TTL %d: ",index);ipPrintAddr(ipAddr);
		printf("-");ethPrintAddr(&ethAddr);printf("\n\r");
		#endif
		return;
    14be:	3f c0       	rjmp	.+126    	; 0x153e <arpUpdateEntry+0x112>
    14c0:	e3 ea       	ldi	r30, 0xA3	; 163
    14c2:	f0 e0       	ldi	r31, 0x00	; 0
	}
	for(index=0; index<ARP_TABLE_SIZE; index++)
	{
		if(!ARPTable[index].time)
    14c4:	80 e0       	ldi	r24, 0x00	; 0
    14c6:	90 e0       	ldi	r25, 0x00	; 0
		}
	}
	return -1;
}
//--------------------------------------------------------------------------------------
void arpUpdateEntry(struct ntEthAddr ethAddr,unsigned long ipAddr)
    14c8:	01 96       	adiw	r24, 0x01	; 1
    14ca:	9c 01       	movw	r18, r24
		#endif
		return;
	}
	for(index=0; index<ARP_TABLE_SIZE; index++)
	{
		if(!ARPTable[index].time)
    14cc:	40 81       	ld	r20, Z
    14ce:	44 23       	and	r20, r20
    14d0:	91 f5       	brne	.+100    	; 0x1536 <arpUpdateEntry+0x10a>
    14d2:	02 c0       	rjmp	.+4      	; 0x14d8 <arpUpdateEntry+0xac>
    14d4:	20 e0       	ldi	r18, 0x00	; 0
    14d6:	30 e0       	ldi	r19, 0x00	; 0
		{
			ARPTable[index].ethAddr = ethAddr;
    14d8:	d9 01       	movw	r26, r18
    14da:	aa 0f       	add	r26, r26
    14dc:	bb 1f       	adc	r27, r27
    14de:	c9 01       	movw	r24, r18
    14e0:	88 0f       	add	r24, r24
    14e2:	99 1f       	adc	r25, r25
    14e4:	88 0f       	add	r24, r24
    14e6:	99 1f       	adc	r25, r25
    14e8:	88 0f       	add	r24, r24
    14ea:	99 1f       	adc	r25, r25
    14ec:	a8 0f       	add	r26, r24
    14ee:	b9 1f       	adc	r27, r25
    14f0:	a2 0f       	add	r26, r18
    14f2:	b3 1f       	adc	r27, r19
    14f4:	ae 56       	subi	r26, 0x6E	; 110
    14f6:	bf 4f       	sbci	r27, 0xFF	; 255
    14f8:	fe 01       	movw	r30, r28
    14fa:	31 96       	adiw	r30, 0x01	; 1
    14fc:	86 e0       	ldi	r24, 0x06	; 6
    14fe:	01 90       	ld	r0, Z+
    1500:	0d 92       	st	X+, r0
    1502:	81 50       	subi	r24, 0x01	; 1
    1504:	e1 f7       	brne	.-8      	; 0x14fe <arpUpdateEntry+0xd2>
			ARPTable[index].ipAddr = ipAddr;
    1506:	f9 01       	movw	r30, r18
    1508:	ee 0f       	add	r30, r30
    150a:	ff 1f       	adc	r31, r31
    150c:	c9 01       	movw	r24, r18
    150e:	88 0f       	add	r24, r24
    1510:	99 1f       	adc	r25, r25
    1512:	88 0f       	add	r24, r24
    1514:	99 1f       	adc	r25, r25
    1516:	88 0f       	add	r24, r24
    1518:	99 1f       	adc	r25, r25
    151a:	e8 0f       	add	r30, r24
    151c:	f9 1f       	adc	r31, r25
    151e:	2e 0f       	add	r18, r30
    1520:	3f 1f       	adc	r19, r31
    1522:	f9 01       	movw	r30, r18
    1524:	e2 57       	subi	r30, 0x72	; 114
    1526:	ff 4f       	sbci	r31, 0xFF	; 255
    1528:	e0 82       	st	Z, r14
    152a:	f1 82       	std	Z+1, r15	; 0x01
    152c:	02 83       	std	Z+2, r16	; 0x02
    152e:	13 83       	std	Z+3, r17	; 0x03
			ARPTable[index].time = ARP_CACHE_TIME_TO_LIVE;
    1530:	8a ef       	ldi	r24, 0xFA	; 250
    1532:	82 87       	std	Z+10, r24	; 0x0a
			#ifdef ARP_DEBUG
			printf("Update ARP: ");ipPrintAddr(ipAddr);
			printf("-");ethPrintAddr(&ethAddr);printf("\n\r");
			#endif
			return;
    1534:	04 c0       	rjmp	.+8      	; 0x153e <arpUpdateEntry+0x112>
    1536:	3b 96       	adiw	r30, 0x0b	; 11
		printf("Update ARP TTL %d: ",index);ipPrintAddr(ipAddr);
		printf("-");ethPrintAddr(&ethAddr);printf("\n\r");
		#endif
		return;
	}
	for(index=0; index<ARP_TABLE_SIZE; index++)
    1538:	87 30       	cpi	r24, 0x07	; 7
    153a:	91 05       	cpc	r25, r1
    153c:	29 f6       	brne	.-118    	; 0x14c8 <arpUpdateEntry+0x9c>
			printf("-");ethPrintAddr(&ethAddr);printf("\n\r");
			#endif
			return;
		}
	}
}
    153e:	26 96       	adiw	r28, 0x06	; 6
    1540:	0f b6       	in	r0, 0x3f	; 63
    1542:	f8 94       	cli
    1544:	de bf       	out	0x3e, r29	; 62
    1546:	0f be       	out	0x3f, r0	; 63
    1548:	cd bf       	out	0x3d, r28	; 61
    154a:	cf 91       	pop	r28
    154c:	df 91       	pop	r29
    154e:	1f 91       	pop	r17
    1550:	0f 91       	pop	r16
    1552:	ff 90       	pop	r15
    1554:	ef 90       	pop	r14
    1556:	08 95       	ret

00001558 <arpArpProcess>:
//--------------------------------------------------------------------------------------
void arpArpProcess(unsigned int len, unsigned char* ethFrame)
{
    1558:	8f 92       	push	r8
    155a:	9f 92       	push	r9
    155c:	af 92       	push	r10
    155e:	bf 92       	push	r11
    1560:	cf 92       	push	r12
    1562:	df 92       	push	r13
    1564:	ef 92       	push	r14
    1566:	ff 92       	push	r15
    1568:	0f 93       	push	r16
    156a:	1f 93       	push	r17
    156c:	cf 93       	push	r28
    156e:	df 93       	push	r29
    1570:	7c 01       	movw	r14, r24
    1572:	eb 01       	movw	r28, r22
	struct ntEthHeader* ethHeader;
	struct ntARPHeader* arpHeader;
	ethHeader = (struct ntEthHeader*)ethFrame;
	arpHeader = (struct ntARPHeader*)(ethFrame + ETH_HEADER_LEN);
    1574:	0f 2e       	mov	r0, r31
    1576:	fe e0       	ldi	r31, 0x0E	; 14
    1578:	cf 2e       	mov	r12, r31
    157a:	dd 24       	eor	r13, r13
    157c:	f0 2d       	mov	r31, r0
    157e:	c6 0e       	add	r12, r22
    1580:	d7 1e       	adc	r13, r23
	#ifdef ARP_DEBUG
	printf("Received ARP Request\r\n");
	arpPrintHeader(arpHeader);
	#endif
	if(	(arpHeader->hwType == 0x0100) &&
    1582:	8e 85       	ldd	r24, Y+14	; 0x0e
    1584:	9f 85       	ldd	r25, Y+15	; 0x0f
    1586:	21 e0       	ldi	r18, 0x01	; 1
    1588:	80 30       	cpi	r24, 0x00	; 0
    158a:	92 07       	cpc	r25, r18
    158c:	09 f0       	breq	.+2      	; 0x1590 <arpArpProcess+0x38>
    158e:	1c c1       	rjmp	.+568    	; 0x17c8 <arpArpProcess+0x270>
    1590:	f6 01       	movw	r30, r12
    1592:	82 81       	ldd	r24, Z+2	; 0x02
    1594:	93 81       	ldd	r25, Z+3	; 0x03
    1596:	88 30       	cpi	r24, 0x08	; 8
    1598:	91 05       	cpc	r25, r1
    159a:	09 f0       	breq	.+2      	; 0x159e <arpArpProcess+0x46>
    159c:	15 c1       	rjmp	.+554    	; 0x17c8 <arpArpProcess+0x270>
		(arpHeader->protocol == 0x0008)  &&
    159e:	84 81       	ldd	r24, Z+4	; 0x04
    15a0:	86 30       	cpi	r24, 0x06	; 6
    15a2:	09 f0       	breq	.+2      	; 0x15a6 <arpArpProcess+0x4e>
    15a4:	11 c1       	rjmp	.+546    	; 0x17c8 <arpArpProcess+0x270>
		(arpHeader->hwLen == 0x06) && 
    15a6:	85 81       	ldd	r24, Z+5	; 0x05
    15a8:	84 30       	cpi	r24, 0x04	; 4
    15aa:	09 f0       	breq	.+2      	; 0x15ae <arpArpProcess+0x56>
    15ac:	0d c1       	rjmp	.+538    	; 0x17c8 <arpArpProcess+0x270>
		(arpHeader->protoLen == 0x04) &&
		(arpHeader->dipaddr == HTONL(ARPMyAddr.ipAddr))){
    15ae:	20 91 83 00 	lds	r18, 0x0083
    15b2:	30 91 84 00 	lds	r19, 0x0084
    15b6:	40 91 85 00 	lds	r20, 0x0085
    15ba:	50 91 86 00 	lds	r21, 0x0086
    15be:	85 2e       	mov	r8, r21
    15c0:	99 24       	eor	r9, r9
    15c2:	aa 24       	eor	r10, r10
    15c4:	bb 24       	eor	r11, r11
    15c6:	b2 2f       	mov	r27, r18
    15c8:	aa 27       	eor	r26, r26
    15ca:	99 27       	eor	r25, r25
    15cc:	88 27       	eor	r24, r24
    15ce:	88 2a       	or	r8, r24
    15d0:	99 2a       	or	r9, r25
    15d2:	aa 2a       	or	r10, r26
    15d4:	bb 2a       	or	r11, r27
    15d6:	da 01       	movw	r26, r20
    15d8:	c9 01       	movw	r24, r18
    15da:	80 70       	andi	r24, 0x00	; 0
    15dc:	90 70       	andi	r25, 0x00	; 0
    15de:	b0 70       	andi	r27, 0x00	; 0
    15e0:	89 2f       	mov	r24, r25
    15e2:	9a 2f       	mov	r25, r26
    15e4:	ab 2f       	mov	r26, r27
    15e6:	bb 27       	eor	r27, r27
    15e8:	88 29       	or	r24, r8
    15ea:	99 29       	or	r25, r9
    15ec:	aa 29       	or	r26, r10
    15ee:	bb 29       	or	r27, r11
    15f0:	20 70       	andi	r18, 0x00	; 0
    15f2:	40 70       	andi	r20, 0x00	; 0
    15f4:	50 70       	andi	r21, 0x00	; 0
    15f6:	54 2f       	mov	r21, r20
    15f8:	43 2f       	mov	r20, r19
    15fa:	32 2f       	mov	r19, r18
    15fc:	22 27       	eor	r18, r18
    15fe:	28 2b       	or	r18, r24
    1600:	39 2b       	or	r19, r25
    1602:	4a 2b       	or	r20, r26
    1604:	5b 2b       	or	r21, r27
	arpPrintHeader(arpHeader);
	#endif
	if(	(arpHeader->hwType == 0x0100) &&
		(arpHeader->protocol == 0x0008)  &&
		(arpHeader->hwLen == 0x06) && 
		(arpHeader->protoLen == 0x04) &&
    1606:	80 8d       	ldd	r24, Z+24	; 0x18
    1608:	91 8d       	ldd	r25, Z+25	; 0x19
    160a:	a2 8d       	ldd	r26, Z+26	; 0x1a
    160c:	b3 8d       	ldd	r27, Z+27	; 0x1b
    160e:	82 17       	cp	r24, r18
    1610:	93 07       	cpc	r25, r19
    1612:	a4 07       	cpc	r26, r20
    1614:	b5 07       	cpc	r27, r21
    1616:	09 f0       	breq	.+2      	; 0x161a <arpArpProcess+0xc2>
    1618:	d7 c0       	rjmp	.+430    	; 0x17c8 <arpArpProcess+0x270>
		(arpHeader->dipaddr == HTONL(ARPMyAddr.ipAddr))){
		if(arpHeader->opcode == HTONS(ARP_OPCODE_REQUEST)){
    161a:	86 81       	ldd	r24, Z+6	; 0x06
    161c:	97 81       	ldd	r25, Z+7	; 0x07
    161e:	f1 e0       	ldi	r31, 0x01	; 1
    1620:	80 30       	cpi	r24, 0x00	; 0
    1622:	9f 07       	cpc	r25, r31
    1624:	09 f0       	breq	.+2      	; 0x1628 <arpArpProcess+0xd0>
    1626:	99 c0       	rjmp	.+306    	; 0x175a <arpArpProcess+0x202>
			arpUpdateEntry(arpHeader->shwaddr,HTONL(arpHeader->sipaddr));
    1628:	f6 01       	movw	r30, r12
    162a:	26 85       	ldd	r18, Z+14	; 0x0e
    162c:	37 85       	ldd	r19, Z+15	; 0x0f
    162e:	40 89       	ldd	r20, Z+16	; 0x10
    1630:	51 89       	ldd	r21, Z+17	; 0x11
    1632:	85 2e       	mov	r8, r21
    1634:	99 24       	eor	r9, r9
    1636:	aa 24       	eor	r10, r10
    1638:	bb 24       	eor	r11, r11
    163a:	b2 2f       	mov	r27, r18
    163c:	aa 27       	eor	r26, r26
    163e:	99 27       	eor	r25, r25
    1640:	88 27       	eor	r24, r24
    1642:	88 2a       	or	r8, r24
    1644:	99 2a       	or	r9, r25
    1646:	aa 2a       	or	r10, r26
    1648:	bb 2a       	or	r11, r27
    164a:	da 01       	movw	r26, r20
    164c:	c9 01       	movw	r24, r18
    164e:	80 70       	andi	r24, 0x00	; 0
    1650:	90 70       	andi	r25, 0x00	; 0
    1652:	b0 70       	andi	r27, 0x00	; 0
    1654:	89 2f       	mov	r24, r25
    1656:	9a 2f       	mov	r25, r26
    1658:	ab 2f       	mov	r26, r27
    165a:	bb 27       	eor	r27, r27
    165c:	88 29       	or	r24, r8
    165e:	99 29       	or	r25, r9
    1660:	aa 29       	or	r26, r10
    1662:	bb 29       	or	r27, r11
    1664:	20 70       	andi	r18, 0x00	; 0
    1666:	40 70       	andi	r20, 0x00	; 0
    1668:	50 70       	andi	r21, 0x00	; 0
    166a:	00 27       	eor	r16, r16
    166c:	12 2f       	mov	r17, r18
    166e:	23 2f       	mov	r18, r19
    1670:	34 2f       	mov	r19, r20
    1672:	08 2b       	or	r16, r24
    1674:	19 2b       	or	r17, r25
    1676:	2a 2b       	or	r18, r26
    1678:	3b 2b       	or	r19, r27
    167a:	40 85       	ldd	r20, Z+8	; 0x08
    167c:	51 85       	ldd	r21, Z+9	; 0x09
    167e:	62 85       	ldd	r22, Z+10	; 0x0a
    1680:	73 85       	ldd	r23, Z+11	; 0x0b
    1682:	84 85       	ldd	r24, Z+12	; 0x0c
    1684:	95 85       	ldd	r25, Z+13	; 0x0d
    1686:	0e 94 16 0a 	call	0x142c	; 0x142c <arpUpdateEntry>
			arpHeader->dhwaddr = arpHeader->shwaddr;
    168a:	d6 01       	movw	r26, r12
    168c:	52 96       	adiw	r26, 0x12	; 18
    168e:	f6 01       	movw	r30, r12
    1690:	38 96       	adiw	r30, 0x08	; 8
    1692:	86 e0       	ldi	r24, 0x06	; 6
    1694:	01 90       	ld	r0, Z+
    1696:	0d 92       	st	X+, r0
    1698:	81 50       	subi	r24, 0x01	; 1
    169a:	e1 f7       	brne	.-8      	; 0x1694 <arpArpProcess+0x13c>
			arpHeader->dipaddr = arpHeader->sipaddr;
    169c:	f6 01       	movw	r30, r12
    169e:	86 85       	ldd	r24, Z+14	; 0x0e
    16a0:	97 85       	ldd	r25, Z+15	; 0x0f
    16a2:	a0 89       	ldd	r26, Z+16	; 0x10
    16a4:	b1 89       	ldd	r27, Z+17	; 0x11
    16a6:	80 8f       	std	Z+24, r24	; 0x18
    16a8:	91 8f       	std	Z+25, r25	; 0x19
    16aa:	a2 8f       	std	Z+26, r26	; 0x1a
    16ac:	b3 8f       	std	Z+27, r27	; 0x1b
			arpHeader->shwaddr = ARPMyAddr.ethAddr;
    16ae:	d6 01       	movw	r26, r12
    16b0:	18 96       	adiw	r26, 0x08	; 8
    16b2:	e7 e8       	ldi	r30, 0x87	; 135
    16b4:	f0 e0       	ldi	r31, 0x00	; 0
    16b6:	86 e0       	ldi	r24, 0x06	; 6
    16b8:	01 90       	ld	r0, Z+
    16ba:	0d 92       	st	X+, r0
    16bc:	81 50       	subi	r24, 0x01	; 1
    16be:	e1 f7       	brne	.-8      	; 0x16b8 <arpArpProcess+0x160>
			arpHeader->sipaddr = HTONL(ARPMyAddr.ipAddr);
    16c0:	20 91 83 00 	lds	r18, 0x0083
    16c4:	30 91 84 00 	lds	r19, 0x0084
    16c8:	40 91 85 00 	lds	r20, 0x0085
    16cc:	50 91 86 00 	lds	r21, 0x0086
    16d0:	85 2e       	mov	r8, r21
    16d2:	99 24       	eor	r9, r9
    16d4:	aa 24       	eor	r10, r10
    16d6:	bb 24       	eor	r11, r11
    16d8:	b2 2f       	mov	r27, r18
    16da:	aa 27       	eor	r26, r26
    16dc:	99 27       	eor	r25, r25
    16de:	88 27       	eor	r24, r24
    16e0:	88 2a       	or	r8, r24
    16e2:	99 2a       	or	r9, r25
    16e4:	aa 2a       	or	r10, r26
    16e6:	bb 2a       	or	r11, r27
    16e8:	da 01       	movw	r26, r20
    16ea:	c9 01       	movw	r24, r18
    16ec:	80 70       	andi	r24, 0x00	; 0
    16ee:	90 70       	andi	r25, 0x00	; 0
    16f0:	b0 70       	andi	r27, 0x00	; 0
    16f2:	89 2f       	mov	r24, r25
    16f4:	9a 2f       	mov	r25, r26
    16f6:	ab 2f       	mov	r26, r27
    16f8:	bb 27       	eor	r27, r27
    16fa:	88 2a       	or	r8, r24
    16fc:	99 2a       	or	r9, r25
    16fe:	aa 2a       	or	r10, r26
    1700:	bb 2a       	or	r11, r27
    1702:	da 01       	movw	r26, r20
    1704:	c9 01       	movw	r24, r18
    1706:	80 70       	andi	r24, 0x00	; 0
    1708:	a0 70       	andi	r26, 0x00	; 0
    170a:	b0 70       	andi	r27, 0x00	; 0
    170c:	ba 2f       	mov	r27, r26
    170e:	a9 2f       	mov	r26, r25
    1710:	98 2f       	mov	r25, r24
    1712:	88 27       	eor	r24, r24
    1714:	88 29       	or	r24, r8
    1716:	99 29       	or	r25, r9
    1718:	aa 29       	or	r26, r10
    171a:	bb 29       	or	r27, r11
    171c:	f6 01       	movw	r30, r12
    171e:	86 87       	std	Z+14, r24	; 0x0e
    1720:	97 87       	std	Z+15, r25	; 0x0f
    1722:	a0 8b       	std	Z+16, r26	; 0x10
    1724:	b1 8b       	std	Z+17, r27	; 0x11
			arpHeader->opcode = HTONS(ARP_OPCODE_REPLY);
    1726:	80 e0       	ldi	r24, 0x00	; 0
    1728:	92 e0       	ldi	r25, 0x02	; 2
    172a:	97 83       	std	Z+7, r25	; 0x07
    172c:	86 83       	std	Z+6, r24	; 0x06
			ethHeader->desAddr = ethHeader->srcAddr;
    172e:	de 01       	movw	r26, r28
    1730:	fe 01       	movw	r30, r28
    1732:	36 96       	adiw	r30, 0x06	; 6
    1734:	86 e0       	ldi	r24, 0x06	; 6
    1736:	01 90       	ld	r0, Z+
    1738:	0d 92       	st	X+, r0
    173a:	81 50       	subi	r24, 0x01	; 1
    173c:	e1 f7       	brne	.-8      	; 0x1736 <arpArpProcess+0x1de>
			ethHeader->srcAddr  = ARPMyAddr.ethAddr;
    173e:	de 01       	movw	r26, r28
    1740:	16 96       	adiw	r26, 0x06	; 6
    1742:	e7 e8       	ldi	r30, 0x87	; 135
    1744:	f0 e0       	ldi	r31, 0x00	; 0
    1746:	86 e0       	ldi	r24, 0x06	; 6
    1748:	01 90       	ld	r0, Z+
    174a:	0d 92       	st	X+, r0
    174c:	81 50       	subi	r24, 0x01	; 1
    174e:	e1 f7       	brne	.-8      	; 0x1748 <arpArpProcess+0x1f0>
			#ifdef ARP_DEBUG
			printf("Sending ARP Reply\r\n");
			arpPrintHeader(arpHeader);
			#endif
			ethSendFrame(len, (unsigned char*)ethHeader);
    1750:	c7 01       	movw	r24, r14
    1752:	be 01       	movw	r22, r28
    1754:	0e 94 ec 14 	call	0x29d8	; 0x29d8 <ethSendFrame>
			return;
    1758:	37 c0       	rjmp	.+110    	; 0x17c8 <arpArpProcess+0x270>
		}
		if(arpHeader->opcode == HTONS(ARP_OPCODE_REPLY)){
    175a:	f2 e0       	ldi	r31, 0x02	; 2
    175c:	80 30       	cpi	r24, 0x00	; 0
    175e:	9f 07       	cpc	r25, r31
    1760:	99 f5       	brne	.+102    	; 0x17c8 <arpArpProcess+0x270>
			arpUpdateEntry(arpHeader->shwaddr,HTONL(arpHeader->sipaddr));
    1762:	f6 01       	movw	r30, r12
    1764:	86 85       	ldd	r24, Z+14	; 0x0e
    1766:	97 85       	ldd	r25, Z+15	; 0x0f
    1768:	a0 89       	ldd	r26, Z+16	; 0x10
    176a:	b1 89       	ldd	r27, Z+17	; 0x11
    176c:	eb 2e       	mov	r14, r27
    176e:	ff 24       	eor	r15, r15
    1770:	00 27       	eor	r16, r16
    1772:	11 27       	eor	r17, r17
    1774:	58 2f       	mov	r21, r24
    1776:	44 27       	eor	r20, r20
    1778:	33 27       	eor	r19, r19
    177a:	22 27       	eor	r18, r18
    177c:	e2 2a       	or	r14, r18
    177e:	f3 2a       	or	r15, r19
    1780:	04 2b       	or	r16, r20
    1782:	15 2b       	or	r17, r21
    1784:	9c 01       	movw	r18, r24
    1786:	ad 01       	movw	r20, r26
    1788:	20 70       	andi	r18, 0x00	; 0
    178a:	30 70       	andi	r19, 0x00	; 0
    178c:	50 70       	andi	r21, 0x00	; 0
    178e:	23 2f       	mov	r18, r19
    1790:	34 2f       	mov	r19, r20
    1792:	45 2f       	mov	r20, r21
    1794:	55 27       	eor	r21, r21
    1796:	2e 29       	or	r18, r14
    1798:	3f 29       	or	r19, r15
    179a:	40 2b       	or	r20, r16
    179c:	51 2b       	or	r21, r17
    179e:	80 70       	andi	r24, 0x00	; 0
    17a0:	a0 70       	andi	r26, 0x00	; 0
    17a2:	b0 70       	andi	r27, 0x00	; 0
    17a4:	ba 2f       	mov	r27, r26
    17a6:	a9 2f       	mov	r26, r25
    17a8:	98 2f       	mov	r25, r24
    17aa:	88 27       	eor	r24, r24
    17ac:	89 01       	movw	r16, r18
    17ae:	9a 01       	movw	r18, r20
    17b0:	08 2b       	or	r16, r24
    17b2:	19 2b       	or	r17, r25
    17b4:	2a 2b       	or	r18, r26
    17b6:	3b 2b       	or	r19, r27
    17b8:	40 85       	ldd	r20, Z+8	; 0x08
    17ba:	51 85       	ldd	r21, Z+9	; 0x09
    17bc:	62 85       	ldd	r22, Z+10	; 0x0a
    17be:	73 85       	ldd	r23, Z+11	; 0x0b
    17c0:	84 85       	ldd	r24, Z+12	; 0x0c
    17c2:	95 85       	ldd	r25, Z+13	; 0x0d
    17c4:	0e 94 16 0a 	call	0x142c	; 0x142c <arpUpdateEntry>
		}
	}
	#ifdef ARP_DEBUG
	printf("Unknown ARP packet\r\n");
	#endif
}
    17c8:	df 91       	pop	r29
    17ca:	cf 91       	pop	r28
    17cc:	1f 91       	pop	r17
    17ce:	0f 91       	pop	r16
    17d0:	ff 90       	pop	r15
    17d2:	ef 90       	pop	r14
    17d4:	df 90       	pop	r13
    17d6:	cf 90       	pop	r12
    17d8:	bf 90       	pop	r11
    17da:	af 90       	pop	r10
    17dc:	9f 90       	pop	r9
    17de:	8f 90       	pop	r8
    17e0:	08 95       	ret

000017e2 <arpIPPacketIn>:
//--------------------------------------------------------------------------------------
void arpIPPacketIn(unsigned char* ethFrame)
{
    17e2:	0f 93       	push	r16
    17e4:	1f 93       	push	r17
    17e6:	fc 01       	movw	r30, r24
	struct ntEthHeader* ethHeader;
	struct ntIPHeader* ipHeader;
	ethHeader = (struct ntEthHeader*)ethFrame;
	ipHeader = (struct ntIPHeader*)(ethFrame + ETH_HEADER_LEN);
	arpUpdateEntry(ethHeader->srcAddr,HTONL(ipHeader->srcIPAddr));
    17e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    17ea:	93 8d       	ldd	r25, Z+27	; 0x1b
    17ec:	a4 8d       	ldd	r26, Z+28	; 0x1c
    17ee:	b5 8d       	ldd	r27, Z+29	; 0x1d
    17f0:	4b 2f       	mov	r20, r27
    17f2:	55 27       	eor	r21, r21
    17f4:	66 27       	eor	r22, r22
    17f6:	77 27       	eor	r23, r23
    17f8:	38 2f       	mov	r19, r24
    17fa:	22 27       	eor	r18, r18
    17fc:	11 27       	eor	r17, r17
    17fe:	00 27       	eor	r16, r16
    1800:	40 2b       	or	r20, r16
    1802:	51 2b       	or	r21, r17
    1804:	62 2b       	or	r22, r18
    1806:	73 2b       	or	r23, r19
    1808:	8c 01       	movw	r16, r24
    180a:	9d 01       	movw	r18, r26
    180c:	00 70       	andi	r16, 0x00	; 0
    180e:	10 70       	andi	r17, 0x00	; 0
    1810:	30 70       	andi	r19, 0x00	; 0
    1812:	01 2f       	mov	r16, r17
    1814:	12 2f       	mov	r17, r18
    1816:	23 2f       	mov	r18, r19
    1818:	33 27       	eor	r19, r19
    181a:	04 2b       	or	r16, r20
    181c:	15 2b       	or	r17, r21
    181e:	26 2b       	or	r18, r22
    1820:	37 2b       	or	r19, r23
    1822:	80 70       	andi	r24, 0x00	; 0
    1824:	a0 70       	andi	r26, 0x00	; 0
    1826:	b0 70       	andi	r27, 0x00	; 0
    1828:	ba 2f       	mov	r27, r26
    182a:	a9 2f       	mov	r26, r25
    182c:	98 2f       	mov	r25, r24
    182e:	88 27       	eor	r24, r24
    1830:	08 2b       	or	r16, r24
    1832:	19 2b       	or	r17, r25
    1834:	2a 2b       	or	r18, r26
    1836:	3b 2b       	or	r19, r27
    1838:	46 81       	ldd	r20, Z+6	; 0x06
    183a:	57 81       	ldd	r21, Z+7	; 0x07
    183c:	60 85       	ldd	r22, Z+8	; 0x08
    183e:	71 85       	ldd	r23, Z+9	; 0x09
    1840:	82 85       	ldd	r24, Z+10	; 0x0a
    1842:	93 85       	ldd	r25, Z+11	; 0x0b
    1844:	0e 94 16 0a 	call	0x142c	; 0x142c <arpUpdateEntry>
}
    1848:	1f 91       	pop	r17
    184a:	0f 91       	pop	r16
    184c:	08 95       	ret

0000184e <arpIpOut>:
//--------------------------------------------------------------------------------------
void arpIpOut(unsigned char* ethFrame, unsigned long phyDstIp)
{
    184e:	ef 92       	push	r14
    1850:	ff 92       	push	r15
    1852:	0f 93       	push	r16
    1854:	1f 93       	push	r17
    1856:	cf 93       	push	r28
    1858:	df 93       	push	r29
    185a:	ec 01       	movw	r28, r24
	struct ntEthHeader* ethHeader;
	struct ntIPHeader* ipHeader;
	ethHeader = (struct ntEthHeader*)ethFrame;
	ipHeader = (struct ntIPHeader*)(ethFrame + ETH_HEADER_LEN);

	if(phyDstIp)
    185c:	41 15       	cp	r20, r1
    185e:	51 05       	cpc	r21, r1
    1860:	61 05       	cpc	r22, r1
    1862:	71 05       	cpc	r23, r1
    1864:	29 f0       	breq	.+10     	; 0x1870 <arpIpOut+0x22>
		index = arpSearchIP(phyDstIp);
    1866:	cb 01       	movw	r24, r22
    1868:	ba 01       	movw	r22, r20
    186a:	0e 94 00 0a 	call	0x1400	; 0x1400 <arpSearchIP>
    186e:	2a c0       	rjmp	.+84     	; 0x18c4 <arpIpOut+0x76>
	else
		index = arpSearchIP(HTONL(ipHeader->desIPAddr));
    1870:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1872:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1874:	a8 a1       	ldd	r26, Y+32	; 0x20
    1876:	b9 a1       	ldd	r27, Y+33	; 0x21
    1878:	eb 2e       	mov	r14, r27
    187a:	ff 24       	eor	r15, r15
    187c:	00 27       	eor	r16, r16
    187e:	11 27       	eor	r17, r17
    1880:	58 2f       	mov	r21, r24
    1882:	44 27       	eor	r20, r20
    1884:	33 27       	eor	r19, r19
    1886:	22 27       	eor	r18, r18
    1888:	e2 2a       	or	r14, r18
    188a:	f3 2a       	or	r15, r19
    188c:	04 2b       	or	r16, r20
    188e:	15 2b       	or	r17, r21
    1890:	9c 01       	movw	r18, r24
    1892:	ad 01       	movw	r20, r26
    1894:	20 70       	andi	r18, 0x00	; 0
    1896:	30 70       	andi	r19, 0x00	; 0
    1898:	50 70       	andi	r21, 0x00	; 0
    189a:	23 2f       	mov	r18, r19
    189c:	34 2f       	mov	r19, r20
    189e:	45 2f       	mov	r20, r21
    18a0:	55 27       	eor	r21, r21
    18a2:	2e 29       	or	r18, r14
    18a4:	3f 29       	or	r19, r15
    18a6:	40 2b       	or	r20, r16
    18a8:	51 2b       	or	r21, r17
    18aa:	80 70       	andi	r24, 0x00	; 0
    18ac:	a0 70       	andi	r26, 0x00	; 0
    18ae:	b0 70       	andi	r27, 0x00	; 0
    18b0:	66 27       	eor	r22, r22
    18b2:	78 2f       	mov	r23, r24
    18b4:	89 2f       	mov	r24, r25
    18b6:	9a 2f       	mov	r25, r26
    18b8:	62 2b       	or	r22, r18
    18ba:	73 2b       	or	r23, r19
    18bc:	84 2b       	or	r24, r20
    18be:	95 2b       	or	r25, r21
    18c0:	0e 94 00 0a 	call	0x1400	; 0x1400 <arpSearchIP>
	if(index < ARP_TABLE_SIZE)
    18c4:	88 30       	cpi	r24, 0x08	; 8
    18c6:	30 f5       	brcc	.+76     	; 0x1914 <arpIpOut+0xc6>
	{
		ethHeader->srcAddr  = ARPMyAddr.ethAddr;
    18c8:	de 01       	movw	r26, r28
    18ca:	16 96       	adiw	r26, 0x06	; 6
    18cc:	e7 e8       	ldi	r30, 0x87	; 135
    18ce:	f0 e0       	ldi	r31, 0x00	; 0
    18d0:	96 e0       	ldi	r25, 0x06	; 6
    18d2:	01 90       	ld	r0, Z+
    18d4:	0d 92       	st	X+, r0
    18d6:	91 50       	subi	r25, 0x01	; 1
    18d8:	e1 f7       	brne	.-8      	; 0x18d2 <arpIpOut+0x84>
		ethHeader->desAddr = ARPTable[index].ethAddr;
    18da:	90 e0       	ldi	r25, 0x00	; 0
    18dc:	fc 01       	movw	r30, r24
    18de:	ee 0f       	add	r30, r30
    18e0:	ff 1f       	adc	r31, r31
    18e2:	9c 01       	movw	r18, r24
    18e4:	22 0f       	add	r18, r18
    18e6:	33 1f       	adc	r19, r19
    18e8:	22 0f       	add	r18, r18
    18ea:	33 1f       	adc	r19, r19
    18ec:	22 0f       	add	r18, r18
    18ee:	33 1f       	adc	r19, r19
    18f0:	e2 0f       	add	r30, r18
    18f2:	f3 1f       	adc	r31, r19
    18f4:	8e 0f       	add	r24, r30
    18f6:	9f 1f       	adc	r25, r31
    18f8:	de 01       	movw	r26, r28
    18fa:	fc 01       	movw	r30, r24
    18fc:	ee 56       	subi	r30, 0x6E	; 110
    18fe:	ff 4f       	sbci	r31, 0xFF	; 255
    1900:	86 e0       	ldi	r24, 0x06	; 6
    1902:	01 90       	ld	r0, Z+
    1904:	0d 92       	st	X+, r0
    1906:	81 50       	subi	r24, 0x01	; 1
    1908:	e1 f7       	brne	.-8      	; 0x1902 <arpIpOut+0xb4>
		ethHeader->type = HTONS(ETH_TYPE_IP);
    190a:	88 e0       	ldi	r24, 0x08	; 8
    190c:	90 e0       	ldi	r25, 0x00	; 0
    190e:	9d 87       	std	Y+13, r25	; 0x0d
    1910:	8c 87       	std	Y+12, r24	; 0x0c
    1912:	14 c0       	rjmp	.+40     	; 0x193c <arpIpOut+0xee>
	}
	else
	{
		ethHeader->srcAddr = ARPMyAddr.ethAddr;
    1914:	de 01       	movw	r26, r28
    1916:	16 96       	adiw	r26, 0x06	; 6
    1918:	e7 e8       	ldi	r30, 0x87	; 135
    191a:	f0 e0       	ldi	r31, 0x00	; 0
    191c:	86 e0       	ldi	r24, 0x06	; 6
    191e:	01 90       	ld	r0, Z+
    1920:	0d 92       	st	X+, r0
    1922:	81 50       	subi	r24, 0x01	; 1
    1924:	e1 f7       	brne	.-8      	; 0x191e <arpIpOut+0xd0>
		ethHeader->desAddr.addr[0] = 0xFF;
    1926:	8f ef       	ldi	r24, 0xFF	; 255
    1928:	88 83       	st	Y, r24
		ethHeader->desAddr.addr[1] = 0xFF;
    192a:	89 83       	std	Y+1, r24	; 0x01
		ethHeader->desAddr.addr[2] = 0xFF;
    192c:	8a 83       	std	Y+2, r24	; 0x02
		ethHeader->desAddr.addr[3] = 0xFF;
    192e:	8b 83       	std	Y+3, r24	; 0x03
		ethHeader->desAddr.addr[4] = 0xFF;
    1930:	8c 83       	std	Y+4, r24	; 0x04
		ethHeader->desAddr.addr[5] = 0xFF;
    1932:	8d 83       	std	Y+5, r24	; 0x05
		ethHeader->type = HTONS(ETH_TYPE_IP);
    1934:	88 e0       	ldi	r24, 0x08	; 8
    1936:	90 e0       	ldi	r25, 0x00	; 0
    1938:	9d 87       	std	Y+13, r25	; 0x0d
    193a:	8c 87       	std	Y+12, r24	; 0x0c
	#ifdef ARP_DEBUG
	printf("ARP Result:");
	ipPrintAddr(ARPTable[index].ipAddr);printf("-");
	ethPrintAddr(&(ethHeader->desAddr));printf("\r\n");
	#endif
}
    193c:	df 91       	pop	r29
    193e:	cf 91       	pop	r28
    1940:	1f 91       	pop	r17
    1942:	0f 91       	pop	r16
    1944:	ff 90       	pop	r15
    1946:	ef 90       	pop	r14
    1948:	08 95       	ret

0000194a <arpTimer>:
//--------------------------------------------------------------------------------------
void arpTimer(void)
//Goi moi 10s
{
    194a:	e8 e9       	ldi	r30, 0x98	; 152
    194c:	f0 e0       	ldi	r31, 0x00	; 0
	ipPrintAddr(ARPTable[index].ipAddr);printf("-");
	ethPrintAddr(&(ethHeader->desAddr));printf("\r\n");
	#endif
}
//--------------------------------------------------------------------------------------
void arpTimer(void)
    194e:	80 ef       	ldi	r24, 0xF0	; 240
    1950:	90 e0       	ldi	r25, 0x00	; 0
//Goi moi 10s
{
	int index;
	for(index=0; index<ARP_TABLE_SIZE; index++)
	{
		if(ARPTable[index].time)
    1952:	20 81       	ld	r18, Z
    1954:	22 23       	and	r18, r18
    1956:	11 f0       	breq	.+4      	; 0x195c <arpTimer+0x12>
			ARPTable[index].time--;
    1958:	21 50       	subi	r18, 0x01	; 1
    195a:	20 83       	st	Z, r18
    195c:	3b 96       	adiw	r30, 0x0b	; 11
//--------------------------------------------------------------------------------------
void arpTimer(void)
//Goi moi 10s
{
	int index;
	for(index=0; index<ARP_TABLE_SIZE; index++)
    195e:	e8 17       	cp	r30, r24
    1960:	f9 07       	cpc	r31, r25
    1962:	b9 f7       	brne	.-18     	; 0x1952 <arpTimer+0x8>
	{
		if(ARPTable[index].time)
			ARPTable[index].time--;
	}
}
    1964:	08 95       	ret

00001966 <dhcpInit>:
unsigned char DhcpRetries;
//--------------------------------------------------------------------------------------
//Ham khoi tao cac thong so ban dau cho DHCP
void dhcpInit(void)
{
	ethGetMacAddress(macaddr);
    1966:	83 ef       	ldi	r24, 0xF3	; 243
    1968:	90 e0       	ldi	r25, 0x00	; 0
    196a:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <ethGetMacAddress>
	DhcpTransactID = *((unsigned long*)&macaddr[0]);
    196e:	80 91 f3 00 	lds	r24, 0x00F3
    1972:	90 91 f4 00 	lds	r25, 0x00F4
    1976:	a0 91 f5 00 	lds	r26, 0x00F5
    197a:	b0 91 f6 00 	lds	r27, 0x00F6
    197e:	80 93 e6 00 	sts	0x00E6, r24
    1982:	90 93 e7 00 	sts	0x00E7, r25
    1986:	a0 93 e8 00 	sts	0x00E8, r26
    198a:	b0 93 e9 00 	sts	0x00E9, r27
	DhcpLeaseTime = 0;
    198e:	10 92 eb 00 	sts	0x00EB, r1
    1992:	10 92 ec 00 	sts	0x00EC, r1
    1996:	10 92 ed 00 	sts	0x00ED, r1
    199a:	10 92 ee 00 	sts	0x00EE, r1
	DhcpTimeout = 1;
    199e:	81 e0       	ldi	r24, 0x01	; 1
    19a0:	80 93 f9 00 	sts	0x00F9, r24
	DhcpRetries = DHCP_RETRIES;
    19a4:	83 e0       	ldi	r24, 0x03	; 3
    19a6:	80 93 ea 00 	sts	0x00EA, r24
}
    19aa:	08 95       	ret

000019ac <dhcpSetOption>:
//--------------------------------------------------------------------------------------
//Ham set cac option cua DHCP
unsigned char* dhcpSetOption(unsigned char* options, unsigned char optcode, unsigned char optlen, void* optvalptr)
{
    19ac:	0f 93       	push	r16
    19ae:	1f 93       	push	r17
    19b0:	cf 93       	push	r28
    19b2:	df 93       	push	r29
    19b4:	fc 01       	movw	r30, r24
	*options++ = optcode;
    19b6:	dc 01       	movw	r26, r24
    19b8:	6d 93       	st	X+, r22
	*options++ = optlen;
    19ba:	41 83       	std	Z+1, r20	; 0x01
    19bc:	8d 01       	movw	r16, r26
    19be:	0f 5f       	subi	r16, 0xFF	; 255
    19c0:	1f 4f       	sbci	r17, 0xFF	; 255
	while(optlen--)
    19c2:	44 23       	and	r20, r20
    19c4:	99 f0       	breq	.+38     	; 0x19ec <dhcpSetOption+0x40>
    19c6:	82 2f       	mov	r24, r18
    19c8:	93 2f       	mov	r25, r19
    19ca:	41 50       	subi	r20, 0x01	; 1
	DhcpTimeout = 1;
	DhcpRetries = DHCP_RETRIES;
}
//--------------------------------------------------------------------------------------
//Ham set cac option cua DHCP
unsigned char* dhcpSetOption(unsigned char* options, unsigned char optcode, unsigned char optlen, void* optvalptr)
    19cc:	50 e0       	ldi	r21, 0x00	; 0
    19ce:	33 96       	adiw	r30, 0x03	; 3
    19d0:	e4 0f       	add	r30, r20
    19d2:	f5 1f       	adc	r31, r21
{
	*options++ = optcode;
	*options++ = optlen;
    19d4:	e8 01       	movw	r28, r16
	while(optlen--)
	{
		*options++ = *(unsigned char*)optvalptr++;
    19d6:	dc 01       	movw	r26, r24
    19d8:	2d 91       	ld	r18, X+
    19da:	cd 01       	movw	r24, r26
    19dc:	29 93       	st	Y+, r18
//Ham set cac option cua DHCP
unsigned char* dhcpSetOption(unsigned char* options, unsigned char optcode, unsigned char optlen, void* optvalptr)
{
	*options++ = optcode;
	*options++ = optlen;
	while(optlen--)
    19de:	ce 17       	cp	r28, r30
    19e0:	df 07       	cpc	r29, r31
    19e2:	c9 f7       	brne	.-14     	; 0x19d6 <dhcpSetOption+0x2a>
	DhcpTimeout = 1;
	DhcpRetries = DHCP_RETRIES;
}
//--------------------------------------------------------------------------------------
//Ham set cac option cua DHCP
unsigned char* dhcpSetOption(unsigned char* options, unsigned char optcode, unsigned char optlen, void* optvalptr)
    19e4:	4f 5f       	subi	r20, 0xFF	; 255
    19e6:	5f 4f       	sbci	r21, 0xFF	; 255
{
	*options++ = optcode;
	*options++ = optlen;
	while(optlen--)
    19e8:	04 0f       	add	r16, r20
    19ea:	15 1f       	adc	r17, r21
	{
		*options++ = *(unsigned char*)optvalptr++;
	}
	*options = DHCP_OPT_END;
    19ec:	8f ef       	ldi	r24, 0xFF	; 255
    19ee:	f8 01       	movw	r30, r16
    19f0:	80 83       	st	Z, r24
	return options;
}
    19f2:	80 2f       	mov	r24, r16
    19f4:	91 2f       	mov	r25, r17
    19f6:	df 91       	pop	r29
    19f8:	cf 91       	pop	r28
    19fa:	1f 91       	pop	r17
    19fc:	0f 91       	pop	r16
    19fe:	08 95       	ret

00001a00 <dhcpGetOption>:
//--------------------------------------------------------------------------------------
//Ham lay cac option cua DHCP
unsigned char dhcpGetOption(unsigned char* options, unsigned char optcode, unsigned char optlen, void* optvalptr)
{
    1a00:	cf 93       	push	r28
    1a02:	df 93       	push	r29
    1a04:	fc 01       	movw	r30, r24
	unsigned char i;
	for (;;)
	{
		if(*options == DHCP_OPT_PAD)
    1a06:	80 81       	ld	r24, Z
    1a08:	88 23       	and	r24, r24
    1a0a:	11 f4       	brne	.+4      	; 0x1a10 <dhcpGetOption+0x10>
			options++;
    1a0c:	31 96       	adiw	r30, 0x01	; 1
    1a0e:	fb cf       	rjmp	.-10     	; 0x1a06 <dhcpGetOption+0x6>
		else if(*options == DHCP_OPT_END)
    1a10:	8f 3f       	cpi	r24, 0xFF	; 255
    1a12:	09 f1       	breq	.+66     	; 0x1a56 <dhcpGetOption+0x56>
			break;
		else if(*options == optcode)
    1a14:	86 17       	cp	r24, r22
    1a16:	b9 f4       	brne	.+46     	; 0x1a46 <dhcpGetOption+0x46>
		{
			optlen = ((optlen<*(options+1))?(optlen):(*(options+1)));
    1a18:	ef 01       	movw	r28, r30
    1a1a:	21 96       	adiw	r28, 0x01	; 1
    1a1c:	51 81       	ldd	r21, Z+1	; 0x01
    1a1e:	45 17       	cp	r20, r21
    1a20:	08 f4       	brcc	.+2      	; 0x1a24 <dhcpGetOption+0x24>
    1a22:	54 2f       	mov	r21, r20
			for(i=0; i<optlen; i++)
    1a24:	55 23       	and	r21, r21
    1a26:	69 f0       	breq	.+26     	; 0x1a42 <dhcpGetOption+0x42>
	*options = DHCP_OPT_END;
	return options;
}
//--------------------------------------------------------------------------------------
//Ham lay cac option cua DHCP
unsigned char dhcpGetOption(unsigned char* options, unsigned char optcode, unsigned char optlen, void* optvalptr)
    1a28:	32 96       	adiw	r30, 0x02	; 2
		else if(*options == DHCP_OPT_END)
			break;
		else if(*options == optcode)
		{
			optlen = ((optlen<*(options+1))?(optlen):(*(options+1)));
			for(i=0; i<optlen; i++)
    1a2a:	82 2f       	mov	r24, r18
    1a2c:	93 2f       	mov	r25, r19
    1a2e:	dc 01       	movw	r26, r24
	*options = DHCP_OPT_END;
	return options;
}
//--------------------------------------------------------------------------------------
//Ham lay cac option cua DHCP
unsigned char dhcpGetOption(unsigned char* options, unsigned char optcode, unsigned char optlen, void* optvalptr)
    1a30:	01 96       	adiw	r24, 0x01	; 1
    1a32:	51 50       	subi	r21, 0x01	; 1
    1a34:	85 0f       	add	r24, r21
    1a36:	91 1d       	adc	r25, r1
			break;
		else if(*options == optcode)
		{
			optlen = ((optlen<*(options+1))?(optlen):(*(options+1)));
			for(i=0; i<optlen; i++)
				*(((uint8_t*)optvalptr)+i) = *(options+i+2);
    1a38:	21 91       	ld	r18, Z+
    1a3a:	2d 93       	st	X+, r18
		else if(*options == DHCP_OPT_END)
			break;
		else if(*options == optcode)
		{
			optlen = ((optlen<*(options+1))?(optlen):(*(options+1)));
			for(i=0; i<optlen; i++)
    1a3c:	a8 17       	cp	r26, r24
    1a3e:	b9 07       	cpc	r27, r25
    1a40:	d9 f7       	brne	.-10     	; 0x1a38 <dhcpGetOption+0x38>
				*(((uint8_t*)optvalptr)+i) = *(options+i+2);
			return *(options+1);
    1a42:	88 81       	ld	r24, Y
    1a44:	09 c0       	rjmp	.+18     	; 0x1a58 <dhcpGetOption+0x58>
		}
		else
		{
			options++;
    1a46:	cf 01       	movw	r24, r30
    1a48:	01 96       	adiw	r24, 0x01	; 1
			options+=*options;
    1a4a:	51 81       	ldd	r21, Z+1	; 0x01
    1a4c:	fc 01       	movw	r30, r24
    1a4e:	e5 0f       	add	r30, r21
    1a50:	f1 1d       	adc	r31, r1
			options++;
    1a52:	31 96       	adiw	r30, 0x01	; 1
    1a54:	d8 cf       	rjmp	.-80     	; 0x1a06 <dhcpGetOption+0x6>
		}
	}
	return 0;
    1a56:	80 e0       	ldi	r24, 0x00	; 0
}
    1a58:	df 91       	pop	r29
    1a5a:	cf 91       	pop	r28
    1a5c:	08 95       	ret

00001a5e <dhcpPrintHeader>:
//--------------------------------------------------------------------------------------
#ifdef DHCP_DEBUG
//Ham de in Header goi DHCP (de debug)
void dhcpPrintHeader(struct netDhcpHeader* packet)
{
    1a5e:	ef 92       	push	r14
    1a60:	ff 92       	push	r15
    1a62:	0f 93       	push	r16
    1a64:	1f 93       	push	r17
    1a66:	cf 93       	push	r28
    1a68:	df 93       	push	r29
    1a6a:	ec 01       	movw	r28, r24
	printf("DHCP Packet:\r\n");
    1a6c:	00 d0       	rcall	.+0      	; 0x1a6e <dhcpPrintHeader+0x10>
    1a6e:	8a ea       	ldi	r24, 0xAA	; 170
    1a70:	91 e0       	ldi	r25, 0x01	; 1
    1a72:	ed b7       	in	r30, 0x3d	; 61
    1a74:	fe b7       	in	r31, 0x3e	; 62
    1a76:	92 83       	std	Z+2, r25	; 0x02
    1a78:	81 83       	std	Z+1, r24	; 0x01
    1a7a:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	// print op
	printf("Op      : ");
    1a7e:	8f e9       	ldi	r24, 0x9F	; 159
    1a80:	91 e0       	ldi	r25, 0x01	; 1
    1a82:	ed b7       	in	r30, 0x3d	; 61
    1a84:	fe b7       	in	r31, 0x3e	; 62
    1a86:	92 83       	std	Z+2, r25	; 0x02
    1a88:	81 83       	std	Z+1, r24	; 0x01
    1a8a:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	switch(packet->bootp.opcode)
    1a8e:	0f 90       	pop	r0
    1a90:	0f 90       	pop	r0
    1a92:	88 81       	ld	r24, Y
    1a94:	81 30       	cpi	r24, 0x01	; 1
    1a96:	19 f0       	breq	.+6      	; 0x1a9e <dhcpPrintHeader+0x40>
    1a98:	82 30       	cpi	r24, 0x02	; 2
    1a9a:	c9 f4       	brne	.+50     	; 0x1ace <dhcpPrintHeader+0x70>
    1a9c:	0c c0       	rjmp	.+24     	; 0x1ab6 <dhcpPrintHeader+0x58>
	{
	case BOOTP_OP_BOOTREQUEST:	printf("BOOTREQUEST"); break;
    1a9e:	00 d0       	rcall	.+0      	; 0x1aa0 <dhcpPrintHeader+0x42>
    1aa0:	83 e9       	ldi	r24, 0x93	; 147
    1aa2:	91 e0       	ldi	r25, 0x01	; 1
    1aa4:	ed b7       	in	r30, 0x3d	; 61
    1aa6:	fe b7       	in	r31, 0x3e	; 62
    1aa8:	92 83       	std	Z+2, r25	; 0x02
    1aaa:	81 83       	std	Z+1, r24	; 0x01
    1aac:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    1ab0:	0f 90       	pop	r0
    1ab2:	0f 90       	pop	r0
    1ab4:	17 c0       	rjmp	.+46     	; 0x1ae4 <dhcpPrintHeader+0x86>
	case BOOTP_OP_BOOTREPLY:	printf("BOOTREPLY"); break;
    1ab6:	00 d0       	rcall	.+0      	; 0x1ab8 <dhcpPrintHeader+0x5a>
    1ab8:	89 e8       	ldi	r24, 0x89	; 137
    1aba:	91 e0       	ldi	r25, 0x01	; 1
    1abc:	ed b7       	in	r30, 0x3d	; 61
    1abe:	fe b7       	in	r31, 0x3e	; 62
    1ac0:	92 83       	std	Z+2, r25	; 0x02
    1ac2:	81 83       	std	Z+1, r24	; 0x01
    1ac4:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    1ac8:	0f 90       	pop	r0
    1aca:	0f 90       	pop	r0
    1acc:	0b c0       	rjmp	.+22     	; 0x1ae4 <dhcpPrintHeader+0x86>
	default:					printf("UNKNOWN"); break;
    1ace:	00 d0       	rcall	.+0      	; 0x1ad0 <dhcpPrintHeader+0x72>
    1ad0:	81 e8       	ldi	r24, 0x81	; 129
    1ad2:	91 e0       	ldi	r25, 0x01	; 1
    1ad4:	ed b7       	in	r30, 0x3d	; 61
    1ad6:	fe b7       	in	r31, 0x3e	; 62
    1ad8:	92 83       	std	Z+2, r25	; 0x02
    1ada:	81 83       	std	Z+1, r24	; 0x01
    1adc:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    1ae0:	0f 90       	pop	r0
    1ae2:	0f 90       	pop	r0
	}
	printf("\n\r");
    1ae4:	00 d0       	rcall	.+0      	; 0x1ae6 <dhcpPrintHeader+0x88>
    1ae6:	8e e7       	ldi	r24, 0x7E	; 126
    1ae8:	91 e0       	ldi	r25, 0x01	; 1
    1aea:	ed b7       	in	r30, 0x3d	; 61
    1aec:	fe b7       	in	r31, 0x3e	; 62
    1aee:	92 83       	std	Z+2, r25	; 0x02
    1af0:	81 83       	std	Z+1, r24	; 0x01
    1af2:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	// print transaction ID
	printf("XID     : 0x");	/*rprintfu32(packet->bootp.transid);*/				printf("\n\r");
    1af6:	81 e7       	ldi	r24, 0x71	; 113
    1af8:	91 e0       	ldi	r25, 0x01	; 1
    1afa:	ed b7       	in	r30, 0x3d	; 61
    1afc:	fe b7       	in	r31, 0x3e	; 62
    1afe:	92 83       	std	Z+2, r25	; 0x02
    1b00:	81 83       	std	Z+1, r24	; 0x01
    1b02:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    1b06:	8e e6       	ldi	r24, 0x6E	; 110
    1b08:	91 e0       	ldi	r25, 0x01	; 1
    1b0a:	ed b7       	in	r30, 0x3d	; 61
    1b0c:	fe b7       	in	r31, 0x3e	; 62
    1b0e:	92 83       	std	Z+2, r25	; 0x02
    1b10:	81 83       	std	Z+1, r24	; 0x01
    1b12:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	// print client IP address
	printf("ClIpAddr: ");	ipPrintAddr(HTONL(packet->bootp.clipaddr));	printf("\n\r");
    1b16:	83 e6       	ldi	r24, 0x63	; 99
    1b18:	91 e0       	ldi	r25, 0x01	; 1
    1b1a:	ed b7       	in	r30, 0x3d	; 61
    1b1c:	fe b7       	in	r31, 0x3e	; 62
    1b1e:	92 83       	std	Z+2, r25	; 0x02
    1b20:	81 83       	std	Z+1, r24	; 0x01
    1b22:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    1b26:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b28:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b2a:	ae 85       	ldd	r26, Y+14	; 0x0e
    1b2c:	bf 85       	ldd	r27, Y+15	; 0x0f
    1b2e:	0f 90       	pop	r0
    1b30:	0f 90       	pop	r0
    1b32:	eb 2e       	mov	r14, r27
    1b34:	ff 24       	eor	r15, r15
    1b36:	00 27       	eor	r16, r16
    1b38:	11 27       	eor	r17, r17
    1b3a:	58 2f       	mov	r21, r24
    1b3c:	44 27       	eor	r20, r20
    1b3e:	33 27       	eor	r19, r19
    1b40:	22 27       	eor	r18, r18
    1b42:	e2 2a       	or	r14, r18
    1b44:	f3 2a       	or	r15, r19
    1b46:	04 2b       	or	r16, r20
    1b48:	15 2b       	or	r17, r21
    1b4a:	9c 01       	movw	r18, r24
    1b4c:	ad 01       	movw	r20, r26
    1b4e:	20 70       	andi	r18, 0x00	; 0
    1b50:	30 70       	andi	r19, 0x00	; 0
    1b52:	50 70       	andi	r21, 0x00	; 0
    1b54:	23 2f       	mov	r18, r19
    1b56:	34 2f       	mov	r19, r20
    1b58:	45 2f       	mov	r20, r21
    1b5a:	55 27       	eor	r21, r21
    1b5c:	2e 29       	or	r18, r14
    1b5e:	3f 29       	or	r19, r15
    1b60:	40 2b       	or	r20, r16
    1b62:	51 2b       	or	r21, r17
    1b64:	80 70       	andi	r24, 0x00	; 0
    1b66:	a0 70       	andi	r26, 0x00	; 0
    1b68:	b0 70       	andi	r27, 0x00	; 0
    1b6a:	66 27       	eor	r22, r22
    1b6c:	78 2f       	mov	r23, r24
    1b6e:	89 2f       	mov	r24, r25
    1b70:	9a 2f       	mov	r25, r26
    1b72:	62 2b       	or	r22, r18
    1b74:	73 2b       	or	r23, r19
    1b76:	84 2b       	or	r24, r20
    1b78:	95 2b       	or	r25, r21
    1b7a:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <ipPrintAddr>
    1b7e:	00 d0       	rcall	.+0      	; 0x1b80 <dhcpPrintHeader+0x122>
    1b80:	80 e6       	ldi	r24, 0x60	; 96
    1b82:	91 e0       	ldi	r25, 0x01	; 1
    1b84:	ed b7       	in	r30, 0x3d	; 61
    1b86:	fe b7       	in	r31, 0x3e	; 62
    1b88:	92 83       	std	Z+2, r25	; 0x02
    1b8a:	81 83       	std	Z+1, r24	; 0x01
    1b8c:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	// print 'your' IP address
	printf("YrIpAddr: ");	ipPrintAddr(HTONL(packet->bootp.yoipaddr));	printf("\n\r");
    1b90:	85 e5       	ldi	r24, 0x55	; 85
    1b92:	91 e0       	ldi	r25, 0x01	; 1
    1b94:	ed b7       	in	r30, 0x3d	; 61
    1b96:	fe b7       	in	r31, 0x3e	; 62
    1b98:	92 83       	std	Z+2, r25	; 0x02
    1b9a:	81 83       	std	Z+1, r24	; 0x01
    1b9c:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    1ba0:	88 89       	ldd	r24, Y+16	; 0x10
    1ba2:	99 89       	ldd	r25, Y+17	; 0x11
    1ba4:	aa 89       	ldd	r26, Y+18	; 0x12
    1ba6:	bb 89       	ldd	r27, Y+19	; 0x13
    1ba8:	0f 90       	pop	r0
    1baa:	0f 90       	pop	r0
    1bac:	eb 2e       	mov	r14, r27
    1bae:	ff 24       	eor	r15, r15
    1bb0:	00 27       	eor	r16, r16
    1bb2:	11 27       	eor	r17, r17
    1bb4:	58 2f       	mov	r21, r24
    1bb6:	44 27       	eor	r20, r20
    1bb8:	33 27       	eor	r19, r19
    1bba:	22 27       	eor	r18, r18
    1bbc:	e2 2a       	or	r14, r18
    1bbe:	f3 2a       	or	r15, r19
    1bc0:	04 2b       	or	r16, r20
    1bc2:	15 2b       	or	r17, r21
    1bc4:	9c 01       	movw	r18, r24
    1bc6:	ad 01       	movw	r20, r26
    1bc8:	20 70       	andi	r18, 0x00	; 0
    1bca:	30 70       	andi	r19, 0x00	; 0
    1bcc:	50 70       	andi	r21, 0x00	; 0
    1bce:	23 2f       	mov	r18, r19
    1bd0:	34 2f       	mov	r19, r20
    1bd2:	45 2f       	mov	r20, r21
    1bd4:	55 27       	eor	r21, r21
    1bd6:	2e 29       	or	r18, r14
    1bd8:	3f 29       	or	r19, r15
    1bda:	40 2b       	or	r20, r16
    1bdc:	51 2b       	or	r21, r17
    1bde:	80 70       	andi	r24, 0x00	; 0
    1be0:	a0 70       	andi	r26, 0x00	; 0
    1be2:	b0 70       	andi	r27, 0x00	; 0
    1be4:	66 27       	eor	r22, r22
    1be6:	78 2f       	mov	r23, r24
    1be8:	89 2f       	mov	r24, r25
    1bea:	9a 2f       	mov	r25, r26
    1bec:	62 2b       	or	r22, r18
    1bee:	73 2b       	or	r23, r19
    1bf0:	84 2b       	or	r24, r20
    1bf2:	95 2b       	or	r25, r21
    1bf4:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <ipPrintAddr>
    1bf8:	00 d0       	rcall	.+0      	; 0x1bfa <dhcpPrintHeader+0x19c>
    1bfa:	82 e5       	ldi	r24, 0x52	; 82
    1bfc:	91 e0       	ldi	r25, 0x01	; 1
    1bfe:	ed b7       	in	r30, 0x3d	; 61
    1c00:	fe b7       	in	r31, 0x3e	; 62
    1c02:	92 83       	std	Z+2, r25	; 0x02
    1c04:	81 83       	std	Z+1, r24	; 0x01
    1c06:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	// print server IP address
	printf("SvIpAddr: ");	ipPrintAddr(HTONL(packet->bootp.seipaddr));	printf("\n\r");
    1c0a:	87 e4       	ldi	r24, 0x47	; 71
    1c0c:	91 e0       	ldi	r25, 0x01	; 1
    1c0e:	ed b7       	in	r30, 0x3d	; 61
    1c10:	fe b7       	in	r31, 0x3e	; 62
    1c12:	92 83       	std	Z+2, r25	; 0x02
    1c14:	81 83       	std	Z+1, r24	; 0x01
    1c16:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    1c1a:	8c 89       	ldd	r24, Y+20	; 0x14
    1c1c:	9d 89       	ldd	r25, Y+21	; 0x15
    1c1e:	ae 89       	ldd	r26, Y+22	; 0x16
    1c20:	bf 89       	ldd	r27, Y+23	; 0x17
    1c22:	0f 90       	pop	r0
    1c24:	0f 90       	pop	r0
    1c26:	eb 2e       	mov	r14, r27
    1c28:	ff 24       	eor	r15, r15
    1c2a:	00 27       	eor	r16, r16
    1c2c:	11 27       	eor	r17, r17
    1c2e:	58 2f       	mov	r21, r24
    1c30:	44 27       	eor	r20, r20
    1c32:	33 27       	eor	r19, r19
    1c34:	22 27       	eor	r18, r18
    1c36:	e2 2a       	or	r14, r18
    1c38:	f3 2a       	or	r15, r19
    1c3a:	04 2b       	or	r16, r20
    1c3c:	15 2b       	or	r17, r21
    1c3e:	9c 01       	movw	r18, r24
    1c40:	ad 01       	movw	r20, r26
    1c42:	20 70       	andi	r18, 0x00	; 0
    1c44:	30 70       	andi	r19, 0x00	; 0
    1c46:	50 70       	andi	r21, 0x00	; 0
    1c48:	23 2f       	mov	r18, r19
    1c4a:	34 2f       	mov	r19, r20
    1c4c:	45 2f       	mov	r20, r21
    1c4e:	55 27       	eor	r21, r21
    1c50:	2e 29       	or	r18, r14
    1c52:	3f 29       	or	r19, r15
    1c54:	40 2b       	or	r20, r16
    1c56:	51 2b       	or	r21, r17
    1c58:	80 70       	andi	r24, 0x00	; 0
    1c5a:	a0 70       	andi	r26, 0x00	; 0
    1c5c:	b0 70       	andi	r27, 0x00	; 0
    1c5e:	66 27       	eor	r22, r22
    1c60:	78 2f       	mov	r23, r24
    1c62:	89 2f       	mov	r24, r25
    1c64:	9a 2f       	mov	r25, r26
    1c66:	62 2b       	or	r22, r18
    1c68:	73 2b       	or	r23, r19
    1c6a:	84 2b       	or	r24, r20
    1c6c:	95 2b       	or	r25, r21
    1c6e:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <ipPrintAddr>
    1c72:	00 d0       	rcall	.+0      	; 0x1c74 <dhcpPrintHeader+0x216>
    1c74:	84 e4       	ldi	r24, 0x44	; 68
    1c76:	91 e0       	ldi	r25, 0x01	; 1
    1c78:	ed b7       	in	r30, 0x3d	; 61
    1c7a:	fe b7       	in	r31, 0x3e	; 62
    1c7c:	92 83       	std	Z+2, r25	; 0x02
    1c7e:	81 83       	std	Z+1, r24	; 0x01
    1c80:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	// print gateway IP address
	printf("GwIpAddr: ");	ipPrintAddr(HTONL(packet->bootp.gwipaddr));	printf("\n\r");
    1c84:	89 e3       	ldi	r24, 0x39	; 57
    1c86:	91 e0       	ldi	r25, 0x01	; 1
    1c88:	ed b7       	in	r30, 0x3d	; 61
    1c8a:	fe b7       	in	r31, 0x3e	; 62
    1c8c:	92 83       	std	Z+2, r25	; 0x02
    1c8e:	81 83       	std	Z+1, r24	; 0x01
    1c90:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    1c94:	88 8d       	ldd	r24, Y+24	; 0x18
    1c96:	99 8d       	ldd	r25, Y+25	; 0x19
    1c98:	aa 8d       	ldd	r26, Y+26	; 0x1a
    1c9a:	bb 8d       	ldd	r27, Y+27	; 0x1b
    1c9c:	0f 90       	pop	r0
    1c9e:	0f 90       	pop	r0
    1ca0:	eb 2e       	mov	r14, r27
    1ca2:	ff 24       	eor	r15, r15
    1ca4:	00 27       	eor	r16, r16
    1ca6:	11 27       	eor	r17, r17
    1ca8:	58 2f       	mov	r21, r24
    1caa:	44 27       	eor	r20, r20
    1cac:	33 27       	eor	r19, r19
    1cae:	22 27       	eor	r18, r18
    1cb0:	e2 2a       	or	r14, r18
    1cb2:	f3 2a       	or	r15, r19
    1cb4:	04 2b       	or	r16, r20
    1cb6:	15 2b       	or	r17, r21
    1cb8:	9c 01       	movw	r18, r24
    1cba:	ad 01       	movw	r20, r26
    1cbc:	20 70       	andi	r18, 0x00	; 0
    1cbe:	30 70       	andi	r19, 0x00	; 0
    1cc0:	50 70       	andi	r21, 0x00	; 0
    1cc2:	23 2f       	mov	r18, r19
    1cc4:	34 2f       	mov	r19, r20
    1cc6:	45 2f       	mov	r20, r21
    1cc8:	55 27       	eor	r21, r21
    1cca:	2e 29       	or	r18, r14
    1ccc:	3f 29       	or	r19, r15
    1cce:	40 2b       	or	r20, r16
    1cd0:	51 2b       	or	r21, r17
    1cd2:	80 70       	andi	r24, 0x00	; 0
    1cd4:	a0 70       	andi	r26, 0x00	; 0
    1cd6:	b0 70       	andi	r27, 0x00	; 0
    1cd8:	66 27       	eor	r22, r22
    1cda:	78 2f       	mov	r23, r24
    1cdc:	89 2f       	mov	r24, r25
    1cde:	9a 2f       	mov	r25, r26
    1ce0:	62 2b       	or	r22, r18
    1ce2:	73 2b       	or	r23, r19
    1ce4:	84 2b       	or	r24, r20
    1ce6:	95 2b       	or	r25, r21
    1ce8:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <ipPrintAddr>
    1cec:	00 d0       	rcall	.+0      	; 0x1cee <dhcpPrintHeader+0x290>
    1cee:	86 e3       	ldi	r24, 0x36	; 54
    1cf0:	91 e0       	ldi	r25, 0x01	; 1
    1cf2:	ed b7       	in	r30, 0x3d	; 61
    1cf4:	fe b7       	in	r31, 0x3e	; 62
    1cf6:	92 83       	std	Z+2, r25	; 0x02
    1cf8:	81 83       	std	Z+1, r24	; 0x01
    1cfa:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	// print client hardware address
	printf("ClHwAddr: ");	ethPrintAddr((struct ntEthAddr*)packet->bootp.clhwaddr);	printf("\n\r");
    1cfe:	8b e2       	ldi	r24, 0x2B	; 43
    1d00:	91 e0       	ldi	r25, 0x01	; 1
    1d02:	ed b7       	in	r30, 0x3d	; 61
    1d04:	fe b7       	in	r31, 0x3e	; 62
    1d06:	92 83       	std	Z+2, r25	; 0x02
    1d08:	81 83       	std	Z+1, r24	; 0x01
    1d0a:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    1d0e:	0f 90       	pop	r0
    1d10:	0f 90       	pop	r0
    1d12:	ce 01       	movw	r24, r28
    1d14:	4c 96       	adiw	r24, 0x1c	; 28
    1d16:	0e 94 b9 1b 	call	0x3772	; 0x3772 <ethPrintAddr>
    1d1a:	00 d0       	rcall	.+0      	; 0x1d1c <dhcpPrintHeader+0x2be>
    1d1c:	88 e2       	ldi	r24, 0x28	; 40
    1d1e:	91 e0       	ldi	r25, 0x01	; 1
    1d20:	ed b7       	in	r30, 0x3d	; 61
    1d22:	fe b7       	in	r31, 0x3e	; 62
    1d24:	92 83       	std	Z+2, r25	; 0x02
    1d26:	81 83       	std	Z+1, r24	; 0x01
    1d28:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    1d2c:	0f 90       	pop	r0
    1d2e:	0f 90       	pop	r0
}
    1d30:	df 91       	pop	r29
    1d32:	cf 91       	pop	r28
    1d34:	1f 91       	pop	r17
    1d36:	0f 91       	pop	r16
    1d38:	ff 90       	pop	r15
    1d3a:	ef 90       	pop	r14
    1d3c:	08 95       	ret

00001d3e <dhcpDiscover>:
#endif
//--------------------------------------------------------------------------------------
//Ham gui di mot ban tin DHCP discover de tim kiem DHCP server
void dhcpDiscover(void)
{
    1d3e:	2f 92       	push	r2
    1d40:	3f 92       	push	r3
    1d42:	4f 92       	push	r4
    1d44:	5f 92       	push	r5
    1d46:	6f 92       	push	r6
    1d48:	7f 92       	push	r7
    1d4a:	8f 92       	push	r8
    1d4c:	9f 92       	push	r9
    1d4e:	af 92       	push	r10
    1d50:	bf 92       	push	r11
    1d52:	cf 92       	push	r12
    1d54:	df 92       	push	r13
    1d56:	ef 92       	push	r14
    1d58:	ff 92       	push	r15
    1d5a:	0f 93       	push	r16
    1d5c:	1f 93       	push	r17
    1d5e:	df 93       	push	r29
    1d60:	cf 93       	push	r28
    1d62:	00 d0       	rcall	.+0      	; 0x1d64 <dhcpDiscover+0x26>
    1d64:	00 d0       	rcall	.+0      	; 0x1d66 <dhcpDiscover+0x28>
    1d66:	cd b7       	in	r28, 0x3d	; 61
    1d68:	de b7       	in	r29, 0x3e	; 62
	struct netDhcpHeader* packet;
	unsigned long val;
	unsigned char* optptr;
	
	packet = (struct netDhcpHeader*)(ethGetBuffer() + ETH_HEADER_LEN + IP_HEADER_LEN + UDP_HEADER_LEN);
    1d6a:	0e 94 5f 15 	call	0x2abe	; 0x2abe <ethGetBuffer>
    1d6e:	8c 01       	movw	r16, r24
    1d70:	0f 2e       	mov	r0, r31
    1d72:	fa e2       	ldi	r31, 0x2A	; 42
    1d74:	ef 2e       	mov	r14, r31
    1d76:	ff 24       	eor	r15, r15
    1d78:	f0 2d       	mov	r31, r0
    1d7a:	e8 0e       	add	r14, r24
    1d7c:	f9 1e       	adc	r15, r25
	//
	packet->bootp.opcode = BOOTP_OP_BOOTREQUEST;
    1d7e:	81 e0       	ldi	r24, 0x01	; 1
    1d80:	f8 01       	movw	r30, r16
    1d82:	82 a7       	std	Z+42, r24	; 0x2a
	packet->bootp.hwaddrtype = BOOTP_HTYPE_ETHERNET;
    1d84:	f7 01       	movw	r30, r14
    1d86:	81 83       	std	Z+1, r24	; 0x01
	packet->bootp.hwaddrlen = BOOTP_HLEN_ETHERNET;
    1d88:	86 e0       	ldi	r24, 0x06	; 6
    1d8a:	82 83       	std	Z+2, r24	; 0x02
	packet->bootp.clipaddr = HTONL(ipGetConfig()->ip);
    1d8c:	0e 94 b6 1b 	call	0x376c	; 0x376c <ipGetConfig>
    1d90:	fc 01       	movw	r30, r24
    1d92:	a0 80       	ld	r10, Z
    1d94:	b1 80       	ldd	r11, Z+1	; 0x01
    1d96:	c2 80       	ldd	r12, Z+2	; 0x02
    1d98:	d3 80       	ldd	r13, Z+3	; 0x03
    1d9a:	da 2c       	mov	r13, r10
    1d9c:	cc 24       	eor	r12, r12
    1d9e:	bb 24       	eor	r11, r11
    1da0:	aa 24       	eor	r10, r10
    1da2:	0e 94 b6 1b 	call	0x376c	; 0x376c <ipGetConfig>
    1da6:	fc 01       	movw	r30, r24
    1da8:	80 81       	ld	r24, Z
    1daa:	91 81       	ldd	r25, Z+1	; 0x01
    1dac:	a2 81       	ldd	r26, Z+2	; 0x02
    1dae:	b3 81       	ldd	r27, Z+3	; 0x03
    1db0:	80 70       	andi	r24, 0x00	; 0
    1db2:	90 70       	andi	r25, 0x00	; 0
    1db4:	b0 70       	andi	r27, 0x00	; 0
    1db6:	29 2e       	mov	r2, r25
    1db8:	3a 2e       	mov	r3, r26
    1dba:	4b 2e       	mov	r4, r27
    1dbc:	55 24       	eor	r5, r5
    1dbe:	0e 94 b6 1b 	call	0x376c	; 0x376c <ipGetConfig>
    1dc2:	fc 01       	movw	r30, r24
    1dc4:	80 81       	ld	r24, Z
    1dc6:	91 81       	ldd	r25, Z+1	; 0x01
    1dc8:	a2 81       	ldd	r26, Z+2	; 0x02
    1dca:	b3 81       	ldd	r27, Z+3	; 0x03
    1dcc:	80 70       	andi	r24, 0x00	; 0
    1dce:	a0 70       	andi	r26, 0x00	; 0
    1dd0:	b0 70       	andi	r27, 0x00	; 0
    1dd2:	66 24       	eor	r6, r6
    1dd4:	78 2e       	mov	r7, r24
    1dd6:	89 2e       	mov	r8, r25
    1dd8:	9a 2e       	mov	r9, r26
    1dda:	0e 94 b6 1b 	call	0x376c	; 0x376c <ipGetConfig>
    1dde:	fc 01       	movw	r30, r24
    1de0:	83 81       	ldd	r24, Z+3	; 0x03
    1de2:	90 e0       	ldi	r25, 0x00	; 0
    1de4:	a0 e0       	ldi	r26, 0x00	; 0
    1de6:	b0 e0       	ldi	r27, 0x00	; 0
    1de8:	a8 2a       	or	r10, r24
    1dea:	b9 2a       	or	r11, r25
    1dec:	ca 2a       	or	r12, r26
    1dee:	db 2a       	or	r13, r27
    1df0:	a2 28       	or	r10, r2
    1df2:	b3 28       	or	r11, r3
    1df4:	c4 28       	or	r12, r4
    1df6:	d5 28       	or	r13, r5
    1df8:	6a 28       	or	r6, r10
    1dfa:	7b 28       	or	r7, r11
    1dfc:	8c 28       	or	r8, r12
    1dfe:	9d 28       	or	r9, r13
    1e00:	f7 01       	movw	r30, r14
    1e02:	64 86       	std	Z+12, r6	; 0x0c
    1e04:	75 86       	std	Z+13, r7	; 0x0d
    1e06:	86 86       	std	Z+14, r8	; 0x0e
    1e08:	97 86       	std	Z+15, r9	; 0x0f
	packet->bootp.yoipaddr = HTONL(0l);
    1e0a:	10 8a       	std	Z+16, r1	; 0x10
    1e0c:	11 8a       	std	Z+17, r1	; 0x11
    1e0e:	12 8a       	std	Z+18, r1	; 0x12
    1e10:	13 8a       	std	Z+19, r1	; 0x13
	packet->bootp.seipaddr = HTONL(0l);
    1e12:	14 8a       	std	Z+20, r1	; 0x14
    1e14:	15 8a       	std	Z+21, r1	; 0x15
    1e16:	16 8a       	std	Z+22, r1	; 0x16
    1e18:	17 8a       	std	Z+23, r1	; 0x17
	packet->bootp.gwipaddr = HTONL(0l);
    1e1a:	10 8e       	std	Z+24, r1	; 0x18
    1e1c:	11 8e       	std	Z+25, r1	; 0x19
    1e1e:	12 8e       	std	Z+26, r1	; 0x1a
    1e20:	13 8e       	std	Z+27, r1	; 0x1b
	ethGetMacAddress(&packet->bootp.clhwaddr[0]);
    1e22:	c7 01       	movw	r24, r14
    1e24:	4c 96       	adiw	r24, 0x1c	; 28
    1e26:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <ethGetMacAddress>
	packet->bootp.transid = DhcpTransactID;
    1e2a:	80 91 e6 00 	lds	r24, 0x00E6
    1e2e:	90 91 e7 00 	lds	r25, 0x00E7
    1e32:	a0 91 e8 00 	lds	r26, 0x00E8
    1e36:	b0 91 e9 00 	lds	r27, 0x00E9
    1e3a:	f7 01       	movw	r30, r14
    1e3c:	84 83       	std	Z+4, r24	; 0x04
    1e3e:	95 83       	std	Z+5, r25	; 0x05
    1e40:	a6 83       	std	Z+6, r26	; 0x06
    1e42:	b7 83       	std	Z+7, r27	; 0x07
	packet->bootp.flags = HTONS(1);
    1e44:	80 e0       	ldi	r24, 0x00	; 0
    1e46:	91 e0       	ldi	r25, 0x01	; 1
    1e48:	93 87       	std	Z+11, r25	; 0x0b
    1e4a:	82 87       	std	Z+10, r24	; 0x0a
	//
	packet->cookie = 0x63538263;
    1e4c:	f8 01       	movw	r30, r16
    1e4e:	ea 5e       	subi	r30, 0xEA	; 234
    1e50:	fe 4f       	sbci	r31, 0xFE	; 254
    1e52:	83 e6       	ldi	r24, 0x63	; 99
    1e54:	92 e8       	ldi	r25, 0x82	; 130
    1e56:	a3 e5       	ldi	r26, 0x53	; 83
    1e58:	b3 e6       	ldi	r27, 0x63	; 99
    1e5a:	80 83       	st	Z, r24
    1e5c:	91 83       	std	Z+1, r25	; 0x01
    1e5e:	a2 83       	std	Z+2, r26	; 0x02
    1e60:	b3 83       	std	Z+3, r27	; 0x03
	val = DHCP_MSG_DHCPDISCOVER;
    1e62:	81 e0       	ldi	r24, 0x01	; 1
    1e64:	90 e0       	ldi	r25, 0x00	; 0
    1e66:	a0 e0       	ldi	r26, 0x00	; 0
    1e68:	b0 e0       	ldi	r27, 0x00	; 0
    1e6a:	89 83       	std	Y+1, r24	; 0x01
    1e6c:	9a 83       	std	Y+2, r25	; 0x02
    1e6e:	ab 83       	std	Y+3, r26	; 0x03
    1e70:	bc 83       	std	Y+4, r27	; 0x04
	optptr = dhcpSetOption(packet->options, DHCP_OPT_DHCPMSGTYPE, 1, &val);
    1e72:	c8 01       	movw	r24, r16
    1e74:	86 5e       	subi	r24, 0xE6	; 230
    1e76:	9e 4f       	sbci	r25, 0xFE	; 254
    1e78:	65 e3       	ldi	r22, 0x35	; 53
    1e7a:	41 e0       	ldi	r20, 0x01	; 1
    1e7c:	9e 01       	movw	r18, r28
    1e7e:	2f 5f       	subi	r18, 0xFF	; 255
    1e80:	3f 4f       	sbci	r19, 0xFF	; 255
    1e82:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <dhcpSetOption>
	dhcpSetOption(optptr, DHCP_OPT_CLIENTID, 6, macaddr);
    1e86:	6d e3       	ldi	r22, 0x3D	; 61
    1e88:	46 e0       	ldi	r20, 0x06	; 6
    1e8a:	23 ef       	ldi	r18, 0xF3	; 243
    1e8c:	30 e0       	ldi	r19, 0x00	; 0
    1e8e:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <dhcpSetOption>
	#ifdef DHCP_DEBUG
	printf("DHCP: Sending Query\r\n");
    1e92:	00 d0       	rcall	.+0      	; 0x1e94 <dhcpDiscover+0x156>
    1e94:	82 e1       	ldi	r24, 0x12	; 18
    1e96:	91 e0       	ldi	r25, 0x01	; 1
    1e98:	ed b7       	in	r30, 0x3d	; 61
    1e9a:	fe b7       	in	r31, 0x3e	; 62
    1e9c:	92 83       	std	Z+2, r25	; 0x02
    1e9e:	81 83       	std	Z+1, r24	; 0x01
    1ea0:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	dhcpPrintHeader(packet);
    1ea4:	0f 90       	pop	r0
    1ea6:	0f 90       	pop	r0
    1ea8:	c7 01       	movw	r24, r14
    1eaa:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <dhcpPrintHeader>
	#endif
	udpSend(0xFFFFFFFF, DHCP_UDP_SERVER_PORT, DHCP_UDP_CLIENT_PORT, DHCP_HEADER_LEN+3+1+8, (unsigned char*)packet);
    1eae:	6f ef       	ldi	r22, 0xFF	; 255
    1eb0:	7f ef       	ldi	r23, 0xFF	; 255
    1eb2:	cb 01       	movw	r24, r22
    1eb4:	43 e4       	ldi	r20, 0x43	; 67
    1eb6:	50 e0       	ldi	r21, 0x00	; 0
    1eb8:	24 e4       	ldi	r18, 0x44	; 68
    1eba:	30 e0       	ldi	r19, 0x00	; 0
    1ebc:	0c ef       	ldi	r16, 0xFC	; 252
    1ebe:	10 e0       	ldi	r17, 0x00	; 0
    1ec0:	0e 94 8d 2b 	call	0x571a	; 0x571a <udpSend>
}
    1ec4:	0f 90       	pop	r0
    1ec6:	0f 90       	pop	r0
    1ec8:	0f 90       	pop	r0
    1eca:	0f 90       	pop	r0
    1ecc:	cf 91       	pop	r28
    1ece:	df 91       	pop	r29
    1ed0:	1f 91       	pop	r17
    1ed2:	0f 91       	pop	r16
    1ed4:	ff 90       	pop	r15
    1ed6:	ef 90       	pop	r14
    1ed8:	df 90       	pop	r13
    1eda:	cf 90       	pop	r12
    1edc:	bf 90       	pop	r11
    1ede:	af 90       	pop	r10
    1ee0:	9f 90       	pop	r9
    1ee2:	8f 90       	pop	r8
    1ee4:	7f 90       	pop	r7
    1ee6:	6f 90       	pop	r6
    1ee8:	5f 90       	pop	r5
    1eea:	4f 90       	pop	r4
    1eec:	3f 90       	pop	r3
    1eee:	2f 90       	pop	r2
    1ef0:	08 95       	ret

00001ef2 <dhcpRequest>:
//--------------------------------------------------------------------------------------
//Ham gui di mot ban tin DHCP request de yeu cau nhan dia chi IP
void dhcpRequest(struct netDhcpHeader* packet, unsigned long serverid)
{
    1ef2:	df 92       	push	r13
    1ef4:	ef 92       	push	r14
    1ef6:	ff 92       	push	r15
    1ef8:	0f 93       	push	r16
    1efa:	1f 93       	push	r17
    1efc:	df 93       	push	r29
    1efe:	cf 93       	push	r28
    1f00:	cd b7       	in	r28, 0x3d	; 61
    1f02:	de b7       	in	r29, 0x3e	; 62
    1f04:	28 97       	sbiw	r28, 0x08	; 8
    1f06:	0f b6       	in	r0, 0x3f	; 63
    1f08:	f8 94       	cli
    1f0a:	de bf       	out	0x3e, r29	; 62
    1f0c:	0f be       	out	0x3f, r0	; 63
    1f0e:	cd bf       	out	0x3d, r28	; 61
    1f10:	7c 01       	movw	r14, r24
    1f12:	4d 83       	std	Y+5, r20	; 0x05
    1f14:	5e 83       	std	Y+6, r21	; 0x06
    1f16:	6f 83       	std	Y+7, r22	; 0x07
    1f18:	78 87       	std	Y+8, r23	; 0x08
	unsigned char* optptr;
	unsigned long val;

	packet->bootp.opcode = BOOTP_OP_BOOTREQUEST;		// request type
    1f1a:	dd 24       	eor	r13, r13
    1f1c:	d3 94       	inc	r13
    1f1e:	fc 01       	movw	r30, r24
    1f20:	d0 82       	st	Z, r13
	val = DHCP_MSG_DHCPREQUEST;
    1f22:	83 e0       	ldi	r24, 0x03	; 3
    1f24:	90 e0       	ldi	r25, 0x00	; 0
    1f26:	a0 e0       	ldi	r26, 0x00	; 0
    1f28:	b0 e0       	ldi	r27, 0x00	; 0
    1f2a:	89 83       	std	Y+1, r24	; 0x01
    1f2c:	9a 83       	std	Y+2, r25	; 0x02
    1f2e:	ab 83       	std	Y+3, r26	; 0x03
    1f30:	bc 83       	std	Y+4, r27	; 0x04
	optptr = dhcpSetOption(packet->options, DHCP_OPT_DHCPMSGTYPE, 1, &val);
    1f32:	c7 01       	movw	r24, r14
    1f34:	80 51       	subi	r24, 0x10	; 16
    1f36:	9f 4f       	sbci	r25, 0xFF	; 255
    1f38:	65 e3       	ldi	r22, 0x35	; 53
    1f3a:	41 e0       	ldi	r20, 0x01	; 1
    1f3c:	8e 01       	movw	r16, r28
    1f3e:	0f 5f       	subi	r16, 0xFF	; 255
    1f40:	1f 4f       	sbci	r17, 0xFF	; 255
    1f42:	98 01       	movw	r18, r16
    1f44:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <dhcpSetOption>
	optptr = dhcpSetOption(optptr, DHCP_OPT_CLIENTID, 6, macaddr);
    1f48:	6d e3       	ldi	r22, 0x3D	; 61
    1f4a:	46 e0       	ldi	r20, 0x06	; 6
    1f4c:	23 ef       	ldi	r18, 0xF3	; 243
    1f4e:	30 e0       	ldi	r19, 0x00	; 0
    1f50:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <dhcpSetOption>
	optptr = dhcpSetOption(optptr, DHCP_OPT_SERVERID, 4, &serverid);
    1f54:	66 e3       	ldi	r22, 0x36	; 54
    1f56:	44 e0       	ldi	r20, 0x04	; 4
    1f58:	9e 01       	movw	r18, r28
    1f5a:	2b 5f       	subi	r18, 0xFB	; 251
    1f5c:	3f 4f       	sbci	r19, 0xFF	; 255
    1f5e:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <dhcpSetOption>
	optptr = dhcpSetOption(optptr, DHCP_OPT_REQUESTEDIP, 4, &packet->bootp.yoipaddr);
    1f62:	97 01       	movw	r18, r14
    1f64:	20 5f       	subi	r18, 0xF0	; 240
    1f66:	3f 4f       	sbci	r19, 0xFF	; 255
    1f68:	62 e3       	ldi	r22, 0x32	; 50
    1f6a:	44 e0       	ldi	r20, 0x04	; 4
    1f6c:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <dhcpSetOption>
	((unsigned char*)&val)[0] = DHCP_OPT_NETMASK;
    1f70:	d9 82       	std	Y+1, r13	; 0x01
	((unsigned char*)&val)[1] = DHCP_OPT_ROUTERS;
    1f72:	23 e0       	ldi	r18, 0x03	; 3
    1f74:	f8 01       	movw	r30, r16
    1f76:	21 83       	std	Z+1, r18	; 0x01
	((unsigned char*)&val)[2] = DHCP_OPT_DNSSERVERS;
    1f78:	26 e0       	ldi	r18, 0x06	; 6
    1f7a:	22 83       	std	Z+2, r18	; 0x02
	((unsigned char*)&val)[3] = DHCP_OPT_DOMAINNAME;
    1f7c:	2f e0       	ldi	r18, 0x0F	; 15
    1f7e:	23 83       	std	Z+3, r18	; 0x03
	optptr = dhcpSetOption(optptr, DHCP_OPT_PARAMREQLIST, 4, &val);
    1f80:	67 e3       	ldi	r22, 0x37	; 55
    1f82:	44 e0       	ldi	r20, 0x04	; 4
    1f84:	98 01       	movw	r18, r16
    1f86:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <dhcpSetOption>
	packet->bootp.yoipaddr = HTONL(0l);
    1f8a:	f7 01       	movw	r30, r14
    1f8c:	10 8a       	std	Z+16, r1	; 0x10
    1f8e:	11 8a       	std	Z+17, r1	; 0x11
    1f90:	12 8a       	std	Z+18, r1	; 0x12
    1f92:	13 8a       	std	Z+19, r1	; 0x13
	#ifdef DHCP_DEBUG
	printf("DHCP: Sending request in response to offer\r\n");
    1f94:	00 d0       	rcall	.+0      	; 0x1f96 <dhcpRequest+0xa4>
    1f96:	85 ee       	ldi	r24, 0xE5	; 229
    1f98:	90 e0       	ldi	r25, 0x00	; 0
    1f9a:	ed b7       	in	r30, 0x3d	; 61
    1f9c:	fe b7       	in	r31, 0x3e	; 62
    1f9e:	92 83       	std	Z+2, r25	; 0x02
    1fa0:	81 83       	std	Z+1, r24	; 0x01
    1fa2:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	#endif
	udpSend(0xFFFFFFFF, DHCP_UDP_SERVER_PORT, DHCP_UDP_CLIENT_PORT, DHCP_HEADER_LEN+3+6+6+6+8+1, (unsigned char*)packet);
    1fa6:	0f 90       	pop	r0
    1fa8:	0f 90       	pop	r0
    1faa:	6f ef       	ldi	r22, 0xFF	; 255
    1fac:	7f ef       	ldi	r23, 0xFF	; 255
    1fae:	cb 01       	movw	r24, r22
    1fb0:	43 e4       	ldi	r20, 0x43	; 67
    1fb2:	50 e0       	ldi	r21, 0x00	; 0
    1fb4:	24 e4       	ldi	r18, 0x44	; 68
    1fb6:	30 e0       	ldi	r19, 0x00	; 0
    1fb8:	0e e0       	ldi	r16, 0x0E	; 14
    1fba:	11 e0       	ldi	r17, 0x01	; 1
    1fbc:	0e 94 8d 2b 	call	0x571a	; 0x571a <udpSend>
}
    1fc0:	28 96       	adiw	r28, 0x08	; 8
    1fc2:	0f b6       	in	r0, 0x3f	; 63
    1fc4:	f8 94       	cli
    1fc6:	de bf       	out	0x3e, r29	; 62
    1fc8:	0f be       	out	0x3f, r0	; 63
    1fca:	cd bf       	out	0x3d, r28	; 61
    1fcc:	cf 91       	pop	r28
    1fce:	df 91       	pop	r29
    1fd0:	1f 91       	pop	r17
    1fd2:	0f 91       	pop	r16
    1fd4:	ff 90       	pop	r15
    1fd6:	ef 90       	pop	r14
    1fd8:	df 90       	pop	r13
    1fda:	08 95       	ret

00001fdc <dhcpIn>:
//--------------------------------------------------------------------------------------
//Ham xu ly mot goi DHCP nhan duoc
void dhcpIn(unsigned int len, struct netDhcpHeader* packet)
{
    1fdc:	4f 92       	push	r4
    1fde:	5f 92       	push	r5
    1fe0:	6f 92       	push	r6
    1fe2:	7f 92       	push	r7
    1fe4:	8f 92       	push	r8
    1fe6:	9f 92       	push	r9
    1fe8:	af 92       	push	r10
    1fea:	bf 92       	push	r11
    1fec:	cf 92       	push	r12
    1fee:	df 92       	push	r13
    1ff0:	ef 92       	push	r14
    1ff2:	ff 92       	push	r15
    1ff4:	0f 93       	push	r16
    1ff6:	1f 93       	push	r17
    1ff8:	df 93       	push	r29
    1ffa:	cf 93       	push	r28
    1ffc:	cd b7       	in	r28, 0x3d	; 61
    1ffe:	de b7       	in	r29, 0x3e	; 62
    2000:	2d 97       	sbiw	r28, 0x0d	; 13
    2002:	0f b6       	in	r0, 0x3f	; 63
    2004:	f8 94       	cli
    2006:	de bf       	out	0x3e, r29	; 62
    2008:	0f be       	out	0x3f, r0	; 63
    200a:	cd bf       	out	0x3d, r28	; 61
    200c:	8b 01       	movw	r16, r22
	unsigned long netmask;
	unsigned long gateway;
	unsigned long val;
	//
	#ifdef DHCP_DEBUG
	dhcpPrintHeader(packet);
    200e:	cb 01       	movw	r24, r22
    2010:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <dhcpPrintHeader>
	#endif
	//
	if((packet->bootp.opcode != BOOTP_OP_BOOTREPLY) || (packet->bootp.transid != DhcpTransactID))
    2014:	d8 01       	movw	r26, r16
    2016:	8c 91       	ld	r24, X
    2018:	82 30       	cpi	r24, 0x02	; 2
    201a:	09 f0       	breq	.+2      	; 0x201e <dhcpIn+0x42>
    201c:	96 c1       	rjmp	.+812    	; 0x234a <dhcpIn+0x36e>
    201e:	14 96       	adiw	r26, 0x04	; 4
    2020:	2d 91       	ld	r18, X+
    2022:	3d 91       	ld	r19, X+
    2024:	4d 91       	ld	r20, X+
    2026:	5c 91       	ld	r21, X
    2028:	17 97       	sbiw	r26, 0x07	; 7
    202a:	80 91 e6 00 	lds	r24, 0x00E6
    202e:	90 91 e7 00 	lds	r25, 0x00E7
    2032:	a0 91 e8 00 	lds	r26, 0x00E8
    2036:	b0 91 e9 00 	lds	r27, 0x00E9
    203a:	28 17       	cp	r18, r24
    203c:	39 07       	cpc	r19, r25
    203e:	4a 07       	cpc	r20, r26
    2040:	5b 07       	cpc	r21, r27
    2042:	09 f0       	breq	.+2      	; 0x2046 <dhcpIn+0x6a>
    2044:	82 c1       	rjmp	.+772    	; 0x234a <dhcpIn+0x36e>
		return;
	//
	dhcpGetOption(packet->options, DHCP_OPT_DHCPMSGTYPE, 1, &msgtype);
    2046:	0f 2e       	mov	r0, r31
    2048:	f0 ef       	ldi	r31, 0xF0	; 240
    204a:	ef 2e       	mov	r14, r31
    204c:	ff 24       	eor	r15, r15
    204e:	f0 2d       	mov	r31, r0
    2050:	e0 0e       	add	r14, r16
    2052:	f1 1e       	adc	r15, r17
    2054:	c7 01       	movw	r24, r14
    2056:	65 e3       	ldi	r22, 0x35	; 53
    2058:	41 e0       	ldi	r20, 0x01	; 1
    205a:	9e 01       	movw	r18, r28
    205c:	2f 5f       	subi	r18, 0xFF	; 255
    205e:	3f 4f       	sbci	r19, 0xFF	; 255
    2060:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <dhcpGetOption>
	#ifdef DHCP_DEBUG
	printf("DHCP: Received msgtype = %d\r\n", msgtype);
    2064:	00 d0       	rcall	.+0      	; 0x2066 <dhcpIn+0x8a>
    2066:	00 d0       	rcall	.+0      	; 0x2068 <dhcpIn+0x8c>
    2068:	ed b7       	in	r30, 0x3d	; 61
    206a:	fe b7       	in	r31, 0x3e	; 62
    206c:	31 96       	adiw	r30, 0x01	; 1
    206e:	87 ec       	ldi	r24, 0xC7	; 199
    2070:	90 e0       	ldi	r25, 0x00	; 0
    2072:	ad b7       	in	r26, 0x3d	; 61
    2074:	be b7       	in	r27, 0x3e	; 62
    2076:	12 96       	adiw	r26, 0x02	; 2
    2078:	9c 93       	st	X, r25
    207a:	8e 93       	st	-X, r24
    207c:	11 97       	sbiw	r26, 0x01	; 1
    207e:	89 81       	ldd	r24, Y+1	; 0x01
    2080:	82 83       	std	Z+2, r24	; 0x02
    2082:	13 82       	std	Z+3, r1	; 0x03
    2084:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	#endif
	//
	if(msgtype == DHCP_MSG_DHCPOFFER)
    2088:	89 81       	ldd	r24, Y+1	; 0x01
    208a:	0f 90       	pop	r0
    208c:	0f 90       	pop	r0
    208e:	0f 90       	pop	r0
    2090:	0f 90       	pop	r0
    2092:	82 30       	cpi	r24, 0x02	; 2
    2094:	09 f0       	breq	.+2      	; 0x2098 <dhcpIn+0xbc>
    2096:	52 c0       	rjmp	.+164    	; 0x213c <dhcpIn+0x160>
	{
		dhcpGetOption(packet->options, DHCP_OPT_SERVERID, 4, &sid);
    2098:	c7 01       	movw	r24, r14
    209a:	66 e3       	ldi	r22, 0x36	; 54
    209c:	44 e0       	ldi	r20, 0x04	; 4
    209e:	9e 01       	movw	r18, r28
    20a0:	2e 5f       	subi	r18, 0xFE	; 254
    20a2:	3f 4f       	sbci	r19, 0xFF	; 255
    20a4:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <dhcpGetOption>
		#ifdef DHCP_DEBUG
		printf("DHCP: Got offer from server "); ipPrintAddr(HTONL(sid)); printf("\n\r");
    20a8:	00 d0       	rcall	.+0      	; 0x20aa <dhcpIn+0xce>
    20aa:	8a ea       	ldi	r24, 0xAA	; 170
    20ac:	90 e0       	ldi	r25, 0x00	; 0
    20ae:	ed b7       	in	r30, 0x3d	; 61
    20b0:	fe b7       	in	r31, 0x3e	; 62
    20b2:	92 83       	std	Z+2, r25	; 0x02
    20b4:	81 83       	std	Z+1, r24	; 0x01
    20b6:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    20ba:	8a 81       	ldd	r24, Y+2	; 0x02
    20bc:	9b 81       	ldd	r25, Y+3	; 0x03
    20be:	ac 81       	ldd	r26, Y+4	; 0x04
    20c0:	bd 81       	ldd	r27, Y+5	; 0x05
    20c2:	0f 90       	pop	r0
    20c4:	0f 90       	pop	r0
    20c6:	cb 2e       	mov	r12, r27
    20c8:	dd 24       	eor	r13, r13
    20ca:	ee 24       	eor	r14, r14
    20cc:	ff 24       	eor	r15, r15
    20ce:	58 2f       	mov	r21, r24
    20d0:	44 27       	eor	r20, r20
    20d2:	33 27       	eor	r19, r19
    20d4:	22 27       	eor	r18, r18
    20d6:	c2 2a       	or	r12, r18
    20d8:	d3 2a       	or	r13, r19
    20da:	e4 2a       	or	r14, r20
    20dc:	f5 2a       	or	r15, r21
    20de:	9c 01       	movw	r18, r24
    20e0:	ad 01       	movw	r20, r26
    20e2:	20 70       	andi	r18, 0x00	; 0
    20e4:	30 70       	andi	r19, 0x00	; 0
    20e6:	50 70       	andi	r21, 0x00	; 0
    20e8:	23 2f       	mov	r18, r19
    20ea:	34 2f       	mov	r19, r20
    20ec:	45 2f       	mov	r20, r21
    20ee:	55 27       	eor	r21, r21
    20f0:	2c 29       	or	r18, r12
    20f2:	3d 29       	or	r19, r13
    20f4:	4e 29       	or	r20, r14
    20f6:	5f 29       	or	r21, r15
    20f8:	80 70       	andi	r24, 0x00	; 0
    20fa:	a0 70       	andi	r26, 0x00	; 0
    20fc:	b0 70       	andi	r27, 0x00	; 0
    20fe:	66 27       	eor	r22, r22
    2100:	78 2f       	mov	r23, r24
    2102:	89 2f       	mov	r24, r25
    2104:	9a 2f       	mov	r25, r26
    2106:	62 2b       	or	r22, r18
    2108:	73 2b       	or	r23, r19
    210a:	84 2b       	or	r24, r20
    210c:	95 2b       	or	r25, r21
    210e:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <ipPrintAddr>
    2112:	00 d0       	rcall	.+0      	; 0x2114 <dhcpIn+0x138>
    2114:	87 ea       	ldi	r24, 0xA7	; 167
    2116:	90 e0       	ldi	r25, 0x00	; 0
    2118:	ad b7       	in	r26, 0x3d	; 61
    211a:	be b7       	in	r27, 0x3e	; 62
    211c:	12 96       	adiw	r26, 0x02	; 2
    211e:	9c 93       	st	X, r25
    2120:	8e 93       	st	-X, r24
    2122:	11 97       	sbiw	r26, 0x01	; 1
    2124:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
		#endif
		dhcpRequest(packet, sid);
    2128:	0f 90       	pop	r0
    212a:	0f 90       	pop	r0
    212c:	4a 81       	ldd	r20, Y+2	; 0x02
    212e:	5b 81       	ldd	r21, Y+3	; 0x03
    2130:	6c 81       	ldd	r22, Y+4	; 0x04
    2132:	7d 81       	ldd	r23, Y+5	; 0x05
    2134:	c8 01       	movw	r24, r16
    2136:	0e 94 79 0f 	call	0x1ef2	; 0x1ef2 <dhcpRequest>
    213a:	07 c1       	rjmp	.+526    	; 0x234a <dhcpIn+0x36e>
	}
	//
	else if(msgtype == DHCP_MSG_DHCPACK)
    213c:	85 30       	cpi	r24, 0x05	; 5
    213e:	09 f0       	breq	.+2      	; 0x2142 <dhcpIn+0x166>
    2140:	04 c1       	rjmp	.+520    	; 0x234a <dhcpIn+0x36e>
	{
		dhcpGetOption(packet->options, DHCP_OPT_NETMASK, 4, &val);
    2142:	0f 2e       	mov	r0, r31
    2144:	f6 e0       	ldi	r31, 0x06	; 6
    2146:	cf 2e       	mov	r12, r31
    2148:	dd 24       	eor	r13, r13
    214a:	f0 2d       	mov	r31, r0
    214c:	cc 0e       	add	r12, r28
    214e:	dd 1e       	adc	r13, r29
    2150:	c7 01       	movw	r24, r14
    2152:	61 e0       	ldi	r22, 0x01	; 1
    2154:	44 e0       	ldi	r20, 0x04	; 4
    2156:	96 01       	movw	r18, r12
    2158:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <dhcpGetOption>
		netmask = HTONL(val);
    215c:	8e 80       	ldd	r8, Y+6	; 0x06
    215e:	9f 80       	ldd	r9, Y+7	; 0x07
    2160:	a8 84       	ldd	r10, Y+8	; 0x08
    2162:	b9 84       	ldd	r11, Y+9	; 0x09
		//
		dhcpGetOption(packet->options, DHCP_OPT_ROUTERS, 4, &val);
    2164:	c7 01       	movw	r24, r14
    2166:	63 e0       	ldi	r22, 0x03	; 3
    2168:	44 e0       	ldi	r20, 0x04	; 4
    216a:	96 01       	movw	r18, r12
    216c:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <dhcpGetOption>
		gateway = HTONL(val);
    2170:	4e 80       	ldd	r4, Y+6	; 0x06
    2172:	5f 80       	ldd	r5, Y+7	; 0x07
    2174:	68 84       	ldd	r6, Y+8	; 0x08
    2176:	79 84       	ldd	r7, Y+9	; 0x09
		//
		dhcpGetOption(packet->options, DHCP_OPT_LEASETIME, 4, &val);
    2178:	c7 01       	movw	r24, r14
    217a:	63 e3       	ldi	r22, 0x33	; 51
    217c:	44 e0       	ldi	r20, 0x04	; 4
    217e:	96 01       	movw	r18, r12
    2180:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <dhcpGetOption>
		DhcpLeaseTime = HTONL(val);
    2184:	8e 81       	ldd	r24, Y+6	; 0x06
    2186:	9f 81       	ldd	r25, Y+7	; 0x07
    2188:	a8 85       	ldd	r26, Y+8	; 0x08
    218a:	b9 85       	ldd	r27, Y+9	; 0x09
    218c:	cb 2e       	mov	r12, r27
    218e:	dd 24       	eor	r13, r13
    2190:	ee 24       	eor	r14, r14
    2192:	ff 24       	eor	r15, r15
    2194:	58 2f       	mov	r21, r24
    2196:	44 27       	eor	r20, r20
    2198:	33 27       	eor	r19, r19
    219a:	22 27       	eor	r18, r18
    219c:	c2 2a       	or	r12, r18
    219e:	d3 2a       	or	r13, r19
    21a0:	e4 2a       	or	r14, r20
    21a2:	f5 2a       	or	r15, r21
    21a4:	9c 01       	movw	r18, r24
    21a6:	ad 01       	movw	r20, r26
    21a8:	20 70       	andi	r18, 0x00	; 0
    21aa:	30 70       	andi	r19, 0x00	; 0
    21ac:	50 70       	andi	r21, 0x00	; 0
    21ae:	23 2f       	mov	r18, r19
    21b0:	34 2f       	mov	r19, r20
    21b2:	45 2f       	mov	r20, r21
    21b4:	55 27       	eor	r21, r21
    21b6:	2c 29       	or	r18, r12
    21b8:	3d 29       	or	r19, r13
    21ba:	4e 29       	or	r20, r14
    21bc:	5f 29       	or	r21, r15
    21be:	80 70       	andi	r24, 0x00	; 0
    21c0:	a0 70       	andi	r26, 0x00	; 0
    21c2:	b0 70       	andi	r27, 0x00	; 0
    21c4:	cc 24       	eor	r12, r12
    21c6:	d8 2e       	mov	r13, r24
    21c8:	e9 2e       	mov	r14, r25
    21ca:	fa 2e       	mov	r15, r26
    21cc:	2c 29       	or	r18, r12
    21ce:	3d 29       	or	r19, r13
    21d0:	4e 29       	or	r20, r14
    21d2:	5f 29       	or	r21, r15
    21d4:	20 93 eb 00 	sts	0x00EB, r18
    21d8:	30 93 ec 00 	sts	0x00EC, r19
    21dc:	40 93 ed 00 	sts	0x00ED, r20
    21e0:	50 93 ee 00 	sts	0x00EE, r21
		//
		ipSetConfig(HTONL(packet->bootp.yoipaddr), netmask, gateway);
    21e4:	f8 01       	movw	r30, r16
    21e6:	80 89       	ldd	r24, Z+16	; 0x10
    21e8:	91 89       	ldd	r25, Z+17	; 0x11
    21ea:	a2 89       	ldd	r26, Z+18	; 0x12
    21ec:	b3 89       	ldd	r27, Z+19	; 0x13
    21ee:	eb 2e       	mov	r14, r27
    21f0:	ff 24       	eor	r15, r15
    21f2:	00 27       	eor	r16, r16
    21f4:	11 27       	eor	r17, r17
    21f6:	58 2f       	mov	r21, r24
    21f8:	44 27       	eor	r20, r20
    21fa:	33 27       	eor	r19, r19
    21fc:	22 27       	eor	r18, r18
    21fe:	e2 2a       	or	r14, r18
    2200:	f3 2a       	or	r15, r19
    2202:	04 2b       	or	r16, r20
    2204:	15 2b       	or	r17, r21
    2206:	9c 01       	movw	r18, r24
    2208:	ad 01       	movw	r20, r26
    220a:	20 70       	andi	r18, 0x00	; 0
    220c:	30 70       	andi	r19, 0x00	; 0
    220e:	50 70       	andi	r21, 0x00	; 0
    2210:	23 2f       	mov	r18, r19
    2212:	34 2f       	mov	r19, r20
    2214:	45 2f       	mov	r20, r21
    2216:	55 27       	eor	r21, r21
    2218:	2e 29       	or	r18, r14
    221a:	3f 29       	or	r19, r15
    221c:	40 2b       	or	r20, r16
    221e:	51 2b       	or	r21, r17
    2220:	80 70       	andi	r24, 0x00	; 0
    2222:	a0 70       	andi	r26, 0x00	; 0
    2224:	b0 70       	andi	r27, 0x00	; 0
    2226:	ee 24       	eor	r14, r14
    2228:	f8 2e       	mov	r15, r24
    222a:	09 2f       	mov	r16, r25
    222c:	1a 2f       	mov	r17, r26
    222e:	da 01       	movw	r26, r20
    2230:	c9 01       	movw	r24, r18
    2232:	8e 29       	or	r24, r14
    2234:	9f 29       	or	r25, r15
    2236:	a0 2b       	or	r26, r16
    2238:	b1 2b       	or	r27, r17
    223a:	8a 87       	std	Y+10, r24	; 0x0a
    223c:	9b 87       	std	Y+11, r25	; 0x0b
    223e:	ac 87       	std	Y+12, r26	; 0x0c
    2240:	bd 87       	std	Y+13, r27	; 0x0d
	}
	//
	else if(msgtype == DHCP_MSG_DHCPACK)
	{
		dhcpGetOption(packet->options, DHCP_OPT_NETMASK, 4, &val);
		netmask = HTONL(val);
    2242:	2b 2d       	mov	r18, r11
    2244:	33 27       	eor	r19, r19
    2246:	44 27       	eor	r20, r20
    2248:	55 27       	eor	r21, r21
    224a:	b8 2d       	mov	r27, r8
    224c:	aa 27       	eor	r26, r26
    224e:	99 27       	eor	r25, r25
    2250:	88 27       	eor	r24, r24
    2252:	28 2b       	or	r18, r24
    2254:	39 2b       	or	r19, r25
    2256:	4a 2b       	or	r20, r26
    2258:	5b 2b       	or	r21, r27
    225a:	d5 01       	movw	r26, r10
    225c:	c4 01       	movw	r24, r8
    225e:	80 70       	andi	r24, 0x00	; 0
    2260:	90 70       	andi	r25, 0x00	; 0
    2262:	b0 70       	andi	r27, 0x00	; 0
    2264:	89 2f       	mov	r24, r25
    2266:	9a 2f       	mov	r25, r26
    2268:	ab 2f       	mov	r26, r27
    226a:	bb 27       	eor	r27, r27
    226c:	28 2b       	or	r18, r24
    226e:	39 2b       	or	r19, r25
    2270:	4a 2b       	or	r20, r26
    2272:	5b 2b       	or	r21, r27
    2274:	d5 01       	movw	r26, r10
    2276:	c4 01       	movw	r24, r8
    2278:	80 70       	andi	r24, 0x00	; 0
    227a:	a0 70       	andi	r26, 0x00	; 0
    227c:	b0 70       	andi	r27, 0x00	; 0
    227e:	ba 2f       	mov	r27, r26
    2280:	a9 2f       	mov	r26, r25
    2282:	98 2f       	mov	r25, r24
    2284:	88 27       	eor	r24, r24
    2286:	28 2b       	or	r18, r24
    2288:	39 2b       	or	r19, r25
    228a:	4a 2b       	or	r20, r26
    228c:	5b 2b       	or	r21, r27
		//
		dhcpGetOption(packet->options, DHCP_OPT_ROUTERS, 4, &val);
		gateway = HTONL(val);
    228e:	e7 2c       	mov	r14, r7
    2290:	ff 24       	eor	r15, r15
    2292:	00 27       	eor	r16, r16
    2294:	11 27       	eor	r17, r17
    2296:	b4 2d       	mov	r27, r4
    2298:	aa 27       	eor	r26, r26
    229a:	99 27       	eor	r25, r25
    229c:	88 27       	eor	r24, r24
    229e:	e8 2a       	or	r14, r24
    22a0:	f9 2a       	or	r15, r25
    22a2:	0a 2b       	or	r16, r26
    22a4:	1b 2b       	or	r17, r27
    22a6:	d3 01       	movw	r26, r6
    22a8:	c2 01       	movw	r24, r4
    22aa:	80 70       	andi	r24, 0x00	; 0
    22ac:	90 70       	andi	r25, 0x00	; 0
    22ae:	b0 70       	andi	r27, 0x00	; 0
    22b0:	89 2f       	mov	r24, r25
    22b2:	9a 2f       	mov	r25, r26
    22b4:	ab 2f       	mov	r26, r27
    22b6:	bb 27       	eor	r27, r27
    22b8:	e8 2a       	or	r14, r24
    22ba:	f9 2a       	or	r15, r25
    22bc:	0a 2b       	or	r16, r26
    22be:	1b 2b       	or	r17, r27
    22c0:	d3 01       	movw	r26, r6
    22c2:	c2 01       	movw	r24, r4
    22c4:	80 70       	andi	r24, 0x00	; 0
    22c6:	a0 70       	andi	r26, 0x00	; 0
    22c8:	b0 70       	andi	r27, 0x00	; 0
    22ca:	ba 2f       	mov	r27, r26
    22cc:	a9 2f       	mov	r26, r25
    22ce:	98 2f       	mov	r25, r24
    22d0:	88 27       	eor	r24, r24
    22d2:	e8 2a       	or	r14, r24
    22d4:	f9 2a       	or	r15, r25
    22d6:	0a 2b       	or	r16, r26
    22d8:	1b 2b       	or	r17, r27
		//
		dhcpGetOption(packet->options, DHCP_OPT_LEASETIME, 4, &val);
		DhcpLeaseTime = HTONL(val);
		//
		ipSetConfig(HTONL(packet->bootp.yoipaddr), netmask, gateway);
    22da:	6a 85       	ldd	r22, Y+10	; 0x0a
    22dc:	7b 85       	ldd	r23, Y+11	; 0x0b
    22de:	8c 85       	ldd	r24, Y+12	; 0x0c
    22e0:	9d 85       	ldd	r25, Y+13	; 0x0d
    22e2:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <ipSetConfig>
		//
		DhcpRetries = 0;
    22e6:	10 92 ea 00 	sts	0x00EA, r1
		#ifdef DHCP_DEBUG
		printf("DHCP: Got request ACK, bind complete\r\n");
    22ea:	00 d0       	rcall	.+0      	; 0x22ec <dhcpIn+0x310>
    22ec:	80 e8       	ldi	r24, 0x80	; 128
    22ee:	90 e0       	ldi	r25, 0x00	; 0
    22f0:	ad b7       	in	r26, 0x3d	; 61
    22f2:	be b7       	in	r27, 0x3e	; 62
    22f4:	12 96       	adiw	r26, 0x02	; 2
    22f6:	9c 93       	st	X, r25
    22f8:	8e 93       	st	-X, r24
    22fa:	11 97       	sbiw	r26, 0x01	; 1
    22fc:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
		ipPrintConfig(ipGetConfig());
    2300:	0f 90       	pop	r0
    2302:	0f 90       	pop	r0
    2304:	0e 94 b6 1b 	call	0x376c	; 0x376c <ipGetConfig>
    2308:	0e 94 38 1c 	call	0x3870	; 0x3870 <ipPrintConfig>
		printf("LeaseTm : %d\n\r", DhcpLeaseTime);
    230c:	00 d0       	rcall	.+0      	; 0x230e <dhcpIn+0x332>
    230e:	00 d0       	rcall	.+0      	; 0x2310 <dhcpIn+0x334>
    2310:	00 d0       	rcall	.+0      	; 0x2312 <dhcpIn+0x336>
    2312:	81 e7       	ldi	r24, 0x71	; 113
    2314:	90 e0       	ldi	r25, 0x00	; 0
    2316:	ed b7       	in	r30, 0x3d	; 61
    2318:	fe b7       	in	r31, 0x3e	; 62
    231a:	92 83       	std	Z+2, r25	; 0x02
    231c:	81 83       	std	Z+1, r24	; 0x01
    231e:	80 91 eb 00 	lds	r24, 0x00EB
    2322:	90 91 ec 00 	lds	r25, 0x00EC
    2326:	a0 91 ed 00 	lds	r26, 0x00ED
    232a:	b0 91 ee 00 	lds	r27, 0x00EE
    232e:	83 83       	std	Z+3, r24	; 0x03
    2330:	94 83       	std	Z+4, r25	; 0x04
    2332:	a5 83       	std	Z+5, r26	; 0x05
    2334:	b6 83       	std	Z+6, r27	; 0x06
    2336:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    233a:	8d b7       	in	r24, 0x3d	; 61
    233c:	9e b7       	in	r25, 0x3e	; 62
    233e:	06 96       	adiw	r24, 0x06	; 6
    2340:	0f b6       	in	r0, 0x3f	; 63
    2342:	f8 94       	cli
    2344:	9e bf       	out	0x3e, r25	; 62
    2346:	0f be       	out	0x3f, r0	; 63
    2348:	8d bf       	out	0x3d, r24	; 61
		#endif
	}
}
    234a:	2d 96       	adiw	r28, 0x0d	; 13
    234c:	0f b6       	in	r0, 0x3f	; 63
    234e:	f8 94       	cli
    2350:	de bf       	out	0x3e, r29	; 62
    2352:	0f be       	out	0x3f, r0	; 63
    2354:	cd bf       	out	0x3d, r28	; 61
    2356:	cf 91       	pop	r28
    2358:	df 91       	pop	r29
    235a:	1f 91       	pop	r17
    235c:	0f 91       	pop	r16
    235e:	ff 90       	pop	r15
    2360:	ef 90       	pop	r14
    2362:	df 90       	pop	r13
    2364:	cf 90       	pop	r12
    2366:	bf 90       	pop	r11
    2368:	af 90       	pop	r10
    236a:	9f 90       	pop	r9
    236c:	8f 90       	pop	r8
    236e:	7f 90       	pop	r7
    2370:	6f 90       	pop	r6
    2372:	5f 90       	pop	r5
    2374:	4f 90       	pop	r4
    2376:	08 95       	ret

00002378 <dhcpRelease>:
//--------------------------------------------------------------------------------------
//Ham release dia chi IP hien tai va xoa cac thong so cau hinh IP dang co
void dhcpRelease(void)
{
    2378:	2f 92       	push	r2
    237a:	3f 92       	push	r3
    237c:	4f 92       	push	r4
    237e:	5f 92       	push	r5
    2380:	6f 92       	push	r6
    2382:	7f 92       	push	r7
    2384:	8f 92       	push	r8
    2386:	9f 92       	push	r9
    2388:	af 92       	push	r10
    238a:	bf 92       	push	r11
    238c:	cf 92       	push	r12
    238e:	df 92       	push	r13
    2390:	ef 92       	push	r14
    2392:	ff 92       	push	r15
    2394:	0f 93       	push	r16
    2396:	1f 93       	push	r17
    2398:	df 93       	push	r29
    239a:	cf 93       	push	r28
    239c:	00 d0       	rcall	.+0      	; 0x239e <dhcpRelease+0x26>
    239e:	00 d0       	rcall	.+0      	; 0x23a0 <dhcpRelease+0x28>
    23a0:	cd b7       	in	r28, 0x3d	; 61
    23a2:	de b7       	in	r29, 0x3e	; 62
	struct netDhcpHeader* packet;
	unsigned long val;
	unsigned char* optptr;
	
	packet = (struct netDhcpHeader*)&ethGetBuffer()[ETH_HEADER_LEN+IP_HEADER_LEN+UDP_HEADER_LEN];
    23a4:	0e 94 5f 15 	call	0x2abe	; 0x2abe <ethGetBuffer>
    23a8:	8c 01       	movw	r16, r24
    23aa:	0f 2e       	mov	r0, r31
    23ac:	fa e2       	ldi	r31, 0x2A	; 42
    23ae:	ef 2e       	mov	r14, r31
    23b0:	ff 24       	eor	r15, r15
    23b2:	f0 2d       	mov	r31, r0
    23b4:	e8 0e       	add	r14, r24
    23b6:	f9 1e       	adc	r15, r25

	// build BOOTP/DHCP header
	packet->bootp.opcode = BOOTP_OP_BOOTREQUEST;		// request type
    23b8:	81 e0       	ldi	r24, 0x01	; 1
    23ba:	f8 01       	movw	r30, r16
    23bc:	82 a7       	std	Z+42, r24	; 0x2a
	packet->bootp.hwaddrtype = BOOTP_HTYPE_ETHERNET;
    23be:	f7 01       	movw	r30, r14
    23c0:	81 83       	std	Z+1, r24	; 0x01
	packet->bootp.hwaddrlen = BOOTP_HLEN_ETHERNET;
    23c2:	86 e0       	ldi	r24, 0x06	; 6
    23c4:	82 83       	std	Z+2, r24	; 0x02
	packet->bootp.clipaddr = HTONL(ipGetConfig()->ip);
    23c6:	0e 94 b6 1b 	call	0x376c	; 0x376c <ipGetConfig>
    23ca:	fc 01       	movw	r30, r24
    23cc:	a0 80       	ld	r10, Z
    23ce:	b1 80       	ldd	r11, Z+1	; 0x01
    23d0:	c2 80       	ldd	r12, Z+2	; 0x02
    23d2:	d3 80       	ldd	r13, Z+3	; 0x03
    23d4:	da 2c       	mov	r13, r10
    23d6:	cc 24       	eor	r12, r12
    23d8:	bb 24       	eor	r11, r11
    23da:	aa 24       	eor	r10, r10
    23dc:	0e 94 b6 1b 	call	0x376c	; 0x376c <ipGetConfig>
    23e0:	fc 01       	movw	r30, r24
    23e2:	80 81       	ld	r24, Z
    23e4:	91 81       	ldd	r25, Z+1	; 0x01
    23e6:	a2 81       	ldd	r26, Z+2	; 0x02
    23e8:	b3 81       	ldd	r27, Z+3	; 0x03
    23ea:	80 70       	andi	r24, 0x00	; 0
    23ec:	90 70       	andi	r25, 0x00	; 0
    23ee:	b0 70       	andi	r27, 0x00	; 0
    23f0:	29 2e       	mov	r2, r25
    23f2:	3a 2e       	mov	r3, r26
    23f4:	4b 2e       	mov	r4, r27
    23f6:	55 24       	eor	r5, r5
    23f8:	0e 94 b6 1b 	call	0x376c	; 0x376c <ipGetConfig>
    23fc:	fc 01       	movw	r30, r24
    23fe:	80 81       	ld	r24, Z
    2400:	91 81       	ldd	r25, Z+1	; 0x01
    2402:	a2 81       	ldd	r26, Z+2	; 0x02
    2404:	b3 81       	ldd	r27, Z+3	; 0x03
    2406:	80 70       	andi	r24, 0x00	; 0
    2408:	a0 70       	andi	r26, 0x00	; 0
    240a:	b0 70       	andi	r27, 0x00	; 0
    240c:	66 24       	eor	r6, r6
    240e:	78 2e       	mov	r7, r24
    2410:	89 2e       	mov	r8, r25
    2412:	9a 2e       	mov	r9, r26
    2414:	0e 94 b6 1b 	call	0x376c	; 0x376c <ipGetConfig>
    2418:	fc 01       	movw	r30, r24
    241a:	83 81       	ldd	r24, Z+3	; 0x03
    241c:	90 e0       	ldi	r25, 0x00	; 0
    241e:	a0 e0       	ldi	r26, 0x00	; 0
    2420:	b0 e0       	ldi	r27, 0x00	; 0
    2422:	a8 2a       	or	r10, r24
    2424:	b9 2a       	or	r11, r25
    2426:	ca 2a       	or	r12, r26
    2428:	db 2a       	or	r13, r27
    242a:	a2 28       	or	r10, r2
    242c:	b3 28       	or	r11, r3
    242e:	c4 28       	or	r12, r4
    2430:	d5 28       	or	r13, r5
    2432:	6a 28       	or	r6, r10
    2434:	7b 28       	or	r7, r11
    2436:	8c 28       	or	r8, r12
    2438:	9d 28       	or	r9, r13
    243a:	f7 01       	movw	r30, r14
    243c:	64 86       	std	Z+12, r6	; 0x0c
    243e:	75 86       	std	Z+13, r7	; 0x0d
    2440:	86 86       	std	Z+14, r8	; 0x0e
    2442:	97 86       	std	Z+15, r9	; 0x0f
	packet->bootp.yoipaddr = HTONL(0l);
    2444:	10 8a       	std	Z+16, r1	; 0x10
    2446:	11 8a       	std	Z+17, r1	; 0x11
    2448:	12 8a       	std	Z+18, r1	; 0x12
    244a:	13 8a       	std	Z+19, r1	; 0x13
	packet->bootp.seipaddr = HTONL(0l);
    244c:	14 8a       	std	Z+20, r1	; 0x14
    244e:	15 8a       	std	Z+21, r1	; 0x15
    2450:	16 8a       	std	Z+22, r1	; 0x16
    2452:	17 8a       	std	Z+23, r1	; 0x17
	packet->bootp.gwipaddr = HTONL(0l);
    2454:	10 8e       	std	Z+24, r1	; 0x18
    2456:	11 8e       	std	Z+25, r1	; 0x19
    2458:	12 8e       	std	Z+26, r1	; 0x1a
    245a:	13 8e       	std	Z+27, r1	; 0x1b
	ethGetMacAddress(&packet->bootp.clhwaddr[0]);	// fill client hardware address
    245c:	c7 01       	movw	r24, r14
    245e:	4c 96       	adiw	r24, 0x1c	; 28
    2460:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <ethGetMacAddress>
	packet->bootp.transid = DhcpTransactID;			// set trans ID (use part of MAC address)
    2464:	80 91 e6 00 	lds	r24, 0x00E6
    2468:	90 91 e7 00 	lds	r25, 0x00E7
    246c:	a0 91 e8 00 	lds	r26, 0x00E8
    2470:	b0 91 e9 00 	lds	r27, 0x00E9
    2474:	f7 01       	movw	r30, r14
    2476:	84 83       	std	Z+4, r24	; 0x04
    2478:	95 83       	std	Z+5, r25	; 0x05
    247a:	a6 83       	std	Z+6, r26	; 0x06
    247c:	b7 83       	std	Z+7, r27	; 0x07
	packet->bootp.flags = HTONS(1);
    247e:	80 e0       	ldi	r24, 0x00	; 0
    2480:	91 e0       	ldi	r25, 0x01	; 1
    2482:	93 87       	std	Z+11, r25	; 0x0b
    2484:	82 87       	std	Z+10, r24	; 0x0a
	
	// build DHCP request
	// begin with magic cookie
	packet->cookie = 0x63538263;
    2486:	f8 01       	movw	r30, r16
    2488:	ea 5e       	subi	r30, 0xEA	; 234
    248a:	fe 4f       	sbci	r31, 0xFE	; 254
    248c:	83 e6       	ldi	r24, 0x63	; 99
    248e:	92 e8       	ldi	r25, 0x82	; 130
    2490:	a3 e5       	ldi	r26, 0x53	; 83
    2492:	b3 e6       	ldi	r27, 0x63	; 99
    2494:	80 83       	st	Z, r24
    2496:	91 83       	std	Z+1, r25	; 0x01
    2498:	a2 83       	std	Z+2, r26	; 0x02
    249a:	b3 83       	std	Z+3, r27	; 0x03
	//
	// set operation
	val = DHCP_MSG_DHCPRELEASE;
    249c:	87 e0       	ldi	r24, 0x07	; 7
    249e:	90 e0       	ldi	r25, 0x00	; 0
    24a0:	a0 e0       	ldi	r26, 0x00	; 0
    24a2:	b0 e0       	ldi	r27, 0x00	; 0
    24a4:	89 83       	std	Y+1, r24	; 0x01
    24a6:	9a 83       	std	Y+2, r25	; 0x02
    24a8:	ab 83       	std	Y+3, r26	; 0x03
    24aa:	bc 83       	std	Y+4, r27	; 0x04
	optptr = dhcpSetOption(packet->options, DHCP_OPT_DHCPMSGTYPE, 1, &val);
    24ac:	c8 01       	movw	r24, r16
    24ae:	86 5e       	subi	r24, 0xE6	; 230
    24b0:	9e 4f       	sbci	r25, 0xFE	; 254
    24b2:	65 e3       	ldi	r22, 0x35	; 53
    24b4:	41 e0       	ldi	r20, 0x01	; 1
    24b6:	2e 01       	movw	r4, r28
    24b8:	08 94       	sec
    24ba:	41 1c       	adc	r4, r1
    24bc:	51 1c       	adc	r5, r1
    24be:	92 01       	movw	r18, r4
    24c0:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <dhcpSetOption>
	// set the server ID
	val = HTONL(DhcpServerIP);
    24c4:	20 91 ef 00 	lds	r18, 0x00EF
    24c8:	30 91 f0 00 	lds	r19, 0x00F0
    24cc:	40 91 f1 00 	lds	r20, 0x00F1
    24d0:	50 91 f2 00 	lds	r21, 0x00F2
    24d4:	65 2e       	mov	r6, r21
    24d6:	77 24       	eor	r7, r7
    24d8:	88 24       	eor	r8, r8
    24da:	99 24       	eor	r9, r9
    24dc:	d2 2e       	mov	r13, r18
    24de:	cc 24       	eor	r12, r12
    24e0:	bb 24       	eor	r11, r11
    24e2:	aa 24       	eor	r10, r10
    24e4:	6a 28       	or	r6, r10
    24e6:	7b 28       	or	r7, r11
    24e8:	8c 28       	or	r8, r12
    24ea:	9d 28       	or	r9, r13
    24ec:	0f 2e       	mov	r0, r31
    24ee:	f0 e0       	ldi	r31, 0x00	; 0
    24f0:	af 2e       	mov	r10, r31
    24f2:	f0 e0       	ldi	r31, 0x00	; 0
    24f4:	bf 2e       	mov	r11, r31
    24f6:	ff ef       	ldi	r31, 0xFF	; 255
    24f8:	cf 2e       	mov	r12, r31
    24fa:	f0 e0       	ldi	r31, 0x00	; 0
    24fc:	df 2e       	mov	r13, r31
    24fe:	f0 2d       	mov	r31, r0
    2500:	a2 22       	and	r10, r18
    2502:	b3 22       	and	r11, r19
    2504:	c4 22       	and	r12, r20
    2506:	d5 22       	and	r13, r21
    2508:	ab 2c       	mov	r10, r11
    250a:	bc 2c       	mov	r11, r12
    250c:	cd 2c       	mov	r12, r13
    250e:	dd 24       	eor	r13, r13
    2510:	6a 28       	or	r6, r10
    2512:	7b 28       	or	r7, r11
    2514:	8c 28       	or	r8, r12
    2516:	9d 28       	or	r9, r13
    2518:	20 70       	andi	r18, 0x00	; 0
    251a:	40 70       	andi	r20, 0x00	; 0
    251c:	50 70       	andi	r21, 0x00	; 0
    251e:	aa 24       	eor	r10, r10
    2520:	b2 2e       	mov	r11, r18
    2522:	c3 2e       	mov	r12, r19
    2524:	d4 2e       	mov	r13, r20
    2526:	a6 28       	or	r10, r6
    2528:	b7 28       	or	r11, r7
    252a:	c8 28       	or	r12, r8
    252c:	d9 28       	or	r13, r9
    252e:	a9 82       	std	Y+1, r10	; 0x01
    2530:	ba 82       	std	Y+2, r11	; 0x02
    2532:	cb 82       	std	Y+3, r12	; 0x03
    2534:	dc 82       	std	Y+4, r13	; 0x04
	optptr = dhcpSetOption(optptr, DHCP_OPT_SERVERID, 4, &val);
    2536:	66 e3       	ldi	r22, 0x36	; 54
    2538:	44 e0       	ldi	r20, 0x04	; 4
    253a:	92 01       	movw	r18, r4
    253c:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <dhcpSetOption>
	// request the IP previously offered
	optptr = dhcpSetOption(optptr, DHCP_OPT_REQUESTEDIP, 4, &packet->bootp.clipaddr);
    2540:	98 01       	movw	r18, r16
    2542:	2a 5c       	subi	r18, 0xCA	; 202
    2544:	3f 4f       	sbci	r19, 0xFF	; 255
    2546:	62 e3       	ldi	r22, 0x32	; 50
    2548:	44 e0       	ldi	r20, 0x04	; 4
    254a:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <dhcpSetOption>
	//
	#ifdef DHCP_DEBUG
	printf("DHCP: Sending Release to "); ipPrintAddr(DhcpServerIP); printf("\n\r");
    254e:	00 d0       	rcall	.+0      	; 0x2550 <dhcpRelease+0x1d8>
    2550:	87 e5       	ldi	r24, 0x57	; 87
    2552:	90 e0       	ldi	r25, 0x00	; 0
    2554:	ed b7       	in	r30, 0x3d	; 61
    2556:	fe b7       	in	r31, 0x3e	; 62
    2558:	92 83       	std	Z+2, r25	; 0x02
    255a:	81 83       	std	Z+1, r24	; 0x01
    255c:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    2560:	0f 90       	pop	r0
    2562:	0f 90       	pop	r0
    2564:	60 91 ef 00 	lds	r22, 0x00EF
    2568:	70 91 f0 00 	lds	r23, 0x00F0
    256c:	80 91 f1 00 	lds	r24, 0x00F1
    2570:	90 91 f2 00 	lds	r25, 0x00F2
    2574:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <ipPrintAddr>
    2578:	00 d0       	rcall	.+0      	; 0x257a <dhcpRelease+0x202>
    257a:	84 e5       	ldi	r24, 0x54	; 84
    257c:	90 e0       	ldi	r25, 0x00	; 0
    257e:	ed b7       	in	r30, 0x3d	; 61
    2580:	fe b7       	in	r31, 0x3e	; 62
    2582:	92 83       	std	Z+2, r25	; 0x02
    2584:	81 83       	std	Z+1, r24	; 0x01
    2586:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	//dhcpPrintHeader(packet);
	#endif

	// send release
	udpSend(DhcpServerIP, DHCP_UDP_SERVER_PORT, DHCP_UDP_CLIENT_PORT, DHCP_HEADER_LEN+3+6+6+1, (unsigned char*)packet);
    258a:	0f 90       	pop	r0
    258c:	0f 90       	pop	r0
    258e:	60 91 ef 00 	lds	r22, 0x00EF
    2592:	70 91 f0 00 	lds	r23, 0x00F0
    2596:	80 91 f1 00 	lds	r24, 0x00F1
    259a:	90 91 f2 00 	lds	r25, 0x00F2
    259e:	43 e4       	ldi	r20, 0x43	; 67
    25a0:	50 e0       	ldi	r21, 0x00	; 0
    25a2:	24 e4       	ldi	r18, 0x44	; 68
    25a4:	30 e0       	ldi	r19, 0x00	; 0
    25a6:	00 e0       	ldi	r16, 0x00	; 0
    25a8:	11 e0       	ldi	r17, 0x01	; 1
    25aa:	0e 94 8d 2b 	call	0x571a	; 0x571a <udpSend>
	
	// deconfigure ip addressing
	ipSetConfig(0,0,0);
    25ae:	60 e0       	ldi	r22, 0x00	; 0
    25b0:	70 e0       	ldi	r23, 0x00	; 0
    25b2:	cb 01       	movw	r24, r22
    25b4:	20 e0       	ldi	r18, 0x00	; 0
    25b6:	30 e0       	ldi	r19, 0x00	; 0
    25b8:	a9 01       	movw	r20, r18
    25ba:	ee 24       	eor	r14, r14
    25bc:	ff 24       	eor	r15, r15
    25be:	87 01       	movw	r16, r14
    25c0:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <ipSetConfig>
	DhcpLeaseTime = 0;
    25c4:	10 92 eb 00 	sts	0x00EB, r1
    25c8:	10 92 ec 00 	sts	0x00EC, r1
    25cc:	10 92 ed 00 	sts	0x00ED, r1
    25d0:	10 92 ee 00 	sts	0x00EE, r1
}
    25d4:	0f 90       	pop	r0
    25d6:	0f 90       	pop	r0
    25d8:	0f 90       	pop	r0
    25da:	0f 90       	pop	r0
    25dc:	cf 91       	pop	r28
    25de:	df 91       	pop	r29
    25e0:	1f 91       	pop	r17
    25e2:	0f 91       	pop	r16
    25e4:	ff 90       	pop	r15
    25e6:	ef 90       	pop	r14
    25e8:	df 90       	pop	r13
    25ea:	cf 90       	pop	r12
    25ec:	bf 90       	pop	r11
    25ee:	af 90       	pop	r10
    25f0:	9f 90       	pop	r9
    25f2:	8f 90       	pop	r8
    25f4:	7f 90       	pop	r7
    25f6:	6f 90       	pop	r6
    25f8:	5f 90       	pop	r5
    25fa:	4f 90       	pop	r4
    25fc:	3f 90       	pop	r3
    25fe:	2f 90       	pop	r2
    2600:	08 95       	ret

00002602 <dhcpTimer>:
//Ham duoc goi dinh ky moi 1s de cap nhat lease time va timeout cua DHCP
void dhcpTimer(void)
{
	// this function to be called once per second
	// decrement lease time
	if(DhcpLeaseTime)
    2602:	80 91 eb 00 	lds	r24, 0x00EB
    2606:	90 91 ec 00 	lds	r25, 0x00EC
    260a:	a0 91 ed 00 	lds	r26, 0x00ED
    260e:	b0 91 ee 00 	lds	r27, 0x00EE
    2612:	00 97       	sbiw	r24, 0x00	; 0
    2614:	a1 05       	cpc	r26, r1
    2616:	b1 05       	cpc	r27, r1
    2618:	59 f0       	breq	.+22     	; 0x2630 <dhcpTimer+0x2e>
		DhcpLeaseTime--;
    261a:	01 97       	sbiw	r24, 0x01	; 1
    261c:	a1 09       	sbc	r26, r1
    261e:	b1 09       	sbc	r27, r1
    2620:	80 93 eb 00 	sts	0x00EB, r24
    2624:	90 93 ec 00 	sts	0x00EC, r25
    2628:	a0 93 ed 00 	sts	0x00ED, r26
    262c:	b0 93 ee 00 	sts	0x00EE, r27
	if(DhcpTimeout){
    2630:	80 91 f9 00 	lds	r24, 0x00F9
    2634:	88 23       	and	r24, r24
    2636:	19 f0       	breq	.+6      	; 0x263e <dhcpTimer+0x3c>
		DhcpTimeout--;
    2638:	81 50       	subi	r24, 0x01	; 1
    263a:	80 93 f9 00 	sts	0x00F9, r24
    263e:	08 95       	ret

00002640 <dhcpService>:
}
//--------------------------------------------------------------------------------------
//Ham dich vu DHCP, duoc goi trong chuong trinh chinh
void dhcpService(void)
{
	if(DhcpRetries && (DhcpTimeout == 0)){
    2640:	80 91 ea 00 	lds	r24, 0x00EA
    2644:	88 23       	and	r24, r24
    2646:	61 f0       	breq	.+24     	; 0x2660 <dhcpService+0x20>
    2648:	90 91 f9 00 	lds	r25, 0x00F9
    264c:	99 23       	and	r25, r25
    264e:	41 f4       	brne	.+16     	; 0x2660 <dhcpService+0x20>
		DhcpRetries--;
    2650:	81 50       	subi	r24, 0x01	; 1
    2652:	80 93 ea 00 	sts	0x00EA, r24
		DhcpTimeout = DHCP_TIMEOUT;
    2656:	8a e0       	ldi	r24, 0x0A	; 10
    2658:	80 93 f9 00 	sts	0x00F9, r24
		dhcpDiscover();
    265c:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <dhcpDiscover>
    2660:	08 95       	ret

00002662 <enc28j60SPIRead>:
//----------------------------------------------------------------------------

unsigned char enc28j60SPIRead(unsigned char op, unsigned char address)
{
	unsigned char res;
	ENC28J60_CS_LO();
    2662:	c3 98       	cbi	0x18, 3	; 24
	SPDR = op | (address & ADDR_MASK);
    2664:	96 2f       	mov	r25, r22
    2666:	6f 71       	andi	r22, 0x1F	; 31
    2668:	68 2b       	or	r22, r24
    266a:	6f b9       	out	0x0f, r22	; 15
	while(!(SPSR & (1<<SPIF))); 
    266c:	77 9b       	sbis	0x0e, 7	; 14
    266e:	fe cf       	rjmp	.-4      	; 0x266c <enc28j60SPIRead+0xa>
	SPDR = 0x00; 
    2670:	1f b8       	out	0x0f, r1	; 15
	while(!(SPSR & (1<<SPIF))); 
    2672:	77 9b       	sbis	0x0e, 7	; 14
    2674:	fe cf       	rjmp	.-4      	; 0x2672 <enc28j60SPIRead+0x10>
	if(address & 0x80){  
    2676:	99 23       	and	r25, r25
    2678:	1c f4       	brge	.+6      	; 0x2680 <enc28j60SPIRead+0x1e>
		SPDR = 0x00;
    267a:	1f b8       	out	0x0f, r1	; 15
		while(!((SPSR) & (1<<SPIF)));
    267c:	77 9b       	sbis	0x0e, 7	; 14
    267e:	fe cf       	rjmp	.-4      	; 0x267c <enc28j60SPIRead+0x1a>
	}
	res = SPDR; 
    2680:	8f b1       	in	r24, 0x0f	; 15
	ENC28J60_CS_HI();
    2682:	c3 9a       	sbi	0x18, 3	; 24
	return res;
}
    2684:	08 95       	ret

00002686 <enc28j60SPIWrite>:

void enc28j60SPIWrite(unsigned char op, unsigned char address, unsigned char data)
{
	ENC28J60_CS_LO();
    2686:	c3 98       	cbi	0x18, 3	; 24
	SPDR = op | (address & ADDR_MASK);
    2688:	6f 71       	andi	r22, 0x1F	; 31
    268a:	68 2b       	or	r22, r24
    268c:	6f b9       	out	0x0f, r22	; 15
	while(!(SPSR & (1<<SPIF)));
    268e:	77 9b       	sbis	0x0e, 7	; 14
    2690:	fe cf       	rjmp	.-4      	; 0x268e <enc28j60SPIWrite+0x8>
	SPDR = data;
    2692:	4f b9       	out	0x0f, r20	; 15
	while(!(SPSR & (1<<SPIF)));
    2694:	77 9b       	sbis	0x0e, 7	; 14
    2696:	fe cf       	rjmp	.-4      	; 0x2694 <enc28j60SPIWrite+0xe>
	ENC28J60_CS_HI();
    2698:	c3 9a       	sbi	0x18, 3	; 24
}
    269a:	08 95       	ret

0000269c <enc28j60SetBank>:

void enc28j60SetBank(unsigned char address)
{
    269c:	1f 93       	push	r17
    269e:	cf 93       	push	r28
    26a0:	df 93       	push	r29
    26a2:	18 2f       	mov	r17, r24
	if((address & BANK_MASK) != Enc28j60Bank)
    26a4:	c8 2f       	mov	r28, r24
    26a6:	d0 e0       	ldi	r29, 0x00	; 0
    26a8:	c0 76       	andi	r28, 0x60	; 96
    26aa:	d0 70       	andi	r29, 0x00	; 0
    26ac:	80 91 fc 00 	lds	r24, 0x00FC
    26b0:	90 e0       	ldi	r25, 0x00	; 0
    26b2:	c8 17       	cp	r28, r24
    26b4:	d9 07       	cpc	r29, r25
    26b6:	b9 f0       	breq	.+46     	; 0x26e6 <enc28j60SetBank+0x4a>
	{
		enc28j60SPIWrite(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
    26b8:	80 ea       	ldi	r24, 0xA0	; 160
    26ba:	6f e1       	ldi	r22, 0x1F	; 31
    26bc:	43 e0       	ldi	r20, 0x03	; 3
    26be:	0e 94 43 13 	call	0x2686	; 0x2686 <enc28j60SPIWrite>
		enc28j60SPIWrite(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
    26c2:	ae 01       	movw	r20, r28
    26c4:	55 95       	asr	r21
    26c6:	47 95       	ror	r20
    26c8:	55 95       	asr	r21
    26ca:	47 95       	ror	r20
    26cc:	55 95       	asr	r21
    26ce:	47 95       	ror	r20
    26d0:	55 95       	asr	r21
    26d2:	47 95       	ror	r20
    26d4:	55 95       	asr	r21
    26d6:	47 95       	ror	r20
    26d8:	80 e8       	ldi	r24, 0x80	; 128
    26da:	6f e1       	ldi	r22, 0x1F	; 31
    26dc:	0e 94 43 13 	call	0x2686	; 0x2686 <enc28j60SPIWrite>
		Enc28j60Bank = (address & BANK_MASK);
    26e0:	10 76       	andi	r17, 0x60	; 96
    26e2:	10 93 fc 00 	sts	0x00FC, r17
	}
}
    26e6:	df 91       	pop	r29
    26e8:	cf 91       	pop	r28
    26ea:	1f 91       	pop	r17
    26ec:	08 95       	ret

000026ee <enc28j60ReadBuffer>:

void enc28j60ReadBuffer(unsigned int len, unsigned char* data)
{
	ENC28J60_CS_LO();
    26ee:	c3 98       	cbi	0x18, 3	; 24
	SPDR = ENC28J60_READ_BUF_MEM;
    26f0:	2a e3       	ldi	r18, 0x3A	; 58
    26f2:	2f b9       	out	0x0f, r18	; 15
	while(!(SPSR & (1<<SPIF)));
    26f4:	77 9b       	sbis	0x0e, 7	; 14
    26f6:	fe cf       	rjmp	.-4      	; 0x26f4 <enc28j60ReadBuffer+0x6>
	while(len--)
    26f8:	00 97       	sbiw	r24, 0x00	; 0
    26fa:	49 f0       	breq	.+18     	; 0x270e <enc28j60ReadBuffer+0x20>
    26fc:	e6 2f       	mov	r30, r22
    26fe:	f7 2f       	mov	r31, r23
	{
		SPDR = 0x00;
    2700:	1f b8       	out	0x0f, r1	; 15
		while(!(SPSR & (1<<SPIF)));
    2702:	77 9b       	sbis	0x0e, 7	; 14
    2704:	fe cf       	rjmp	.-4      	; 0x2702 <enc28j60ReadBuffer+0x14>
		*data++ = SPDR;
    2706:	2f b1       	in	r18, 0x0f	; 15
    2708:	21 93       	st	Z+, r18
    270a:	01 97       	sbiw	r24, 0x01	; 1
void enc28j60ReadBuffer(unsigned int len, unsigned char* data)
{
	ENC28J60_CS_LO();
	SPDR = ENC28J60_READ_BUF_MEM;
	while(!(SPSR & (1<<SPIF)));
	while(len--)
    270c:	c9 f7       	brne	.-14     	; 0x2700 <enc28j60ReadBuffer+0x12>
	{
		SPDR = 0x00;
		while(!(SPSR & (1<<SPIF)));
		*data++ = SPDR;
	}	
	ENC28J60_CS_HI();
    270e:	c3 9a       	sbi	0x18, 3	; 24
}
    2710:	08 95       	ret

00002712 <enc28j60WriteBuffer>:

void enc28j60WriteBuffer(unsigned int len, unsigned char* data)
{
    2712:	fb 01       	movw	r30, r22
	ENC28J60_CS_LO();
    2714:	c3 98       	cbi	0x18, 3	; 24
	SPDR = ENC28J60_WRITE_BUF_MEM;
    2716:	2a e7       	ldi	r18, 0x7A	; 122
    2718:	2f b9       	out	0x0f, r18	; 15
	while(!(SPSR & (1<<SPIF)));
    271a:	77 9b       	sbis	0x0e, 7	; 14
    271c:	fe cf       	rjmp	.-4      	; 0x271a <enc28j60WriteBuffer+0x8>
    271e:	05 c0       	rjmp	.+10     	; 0x272a <enc28j60WriteBuffer+0x18>
	while(len--)
	{
		SPDR = *data++;
    2720:	21 91       	ld	r18, Z+
    2722:	2f b9       	out	0x0f, r18	; 15
		while(!(SPSR & (1<<SPIF)));
    2724:	77 9b       	sbis	0x0e, 7	; 14
    2726:	fe cf       	rjmp	.-4      	; 0x2724 <enc28j60WriteBuffer+0x12>
    2728:	01 97       	sbiw	r24, 0x01	; 1
void enc28j60WriteBuffer(unsigned int len, unsigned char* data)
{
	ENC28J60_CS_LO();
	SPDR = ENC28J60_WRITE_BUF_MEM;
	while(!(SPSR & (1<<SPIF)));
	while(len--)
    272a:	00 97       	sbiw	r24, 0x00	; 0
    272c:	c9 f7       	brne	.-14     	; 0x2720 <enc28j60WriteBuffer+0xe>
	{
		SPDR = *data++;
		while(!(SPSR & (1<<SPIF)));
	}	
	ENC28J60_CS_HI();
    272e:	c3 9a       	sbi	0x18, 3	; 24
}
    2730:	08 95       	ret

00002732 <enc28j60Read>:

unsigned char enc28j60Read(unsigned char address)
{
    2732:	1f 93       	push	r17
    2734:	18 2f       	mov	r17, r24
	enc28j60SetBank(address);
    2736:	0e 94 4e 13 	call	0x269c	; 0x269c <enc28j60SetBank>
	return enc28j60SPIRead(ENC28J60_READ_CTRL_REG, address);
    273a:	80 e0       	ldi	r24, 0x00	; 0
    273c:	61 2f       	mov	r22, r17
    273e:	0e 94 31 13 	call	0x2662	; 0x2662 <enc28j60SPIRead>
}
    2742:	1f 91       	pop	r17
    2744:	08 95       	ret

00002746 <enc28j60Write>:

void enc28j60Write(unsigned char address, unsigned char data)
{
    2746:	0f 93       	push	r16
    2748:	1f 93       	push	r17
    274a:	18 2f       	mov	r17, r24
    274c:	06 2f       	mov	r16, r22
	enc28j60SetBank(address);
    274e:	0e 94 4e 13 	call	0x269c	; 0x269c <enc28j60SetBank>
	enc28j60SPIWrite(ENC28J60_WRITE_CTRL_REG, address, data);
    2752:	80 e4       	ldi	r24, 0x40	; 64
    2754:	61 2f       	mov	r22, r17
    2756:	40 2f       	mov	r20, r16
    2758:	0e 94 43 13 	call	0x2686	; 0x2686 <enc28j60SPIWrite>
}
    275c:	1f 91       	pop	r17
    275e:	0f 91       	pop	r16
    2760:	08 95       	ret

00002762 <enc28j60PhyRead>:

unsigned int enc28j60PhyRead(unsigned char address)
{
    2762:	ef 92       	push	r14
    2764:	ff 92       	push	r15
    2766:	cf 93       	push	r28
    2768:	df 93       	push	r29
    276a:	68 2f       	mov	r22, r24
	unsigned int data;
	enc28j60Write(MIREGADR, address);
    276c:	84 ed       	ldi	r24, 0xD4	; 212
    276e:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60Write(MICMD, MICMD_MIIRD);
    2772:	82 ed       	ldi	r24, 0xD2	; 210
    2774:	61 e0       	ldi	r22, 0x01	; 1
    2776:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	while(enc28j60Read(MISTAT) & MISTAT_BUSY);
    277a:	8a ee       	ldi	r24, 0xEA	; 234
    277c:	0e 94 99 13 	call	0x2732	; 0x2732 <enc28j60Read>
    2780:	80 fd       	sbrc	r24, 0
    2782:	fb cf       	rjmp	.-10     	; 0x277a <enc28j60PhyRead+0x18>
	enc28j60Write(MICMD, 0x00);
    2784:	82 ed       	ldi	r24, 0xD2	; 210
    2786:	60 e0       	ldi	r22, 0x00	; 0
    2788:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	data  = enc28j60Read(MIRDL);
    278c:	88 ed       	ldi	r24, 0xD8	; 216
    278e:	0e 94 99 13 	call	0x2732	; 0x2732 <enc28j60Read>
    2792:	c8 2f       	mov	r28, r24
    2794:	d0 e0       	ldi	r29, 0x00	; 0
	data |= enc28j60Read(MIRDH);
    2796:	89 ed       	ldi	r24, 0xD9	; 217
    2798:	0e 94 99 13 	call	0x2732	; 0x2732 <enc28j60Read>
    279c:	90 e0       	ldi	r25, 0x00	; 0
    279e:	c8 2b       	or	r28, r24
    27a0:	d9 2b       	or	r29, r25
	return data;
}
    27a2:	7e 01       	movw	r14, r28
    27a4:	8c 2f       	mov	r24, r28
    27a6:	9f 2d       	mov	r25, r15
    27a8:	df 91       	pop	r29
    27aa:	cf 91       	pop	r28
    27ac:	ff 90       	pop	r15
    27ae:	ef 90       	pop	r14
    27b0:	08 95       	ret

000027b2 <enc28j60PhyWrite>:

void enc28j60PhyWrite(unsigned char address, unsigned int data)
{
    27b2:	0f 93       	push	r16
    27b4:	1f 93       	push	r17
    27b6:	98 2f       	mov	r25, r24
    27b8:	06 2f       	mov	r16, r22
    27ba:	17 2f       	mov	r17, r23
	enc28j60Write(MIREGADR, address);
    27bc:	84 ed       	ldi	r24, 0xD4	; 212
    27be:	69 2f       	mov	r22, r25
    27c0:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60Write(MIWRL, data);	
    27c4:	86 ed       	ldi	r24, 0xD6	; 214
    27c6:	60 2f       	mov	r22, r16
    27c8:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60Write(MIWRH, data>>8);
    27cc:	87 ed       	ldi	r24, 0xD7	; 215
    27ce:	61 2f       	mov	r22, r17
    27d0:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	while(enc28j60Read(MISTAT) & MISTAT_BUSY);
    27d4:	8a ee       	ldi	r24, 0xEA	; 234
    27d6:	0e 94 99 13 	call	0x2732	; 0x2732 <enc28j60Read>
    27da:	80 fd       	sbrc	r24, 0
    27dc:	fb cf       	rjmp	.-10     	; 0x27d4 <enc28j60PhyWrite+0x22>
}
    27de:	1f 91       	pop	r17
    27e0:	0f 91       	pop	r16
    27e2:	08 95       	ret

000027e4 <enc28j60PacketSend>:

void enc28j60PacketSend(unsigned int len, unsigned char* packet)
{
    27e4:	0f 93       	push	r16
    27e6:	1f 93       	push	r17
    27e8:	cf 93       	push	r28
    27ea:	df 93       	push	r29
    27ec:	08 2f       	mov	r16, r24
    27ee:	19 2f       	mov	r17, r25
    27f0:	eb 01       	movw	r28, r22
	enc28j60Write(EWRPTL, TXSTART_INIT);
    27f2:	82 e0       	ldi	r24, 0x02	; 2
    27f4:	60 e0       	ldi	r22, 0x00	; 0
    27f6:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
    27fa:	83 e0       	ldi	r24, 0x03	; 3
    27fc:	60 e0       	ldi	r22, 0x00	; 0
    27fe:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60Write(ETXNDL, (TXSTART_INIT+len));
    2802:	86 e0       	ldi	r24, 0x06	; 6
    2804:	60 2f       	mov	r22, r16
    2806:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
    280a:	87 e0       	ldi	r24, 0x07	; 7
    280c:	61 2f       	mov	r22, r17
    280e:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60SPIWrite(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
    2812:	8a e7       	ldi	r24, 0x7A	; 122
    2814:	60 e0       	ldi	r22, 0x00	; 0
    2816:	40 e0       	ldi	r20, 0x00	; 0
    2818:	0e 94 43 13 	call	0x2686	; 0x2686 <enc28j60SPIWrite>

	enc28j60WriteBuffer(len, packet);
    281c:	80 2f       	mov	r24, r16
    281e:	91 2f       	mov	r25, r17
    2820:	be 01       	movw	r22, r28
    2822:	0e 94 89 13 	call	0x2712	; 0x2712 <enc28j60WriteBuffer>
	enc28j60SPIWrite(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
    2826:	80 e8       	ldi	r24, 0x80	; 128
    2828:	6f e1       	ldi	r22, 0x1F	; 31
    282a:	48 e0       	ldi	r20, 0x08	; 8
    282c:	0e 94 43 13 	call	0x2686	; 0x2686 <enc28j60SPIWrite>
}
    2830:	df 91       	pop	r29
    2832:	cf 91       	pop	r28
    2834:	1f 91       	pop	r17
    2836:	0f 91       	pop	r16
    2838:	08 95       	ret

0000283a <enc28j60PacketReceive>:

unsigned int NextPacketPtr;

unsigned int enc28j60PacketReceive(unsigned int maxlen, unsigned char* packet)
{
    283a:	ef 92       	push	r14
    283c:	ff 92       	push	r15
    283e:	0f 93       	push	r16
    2840:	1f 93       	push	r17
    2842:	cf 93       	push	r28
    2844:	df 93       	push	r29
    2846:	8c 01       	movw	r16, r24
    2848:	7b 01       	movw	r14, r22
	unsigned int rxstat;
	unsigned int len;
	if( !enc28j60Read(EPKTCNT) )
    284a:	89 e3       	ldi	r24, 0x39	; 57
    284c:	0e 94 99 13 	call	0x2732	; 0x2732 <enc28j60Read>
    2850:	88 23       	and	r24, r24
    2852:	09 f4       	brne	.+2      	; 0x2856 <enc28j60PacketReceive+0x1c>
    2854:	50 c0       	rjmp	.+160    	; 0x28f6 <enc28j60PacketReceive+0xbc>
		return 0;
	enc28j60Write(ERDPTL, (NextPacketPtr));
    2856:	80 e0       	ldi	r24, 0x00	; 0
    2858:	60 91 fa 00 	lds	r22, 0x00FA
    285c:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
    2860:	60 91 fb 00 	lds	r22, 0x00FB
    2864:	81 e0       	ldi	r24, 0x01	; 1
    2866:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	NextPacketPtr  = enc28j60SPIRead(ENC28J60_READ_BUF_MEM, 0);
    286a:	8a e3       	ldi	r24, 0x3A	; 58
    286c:	60 e0       	ldi	r22, 0x00	; 0
    286e:	0e 94 31 13 	call	0x2662	; 0x2662 <enc28j60SPIRead>
    2872:	80 93 fa 00 	sts	0x00FA, r24
    2876:	10 92 fb 00 	sts	0x00FB, r1
	NextPacketPtr |= ((unsigned int)enc28j60SPIRead(ENC28J60_READ_BUF_MEM, 0))<<8;
    287a:	8a e3       	ldi	r24, 0x3A	; 58
    287c:	60 e0       	ldi	r22, 0x00	; 0
    287e:	0e 94 31 13 	call	0x2662	; 0x2662 <enc28j60SPIRead>
    2882:	38 2f       	mov	r19, r24
    2884:	20 e0       	ldi	r18, 0x00	; 0
    2886:	80 91 fa 00 	lds	r24, 0x00FA
    288a:	90 91 fb 00 	lds	r25, 0x00FB
    288e:	28 2b       	or	r18, r24
    2890:	39 2b       	or	r19, r25
    2892:	30 93 fb 00 	sts	0x00FB, r19
    2896:	20 93 fa 00 	sts	0x00FA, r18
	len  = enc28j60SPIRead(ENC28J60_READ_BUF_MEM, 0);
    289a:	8a e3       	ldi	r24, 0x3A	; 58
    289c:	60 e0       	ldi	r22, 0x00	; 0
    289e:	0e 94 31 13 	call	0x2662	; 0x2662 <enc28j60SPIRead>
    28a2:	c8 2f       	mov	r28, r24
    28a4:	d0 e0       	ldi	r29, 0x00	; 0
	len |= ((unsigned int)enc28j60SPIRead(ENC28J60_READ_BUF_MEM, 0))<<8;
    28a6:	8a e3       	ldi	r24, 0x3A	; 58
    28a8:	60 e0       	ldi	r22, 0x00	; 0
    28aa:	0e 94 31 13 	call	0x2662	; 0x2662 <enc28j60SPIRead>
    28ae:	38 2f       	mov	r19, r24
    28b0:	20 e0       	ldi	r18, 0x00	; 0
    28b2:	c2 2b       	or	r28, r18
    28b4:	d3 2b       	or	r29, r19
	rxstat  = enc28j60SPIRead(ENC28J60_READ_BUF_MEM, 0);
    28b6:	8a e3       	ldi	r24, 0x3A	; 58
    28b8:	60 e0       	ldi	r22, 0x00	; 0
    28ba:	0e 94 31 13 	call	0x2662	; 0x2662 <enc28j60SPIRead>
	rxstat |= ((unsigned int)enc28j60SPIRead(ENC28J60_READ_BUF_MEM, 0))<<8;
    28be:	8a e3       	ldi	r24, 0x3A	; 58
    28c0:	60 e0       	ldi	r22, 0x00	; 0
    28c2:	0e 94 31 13 	call	0x2662	; 0x2662 <enc28j60SPIRead>
	len = ((len<maxlen)?(len):(maxlen));
    28c6:	0c 17       	cp	r16, r28
    28c8:	1d 07       	cpc	r17, r29
    28ca:	08 f4       	brcc	.+2      	; 0x28ce <enc28j60PacketReceive+0x94>
    28cc:	e8 01       	movw	r28, r16
	enc28j60ReadBuffer(len, packet);
    28ce:	ce 01       	movw	r24, r28
    28d0:	b7 01       	movw	r22, r14
    28d2:	0e 94 77 13 	call	0x26ee	; 0x26ee <enc28j60ReadBuffer>
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
    28d6:	8c e0       	ldi	r24, 0x0C	; 12
    28d8:	60 91 fa 00 	lds	r22, 0x00FA
    28dc:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
    28e0:	60 91 fb 00 	lds	r22, 0x00FB
    28e4:	8d e0       	ldi	r24, 0x0D	; 13
    28e6:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60SPIWrite(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
    28ea:	80 e8       	ldi	r24, 0x80	; 128
    28ec:	6e e1       	ldi	r22, 0x1E	; 30
    28ee:	40 e4       	ldi	r20, 0x40	; 64
    28f0:	0e 94 43 13 	call	0x2686	; 0x2686 <enc28j60SPIWrite>

	return len;
    28f4:	02 c0       	rjmp	.+4      	; 0x28fa <enc28j60PacketReceive+0xc0>
unsigned int enc28j60PacketReceive(unsigned int maxlen, unsigned char* packet)
{
	unsigned int rxstat;
	unsigned int len;
	if( !enc28j60Read(EPKTCNT) )
		return 0;
    28f6:	c0 e0       	ldi	r28, 0x00	; 0
    28f8:	d0 e0       	ldi	r29, 0x00	; 0
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
	enc28j60SPIWrite(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);

	return len;
}
    28fa:	7e 01       	movw	r14, r28
    28fc:	8c 2f       	mov	r24, r28
    28fe:	9f 2d       	mov	r25, r15
    2900:	df 91       	pop	r29
    2902:	cf 91       	pop	r28
    2904:	1f 91       	pop	r17
    2906:	0f 91       	pop	r16
    2908:	ff 90       	pop	r15
    290a:	ef 90       	pop	r14
    290c:	08 95       	ret

0000290e <delay_us>:
void delay_us(unsigned short time_us) 
{
	unsigned short delay_loops;
	register unsigned short i;

	delay_loops = (time_us+3)/5*CYCLES_PER_US; // +3 for rounding up (dirty) 
    290e:	03 96       	adiw	r24, 0x03	; 3
    2910:	65 e0       	ldi	r22, 0x05	; 5
    2912:	70 e0       	ldi	r23, 0x00	; 0
    2914:	0e 94 8c 2c 	call	0x5918	; 0x5918 <__udivmodhi4>
    2918:	66 0f       	add	r22, r22
    291a:	77 1f       	adc	r23, r23
    291c:	66 0f       	add	r22, r22
    291e:	77 1f       	adc	r23, r23
    2920:	66 0f       	add	r22, r22
    2922:	77 1f       	adc	r23, r23

	// one loop takes 5 cpu cycles 
	for (i=0; i < delay_loops; i++) {};
    2924:	61 15       	cp	r22, r1
    2926:	71 05       	cpc	r23, r1
    2928:	31 f0       	breq	.+12     	; 0x2936 <delay_us+0x28>
    292a:	80 e0       	ldi	r24, 0x00	; 0
    292c:	90 e0       	ldi	r25, 0x00	; 0
    292e:	01 96       	adiw	r24, 0x01	; 1
    2930:	86 17       	cp	r24, r22
    2932:	97 07       	cpc	r25, r23
    2934:	e0 f3       	brcs	.-8      	; 0x292e <delay_us+0x20>
    2936:	08 95       	ret

00002938 <enc28j60Init>:
}

void enc28j60Init(void)
{
    2938:	cf 93       	push	r28
    293a:	df 93       	push	r29
	unsigned char i;
	unsigned int timeout=0;
	Enc28j60Bank = 0xFF;
    293c:	8f ef       	ldi	r24, 0xFF	; 255
    293e:	80 93 fc 00 	sts	0x00FC, r24
	ENC28J60_CONTROL_DDR |= (1<<ENC28J60_CONTROL_CS);
    2942:	bb 9a       	sbi	0x17, 3	; 23
	ENC28J60_CS_HI();
    2944:	c3 9a       	sbi	0x18, 3	; 24
	ENC28J60_SPI_PORT |= (1<<ENC28J60_SPI_SCK); //sck = hi
    2946:	c7 9a       	sbi	0x18, 7	; 24
	ENC28J60_SPI_DDR |= (1<<ENC28J60_SPI_SS)|(1<<ENC28J60_SPI_MOSI)|(1<<ENC28J60_SPI_SCK); //SS,MOSI,SCK = OUT
    2948:	87 b3       	in	r24, 0x17	; 23
    294a:	80 6b       	ori	r24, 0xB0	; 176
    294c:	87 bb       	out	0x17, r24	; 23
	ENC28J60_SPI_DDR &= ~(1<<ENC28J60_SPI_MISO); //MISO = IN
    294e:	be 98       	cbi	0x17, 6	; 23
	SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(0<<SPR1)|(0<<SPR0);
    2950:	80 e5       	ldi	r24, 0x50	; 80
    2952:	8d b9       	out	0x0d, r24	; 13
//	SPSR = (1<<SPI2X);
	SPSR = (0<<SPI2X);
    2954:	1e b8       	out	0x0e, r1	; 14
	delay_us(65000);delay_us(65000);delay_us(65000);
	enc28j60SPIWrite(ENC28J60_SOFT_RESET,0, ENC28J60_SOFT_RESET);
    2956:	8f ef       	ldi	r24, 0xFF	; 255
    2958:	60 e0       	ldi	r22, 0x00	; 0
    295a:	4f ef       	ldi	r20, 0xFF	; 255
    295c:	0e 94 43 13 	call	0x2686	; 0x2686 <enc28j60SPIWrite>
	delay_us(65000);delay_us(65000);delay_us(65000);
	while((!(enc28j60Read(ESTAT) & 0x01)) && (timeout<65000)){timeout++;};
    2960:	c9 ee       	ldi	r28, 0xE9	; 233
    2962:	dd ef       	ldi	r29, 0xFD	; 253
    2964:	8d e1       	ldi	r24, 0x1D	; 29
    2966:	0e 94 99 13 	call	0x2732	; 0x2732 <enc28j60Read>
    296a:	80 fd       	sbrc	r24, 0
    296c:	02 c0       	rjmp	.+4      	; 0x2972 <enc28j60Init+0x3a>
    296e:	21 97       	sbiw	r28, 0x01	; 1
    2970:	c9 f7       	brne	.-14     	; 0x2964 <enc28j60Init+0x2c>
	if(timeout>=65000){timeout=0;}
	NextPacketPtr = RXSTART_INIT;
    2972:	80 e0       	ldi	r24, 0x00	; 0
    2974:	96 e0       	ldi	r25, 0x06	; 6
    2976:	90 93 fb 00 	sts	0x00FB, r25
    297a:	80 93 fa 00 	sts	0x00FA, r24
    297e:	c1 e0       	ldi	r28, 0x01	; 1
    2980:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<2*22; i+=2){
		enc28j60Write(pgm_read_byte(&enc28j60_config[i+0]),pgm_read_byte(&enc28j60_config[i+1]));
    2982:	fe 01       	movw	r30, r28
    2984:	e8 54       	subi	r30, 0x48	; 72
    2986:	fe 4f       	sbci	r31, 0xFE	; 254
    2988:	84 91       	lpm	r24, Z+
    298a:	fe 01       	movw	r30, r28
    298c:	e7 54       	subi	r30, 0x47	; 71
    298e:	fe 4f       	sbci	r31, 0xFE	; 254
    2990:	64 91       	lpm	r22, Z+
    2992:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
    2996:	22 96       	adiw	r28, 0x02	; 2
	enc28j60SPIWrite(ENC28J60_SOFT_RESET,0, ENC28J60_SOFT_RESET);
	delay_us(65000);delay_us(65000);delay_us(65000);
	while((!(enc28j60Read(ESTAT) & 0x01)) && (timeout<65000)){timeout++;};
	if(timeout>=65000){timeout=0;}
	NextPacketPtr = RXSTART_INIT;
	for(i=0; i<2*22; i+=2){
    2998:	cd 32       	cpi	r28, 0x2D	; 45
    299a:	d1 05       	cpc	r29, r1
    299c:	91 f7       	brne	.-28     	; 0x2982 <enc28j60Init+0x4a>
		enc28j60Write(pgm_read_byte(&enc28j60_config[i+0]),pgm_read_byte(&enc28j60_config[i+1]));
	}
	enc28j60PhyWrite(PHCON2, PHCON2_HDLDIS); //=no loopback of transmitted frames
    299e:	80 e1       	ldi	r24, 0x10	; 16
    29a0:	60 e0       	ldi	r22, 0x00	; 0
    29a2:	71 e0       	ldi	r23, 0x01	; 1
    29a4:	0e 94 d9 13 	call	0x27b2	; 0x27b2 <enc28j60PhyWrite>
	enc28j60SPIWrite(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
    29a8:	80 e8       	ldi	r24, 0x80	; 128
    29aa:	6b e1       	ldi	r22, 0x1B	; 27
    29ac:	40 ec       	ldi	r20, 0xC0	; 192
    29ae:	0e 94 43 13 	call	0x2686	; 0x2686 <enc28j60SPIWrite>
	enc28j60SPIWrite(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
    29b2:	80 e8       	ldi	r24, 0x80	; 128
    29b4:	6f e1       	ldi	r22, 0x1F	; 31
    29b6:	44 e0       	ldi	r20, 0x04	; 4
    29b8:	0e 94 43 13 	call	0x2686	; 0x2686 <enc28j60SPIWrite>
	enc28j60PhyWrite(PHLCON, 0x347A); //cave: Table3-3: reset value is 0x3422, do not modify the reserved "3"!! 
    29bc:	84 e1       	ldi	r24, 0x14	; 20
    29be:	6a e7       	ldi	r22, 0x7A	; 122
    29c0:	74 e3       	ldi	r23, 0x34	; 52
    29c2:	0e 94 d9 13 	call	0x27b2	; 0x27b2 <enc28j60PhyWrite>
}
    29c6:	df 91       	pop	r29
    29c8:	cf 91       	pop	r28
    29ca:	08 95       	ret

000029cc <ethInit>:

//----------------------------------------------------------------------------
//Ham khoi tao chip Ethernet
void ethInit(void)
{
	enc28j60Init();
    29cc:	0e 94 9c 14 	call	0x2938	; 0x2938 <enc28j60Init>
	ETH_INT_ENABLE;
    29d0:	8b b7       	in	r24, 0x3b	; 59
    29d2:	80 62       	ori	r24, 0x20	; 32
    29d4:	8b bf       	out	0x3b, r24	; 59
}
    29d6:	08 95       	ret

000029d8 <ethSendFrame>:
//--------------------------------------------------------------------------------------
//Ham goi 1 frame xuong chip ethernet
void ethSendFrame(unsigned int len, unsigned char* packet)
{
	enc28j60PacketSend(len, packet);
    29d8:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <enc28j60PacketSend>
}
    29dc:	08 95       	ret

000029de <ethGetFrame>:
//--------------------------------------------------------------------------------------
//Ham doc 1 frame ethernet tu chip ethernet ve buffer tren RAM cua CPU
unsigned int ethGetFrame(unsigned int maxlen, unsigned char* packet)
{
	return enc28j60PacketReceive(maxlen, packet);
    29de:	0e 94 1d 14 	call	0x283a	; 0x283a <enc28j60PacketReceive>
}
    29e2:	08 95       	ret

000029e4 <ethGetMacAddress>:
//--------------------------------------------------------------------------------------
//Ham doc dia chi MAC hien tai tu chip ethernet, luu vao buffer macaddr[6]
void ethGetMacAddress(unsigned char* macaddr)
{
    29e4:	ef 92       	push	r14
    29e6:	ff 92       	push	r15
    29e8:	0f 93       	push	r16
    29ea:	1f 93       	push	r17
    29ec:	cf 93       	push	r28
    29ee:	df 93       	push	r29
    29f0:	8c 01       	movw	r16, r24
	*macaddr++ = enc28j60Read(MAADR5);
    29f2:	84 ee       	ldi	r24, 0xE4	; 228
    29f4:	0e 94 99 13 	call	0x2732	; 0x2732 <enc28j60Read>
    29f8:	e8 01       	movw	r28, r16
    29fa:	89 93       	st	Y+, r24
	*macaddr++ = enc28j60Read(MAADR4);
    29fc:	85 ee       	ldi	r24, 0xE5	; 229
    29fe:	0e 94 99 13 	call	0x2732	; 0x2732 <enc28j60Read>
    2a02:	f8 01       	movw	r30, r16
    2a04:	81 83       	std	Z+1, r24	; 0x01
    2a06:	8e 01       	movw	r16, r28
    2a08:	0f 5f       	subi	r16, 0xFF	; 255
    2a0a:	1f 4f       	sbci	r17, 0xFF	; 255
	*macaddr++ = enc28j60Read(MAADR3);
    2a0c:	82 ee       	ldi	r24, 0xE2	; 226
    2a0e:	0e 94 99 13 	call	0x2732	; 0x2732 <enc28j60Read>
    2a12:	89 83       	std	Y+1, r24	; 0x01
    2a14:	78 01       	movw	r14, r16
    2a16:	08 94       	sec
    2a18:	e1 1c       	adc	r14, r1
    2a1a:	f1 1c       	adc	r15, r1
	*macaddr++ = enc28j60Read(MAADR2);
    2a1c:	83 ee       	ldi	r24, 0xE3	; 227
    2a1e:	0e 94 99 13 	call	0x2732	; 0x2732 <enc28j60Read>
    2a22:	f8 01       	movw	r30, r16
    2a24:	81 83       	std	Z+1, r24	; 0x01
    2a26:	e7 01       	movw	r28, r14
    2a28:	21 96       	adiw	r28, 0x01	; 1
	*macaddr++ = enc28j60Read(MAADR1);
    2a2a:	80 ee       	ldi	r24, 0xE0	; 224
    2a2c:	0e 94 99 13 	call	0x2732	; 0x2732 <enc28j60Read>
    2a30:	f7 01       	movw	r30, r14
    2a32:	81 83       	std	Z+1, r24	; 0x01
	*macaddr++ = enc28j60Read(MAADR0);
    2a34:	81 ee       	ldi	r24, 0xE1	; 225
    2a36:	0e 94 99 13 	call	0x2732	; 0x2732 <enc28j60Read>
    2a3a:	89 83       	std	Y+1, r24	; 0x01
}
    2a3c:	df 91       	pop	r29
    2a3e:	cf 91       	pop	r28
    2a40:	1f 91       	pop	r17
    2a42:	0f 91       	pop	r16
    2a44:	ff 90       	pop	r15
    2a46:	ef 90       	pop	r14
    2a48:	08 95       	ret

00002a4a <ethSetMacAddress>:
//--------------------------------------------------------------------------------------
//Ham set dia chi MAC (dang luu trong buffer macaddr[6] xuong chip ethernet
void ethSetMacAddress(unsigned char* macaddr)
{
    2a4a:	cf 92       	push	r12
    2a4c:	df 92       	push	r13
    2a4e:	ef 92       	push	r14
    2a50:	ff 92       	push	r15
    2a52:	0f 93       	push	r16
    2a54:	1f 93       	push	r17
    2a56:	cf 93       	push	r28
    2a58:	df 93       	push	r29
    2a5a:	ec 01       	movw	r28, r24
	enc28j60Write(MAADR5, *macaddr++);
    2a5c:	8c 01       	movw	r16, r24
    2a5e:	0f 5f       	subi	r16, 0xFF	; 255
    2a60:	1f 4f       	sbci	r17, 0xFF	; 255
    2a62:	84 ee       	ldi	r24, 0xE4	; 228
    2a64:	68 81       	ld	r22, Y
    2a66:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60Write(MAADR4, *macaddr++);
    2a6a:	68 01       	movw	r12, r16
    2a6c:	08 94       	sec
    2a6e:	c1 1c       	adc	r12, r1
    2a70:	d1 1c       	adc	r13, r1
    2a72:	85 ee       	ldi	r24, 0xE5	; 229
    2a74:	69 81       	ldd	r22, Y+1	; 0x01
    2a76:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60Write(MAADR3, *macaddr++);
    2a7a:	76 01       	movw	r14, r12
    2a7c:	08 94       	sec
    2a7e:	e1 1c       	adc	r14, r1
    2a80:	f1 1c       	adc	r15, r1
    2a82:	82 ee       	ldi	r24, 0xE2	; 226
    2a84:	f8 01       	movw	r30, r16
    2a86:	61 81       	ldd	r22, Z+1	; 0x01
    2a88:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60Write(MAADR2, *macaddr++);
    2a8c:	e7 01       	movw	r28, r14
    2a8e:	21 96       	adiw	r28, 0x01	; 1
    2a90:	83 ee       	ldi	r24, 0xE3	; 227
    2a92:	f6 01       	movw	r30, r12
    2a94:	61 81       	ldd	r22, Z+1	; 0x01
    2a96:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60Write(MAADR1, *macaddr++);
    2a9a:	80 ee       	ldi	r24, 0xE0	; 224
    2a9c:	f7 01       	movw	r30, r14
    2a9e:	61 81       	ldd	r22, Z+1	; 0x01
    2aa0:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
	enc28j60Write(MAADR0, *macaddr++);
    2aa4:	81 ee       	ldi	r24, 0xE1	; 225
    2aa6:	69 81       	ldd	r22, Y+1	; 0x01
    2aa8:	0e 94 a3 13 	call	0x2746	; 0x2746 <enc28j60Write>
}
    2aac:	df 91       	pop	r29
    2aae:	cf 91       	pop	r28
    2ab0:	1f 91       	pop	r17
    2ab2:	0f 91       	pop	r16
    2ab4:	ff 90       	pop	r15
    2ab6:	ef 90       	pop	r14
    2ab8:	df 90       	pop	r13
    2aba:	cf 90       	pop	r12
    2abc:	08 95       	ret

00002abe <ethGetBuffer>:
//--------------------------------------------------------------------------------------
//Ham tra lai con tro den buffer ethernet (tren RAM cua CPU)
unsigned char* ethGetBuffer(void)
{
	return ethBuffer;
}
    2abe:	8f ef       	ldi	r24, 0xFF	; 255
    2ac0:	90 e0       	ldi	r25, 0x00	; 0
    2ac2:	08 95       	ret

00002ac4 <__vector_3>:
//--------------------------------------------------------------------------------------
//Vector ngat cua ethernet, mot ngat ngoai se duoc khoi tao boi chip ethernet
// moi khi no nhan duoc 1 frame ethernet (dung dia chi cua no)
ISR (ETH_INTERRUPT)
{
    2ac4:	1f 92       	push	r1
    2ac6:	0f 92       	push	r0
    2ac8:	0f b6       	in	r0, 0x3f	; 63
    2aca:	0f 92       	push	r0
    2acc:	11 24       	eor	r1, r1
    2ace:	8f 93       	push	r24
	eth_got_frame = 1;
    2ad0:	81 e0       	ldi	r24, 0x01	; 1
    2ad2:	80 93 80 00 	sts	0x0080, r24
    time_watchdog = 0;
    2ad6:	10 92 fe 00 	sts	0x00FE, r1
    2ada:	10 92 fd 00 	sts	0x00FD, r1
	ETH_INT_DISABLE;
    2ade:	8b b7       	in	r24, 0x3b	; 59
    2ae0:	8f 7d       	andi	r24, 0xDF	; 223
    2ae2:	8b bf       	out	0x3b, r24	; 59
}
    2ae4:	8f 91       	pop	r24
    2ae6:	0f 90       	pop	r0
    2ae8:	0f be       	out	0x3f, r0	; 63
    2aea:	0f 90       	pop	r0
    2aec:	1f 90       	pop	r1
    2aee:	18 95       	reti

00002af0 <ethService>:
//--------------------------------------------------------------------------------------
//Ham duoc goi lien tuc de thuc thi cac tac vu cua giao thuc ethernet
void ethService(void)
{
    2af0:	0f 93       	push	r16
    2af2:	1f 93       	push	r17
    2af4:	cf 93       	push	r28
    2af6:	df 93       	push	r29
	int len;
	struct ntEthHeader* ethPacket;
	if(!eth_got_frame) return;
    2af8:	80 91 80 00 	lds	r24, 0x0080
    2afc:	88 23       	and	r24, r24
    2afe:	69 f1       	breq	.+90     	; 0x2b5a <ethService+0x6a>
	// look for a packet
	len = ethGetFrame(ETHERNET_BUFFER_SIZE, ethBuffer);
    2b00:	8e e1       	ldi	r24, 0x1E	; 30
    2b02:	94 e0       	ldi	r25, 0x04	; 4
    2b04:	6f ef       	ldi	r22, 0xFF	; 255
    2b06:	70 e0       	ldi	r23, 0x00	; 0
    2b08:	0e 94 ef 14 	call	0x29de	; 0x29de <ethGetFrame>
    2b0c:	08 2f       	mov	r16, r24
    2b0e:	19 2f       	mov	r17, r25

	if(len)
    2b10:	01 15       	cp	r16, r1
    2b12:	11 05       	cpc	r17, r1
    2b14:	11 f1       	breq	.+68     	; 0x2b5a <ethService+0x6a>

		#ifdef ETH_DEBUG
		printf("Received packet len: %d, type:", len);
		#endif
		
		if(ethPacket->type == HTONS(ETH_TYPE_IP))
    2b16:	20 91 0b 01 	lds	r18, 0x010B
    2b1a:	30 91 0c 01 	lds	r19, 0x010C
    2b1e:	28 30       	cpi	r18, 0x08	; 8
    2b20:	31 05       	cpc	r19, r1
    2b22:	69 f4       	brne	.+26     	; 0x2b3e <ethService+0x4e>
		//Neu day la frame danh cho giao thuc IP
		{
			#ifdef ETH_DEBUG
			printf("IP packet\r\n");
			#endif
			arpIPPacketIn((unsigned char*)&ethBuffer[0]);
    2b24:	cf ef       	ldi	r28, 0xFF	; 255
    2b26:	d0 e0       	ldi	r29, 0x00	; 0
    2b28:	ce 01       	movw	r24, r28
    2b2a:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <arpIPPacketIn>
			IPProcess( len-ETH_HEADER_LEN, (struct ntIPHeader*)&ethBuffer[ETH_HEADER_LEN] );
    2b2e:	be 01       	movw	r22, r28
    2b30:	62 5f       	subi	r22, 0xF2	; 242
    2b32:	7f 4f       	sbci	r23, 0xFF	; 255
    2b34:	c8 01       	movw	r24, r16
    2b36:	0e 97       	sbiw	r24, 0x0e	; 14
    2b38:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <IPProcess>
    2b3c:	0b c0       	rjmp	.+22     	; 0x2b54 <ethService+0x64>
		}
		else if(ethPacket->type == HTONS(ETH_TYPE_ARP))
    2b3e:	46 e0       	ldi	r20, 0x06	; 6
    2b40:	28 30       	cpi	r18, 0x08	; 8
    2b42:	34 07       	cpc	r19, r20
    2b44:	29 f4       	brne	.+10     	; 0x2b50 <ethService+0x60>
		//Neu day la 1 frame cua giao thuc ARP
		{
			#ifdef ETH_DEBUG
			printf("ARP packet\r\n");
			#endif
			arpArpProcess(len, ethBuffer );
    2b46:	6f ef       	ldi	r22, 0xFF	; 255
    2b48:	70 e0       	ldi	r23, 0x00	; 0
    2b4a:	0e 94 ac 0a 	call	0x1558	; 0x1558 <arpArpProcess>
    2b4e:	02 c0       	rjmp	.+4      	; 0x2b54 <ethService+0x64>
		}else{
			#ifdef ETH_DEBUG
			printf("Unknown packet:%x\r\n",ethPacket->type);
			#endif
			ethInit();
    2b50:	0e 94 e6 14 	call	0x29cc	; 0x29cc <ethInit>
		}
		ETH_INT_ENABLE;
    2b54:	8b b7       	in	r24, 0x3b	; 59
    2b56:	80 62       	ori	r24, 0x20	; 32
    2b58:	8b bf       	out	0x3b, r24	; 59
	}
	return;
}
    2b5a:	df 91       	pop	r29
    2b5c:	cf 91       	pop	r28
    2b5e:	1f 91       	pop	r17
    2b60:	0f 91       	pop	r16
    2b62:	08 95       	ret

00002b64 <decode_base64>:
unsigned char http_auth_password[20];
//----------------------------------------------------------------------------
PROGMEM char BASE64CODE[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
//
void decode_base64 (unsigned char *str1_in,unsigned char *str2_out)
{
    2b64:	0f 93       	push	r16
    2b66:	1f 93       	push	r17
    2b68:	cf 93       	push	r28
    2b6a:	df 93       	push	r29
    2b6c:	fc 01       	movw	r30, r24
	unsigned char *strp;
    unsigned char end_byte = 0;
	
	strp = str2_out;
	
	while (*str1_in != 0)
    2b6e:	80 81       	ld	r24, Z
    2b70:	88 23       	and	r24, r24
    2b72:	09 f4       	brne	.+2      	; 0x2b76 <decode_base64+0x12>
    2b74:	7d c0       	rjmp	.+250    	; 0x2c70 <decode_base64+0x10c>
	{
		*str2_out++= (*str1_in & 0xFC)>>2;
    2b76:	28 2f       	mov	r18, r24
    2b78:	26 95       	lsr	r18
    2b7a:	26 95       	lsr	r18
    2b7c:	db 01       	movw	r26, r22
    2b7e:	2d 93       	st	X+, r18
    2b80:	cd 01       	movw	r24, r26
		
		*str2_out = (((*str1_in++)&0x03)<<4); 
    2b82:	10 81       	ld	r17, Z
    2b84:	13 70       	andi	r17, 0x03	; 3
    2b86:	12 95       	swap	r17
    2b88:	10 7f       	andi	r17, 0xF0	; 240
    2b8a:	eb 01       	movw	r28, r22
    2b8c:	19 83       	std	Y+1, r17	; 0x01
		if (*str1_in==0)
    2b8e:	21 81       	ldd	r18, Z+1	; 0x01
    2b90:	22 23       	and	r18, r18
    2b92:	b9 f4       	brne	.+46     	; 0x2bc2 <decode_base64+0x5e>
    2b94:	12 c0       	rjmp	.+36     	; 0x2bba <decode_base64+0x56>
	
	strp = str2_out;
	
	while (*str1_in != 0)
	{
		*str2_out++= (*str1_in & 0xFC)>>2;
    2b96:	16 95       	lsr	r17
    2b98:	16 95       	lsr	r17
    2b9a:	13 96       	adiw	r26, 0x03	; 3
    2b9c:	1c 93       	st	X, r17
//
unsigned char http_auth_password[20];
//----------------------------------------------------------------------------
PROGMEM char BASE64CODE[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
//
void decode_base64 (unsigned char *str1_in,unsigned char *str2_out)
    2b9e:	d9 01       	movw	r26, r18
    2ba0:	14 96       	adiw	r26, 0x04	; 4
	
	while (*str1_in != 0)
	{
		*str2_out++= (*str1_in & 0xFC)>>2;
		
		*str2_out = (((*str1_in++)&0x03)<<4); 
    2ba2:	ea 01       	movw	r28, r20
    2ba4:	1b 81       	ldd	r17, Y+3	; 0x03
    2ba6:	13 70       	andi	r17, 0x03	; 3
    2ba8:	12 95       	swap	r17
    2baa:	10 7f       	andi	r17, 0xF0	; 240
    2bac:	e9 01       	movw	r28, r18
    2bae:	1c 83       	std	Y+4, r17	; 0x04
		if (*str1_in==0)
    2bb0:	ea 01       	movw	r28, r20
    2bb2:	2c 81       	ldd	r18, Y+4	; 0x04
    2bb4:	33 96       	adiw	r30, 0x03	; 3
    2bb6:	22 23       	and	r18, r18
    2bb8:	21 f4       	brne	.+8      	; 0x2bc2 <decode_base64+0x5e>
		{
			str2_out++;
    2bba:	ed 01       	movw	r28, r26
    2bbc:	21 96       	adiw	r28, 0x01	; 1
            end_byte = 2;
    2bbe:	22 e0       	ldi	r18, 0x02	; 2
			break;
    2bc0:	28 c0       	rjmp	.+80     	; 0x2c12 <decode_base64+0xae>
		}
		else
		{
			*str2_out++ += ((*str1_in & 0xF0)>>4);
    2bc2:	22 95       	swap	r18
    2bc4:	2f 70       	andi	r18, 0x0F	; 15
    2bc6:	12 0f       	add	r17, r18
    2bc8:	1c 93       	st	X, r17
//
unsigned char http_auth_password[20];
//----------------------------------------------------------------------------
PROGMEM char BASE64CODE[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
//
void decode_base64 (unsigned char *str1_in,unsigned char *str2_out)
    2bca:	9d 01       	movw	r18, r26
    2bcc:	ed 01       	movw	r28, r26
    2bce:	21 96       	adiw	r28, 0x01	; 1
    2bd0:	af 01       	movw	r20, r30
			break;
		}
		else
		{
			*str2_out++ += ((*str1_in & 0xF0)>>4);
			*str2_out = (((*str1_in++)& 0x0F)<<2);
    2bd2:	11 81       	ldd	r17, Z+1	; 0x01
    2bd4:	1f 70       	andi	r17, 0x0F	; 15
    2bd6:	11 0f       	add	r17, r17
    2bd8:	11 0f       	add	r17, r17
    2bda:	11 96       	adiw	r26, 0x01	; 1
    2bdc:	1c 93       	st	X, r17
    2bde:	11 97       	sbiw	r26, 0x01	; 1
			if (*str1_in==0)
    2be0:	02 81       	ldd	r16, Z+2	; 0x02
    2be2:	00 23       	and	r16, r16
    2be4:	19 f4       	brne	.+6      	; 0x2bec <decode_base64+0x88>
			{
				str2_out++;
    2be6:	21 96       	adiw	r28, 0x01	; 1
                end_byte = 1;
    2be8:	21 e0       	ldi	r18, 0x01	; 1
                break;
    2bea:	13 c0       	rjmp	.+38     	; 0x2c12 <decode_base64+0xae>
			}
			else
			{
				*str2_out++	+= ((*str1_in & 0xC0)>>6);
    2bec:	02 95       	swap	r16
    2bee:	06 95       	lsr	r16
    2bf0:	06 95       	lsr	r16
    2bf2:	03 70       	andi	r16, 0x03	; 3
    2bf4:	10 0f       	add	r17, r16
    2bf6:	11 96       	adiw	r26, 0x01	; 1
    2bf8:	1c 93       	st	X, r17
    2bfa:	11 97       	sbiw	r26, 0x01	; 1
				*str2_out++= *str1_in++ & 0x3F;
    2bfc:	12 81       	ldd	r17, Z+2	; 0x02
    2bfe:	1f 73       	andi	r17, 0x3F	; 63
    2c00:	12 96       	adiw	r26, 0x02	; 2
    2c02:	1c 93       	st	X, r17
    2c04:	12 97       	sbiw	r26, 0x02	; 2
//
unsigned char http_auth_password[20];
//----------------------------------------------------------------------------
PROGMEM char BASE64CODE[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
//
void decode_base64 (unsigned char *str1_in,unsigned char *str2_out)
    2c06:	ed 01       	movw	r28, r26
    2c08:	23 96       	adiw	r28, 0x03	; 3
	unsigned char *strp;
    unsigned char end_byte = 0;
	
	strp = str2_out;
	
	while (*str1_in != 0)
    2c0a:	13 81       	ldd	r17, Z+3	; 0x03
    2c0c:	11 23       	and	r17, r17
    2c0e:	19 f6       	brne	.-122    	; 0x2b96 <decode_base64+0x32>
PROGMEM char BASE64CODE[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
//
void decode_base64 (unsigned char *str1_in,unsigned char *str2_out)
{
	unsigned char *strp;
    unsigned char end_byte = 0;
    2c10:	20 e0       	ldi	r18, 0x00	; 0
				*str2_out++	+= ((*str1_in & 0xC0)>>6);
				*str2_out++= *str1_in++ & 0x3F;
			}
		}
	}
	*str2_out = 0;
    2c12:	18 82       	st	Y, r1
    
	while(strp != str2_out)
    2c14:	c6 17       	cp	r28, r22
    2c16:	d7 07       	cpc	r29, r23
    2c18:	91 f0       	breq	.+36     	; 0x2c3e <decode_base64+0xda>
void decode_base64 (unsigned char *str1_in,unsigned char *str2_out)
{
	unsigned char *strp;
    unsigned char end_byte = 0;
	
	strp = str2_out;
    2c1a:	db 01       	movw	r26, r22
	}
	*str2_out = 0;
    
	while(strp != str2_out)
	{
			*strp = pgm_read_byte(&BASE64CODE[(*strp) & 0x3F]);
    2c1c:	ec 91       	ld	r30, X
    2c1e:	f0 e0       	ldi	r31, 0x00	; 0
    2c20:	ef 73       	andi	r30, 0x3F	; 63
    2c22:	f0 70       	andi	r31, 0x00	; 0
    2c24:	ed 54       	subi	r30, 0x4D	; 77
    2c26:	fe 4e       	sbci	r31, 0xEE	; 238
    2c28:	e4 91       	lpm	r30, Z+
    2c2a:	ed 93       	st	X+, r30
			}
		}
	}
	*str2_out = 0;
    
	while(strp != str2_out)
    2c2c:	ca 17       	cp	r28, r26
    2c2e:	db 07       	cpc	r29, r27
    2c30:	a9 f7       	brne	.-22     	; 0x2c1c <decode_base64+0xb8>
//
unsigned char http_auth_password[20];
//----------------------------------------------------------------------------
PROGMEM char BASE64CODE[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
//
void decode_base64 (unsigned char *str1_in,unsigned char *str2_out)
    2c32:	c8 1b       	sub	r28, r24
    2c34:	d9 0b       	sbc	r29, r25
    2c36:	21 96       	adiw	r28, 0x01	; 1
			}
		}
	}
	*str2_out = 0;
    
	while(strp != str2_out)
    2c38:	c6 0f       	add	r28, r22
    2c3a:	d7 1f       	adc	r29, r23
    2c3c:	01 c0       	rjmp	.+2      	; 0x2c40 <decode_base64+0xdc>
void decode_base64 (unsigned char *str1_in,unsigned char *str2_out)
{
	unsigned char *strp;
    unsigned char end_byte = 0;
	
	strp = str2_out;
    2c3e:	eb 01       	movw	r28, r22
	{
			*strp = pgm_read_byte(&BASE64CODE[(*strp) & 0x3F]);
			strp++;
	}
 
    while (end_byte--)
    2c40:	22 23       	and	r18, r18
    2c42:	81 f0       	breq	.+32     	; 0x2c64 <decode_base64+0x100>
    2c44:	21 50       	subi	r18, 0x01	; 1
//
unsigned char http_auth_password[20];
//----------------------------------------------------------------------------
PROGMEM char BASE64CODE[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
//
void decode_base64 (unsigned char *str1_in,unsigned char *str2_out)
    2c46:	30 e0       	ldi	r19, 0x00	; 0
    2c48:	ce 01       	movw	r24, r28
    2c4a:	01 96       	adiw	r24, 0x01	; 1
    2c4c:	82 0f       	add	r24, r18
    2c4e:	93 1f       	adc	r25, r19
    2c50:	fe 01       	movw	r30, r28
			strp++;
	}
 
    while (end_byte--)
    {
        *strp = '=';
    2c52:	4d e3       	ldi	r20, 0x3D	; 61
    2c54:	41 93       	st	Z+, r20
	{
			*strp = pgm_read_byte(&BASE64CODE[(*strp) & 0x3F]);
			strp++;
	}
 
    while (end_byte--)
    2c56:	e8 17       	cp	r30, r24
    2c58:	f9 07       	cpc	r31, r25
    2c5a:	e1 f7       	brne	.-8      	; 0x2c54 <decode_base64+0xf0>
//
unsigned char http_auth_password[20];
//----------------------------------------------------------------------------
PROGMEM char BASE64CODE[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
//
void decode_base64 (unsigned char *str1_in,unsigned char *str2_out)
    2c5c:	2f 5f       	subi	r18, 0xFF	; 255
    2c5e:	3f 4f       	sbci	r19, 0xFF	; 255
	{
			*strp = pgm_read_byte(&BASE64CODE[(*strp) & 0x3F]);
			strp++;
	}
 
    while (end_byte--)
    2c60:	c2 0f       	add	r28, r18
    2c62:	d3 1f       	adc	r29, r19
    {
        *strp = '=';
        strp++;
    }
    *strp = 0; 
    2c64:	18 82       	st	Y, r1
}
    2c66:	df 91       	pop	r29
    2c68:	cf 91       	pop	r28
    2c6a:	1f 91       	pop	r17
    2c6c:	0f 91       	pop	r16
    2c6e:	08 95       	ret
				*str2_out++	+= ((*str1_in & 0xC0)>>6);
				*str2_out++= *str1_in++ & 0x3F;
			}
		}
	}
	*str2_out = 0;
    2c70:	fb 01       	movw	r30, r22
    2c72:	10 82       	st	Z, r1
void decode_base64 (unsigned char *str1_in,unsigned char *str2_out)
{
	unsigned char *strp;
    unsigned char end_byte = 0;
	
	strp = str2_out;
    2c74:	eb 01       	movw	r28, r22
    2c76:	f6 cf       	rjmp	.-20     	; 0x2c64 <decode_base64+0x100>

00002c78 <httpInit>:
}
//----------------------------------------------------------------------------
void httpInit()
{
	unsigned char i;
	decode_base64((unsigned char*)HTTP_AUTH_STRING,http_auth_password);
    2c78:	80 e6       	ldi	r24, 0x60	; 96
    2c7a:	90 e0       	ldi	r25, 0x00	; 0
    2c7c:	65 ec       	ldi	r22, 0xC5	; 197
    2c7e:	75 e0       	ldi	r23, 0x05	; 5
    2c80:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <decode_base64>
	for(i=0; i < MAX_HTTP_SESSION; i++){
		httpSessionTable[i].status = HTTP_STATUS_IDLE;
    2c84:	10 92 1d 05 	sts	0x051D, r1
    2c88:	10 92 32 05 	sts	0x0532, r1
    2c8c:	10 92 47 05 	sts	0x0547, r1
    2c90:	10 92 5c 05 	sts	0x055C, r1
    2c94:	10 92 71 05 	sts	0x0571, r1
    2c98:	10 92 86 05 	sts	0x0586, r1
    2c9c:	10 92 9b 05 	sts	0x059B, r1
    2ca0:	10 92 b0 05 	sts	0x05B0, r1
	}
	//UpdateCtrlSts(0x00);
}
    2ca4:	08 95       	ret

00002ca6 <httpGetRequest>:
//----------------------------------------------------------------------------
//Ham xu ly mot request cua giao thuc HTTP
void httpGetRequest(unsigned char *buffer,unsigned int bufferLen,struct httpRequest* rqst)
{
    2ca6:	cf 93       	push	r28
    2ca8:	df 93       	push	r29
    2caa:	fc 01       	movw	r30, r24
    2cac:	ea 01       	movw	r28, r20
	unsigned int i;
	if((buffer[0] == 'G')&&(buffer[1] == 'E')&&(buffer[2] == 'T')){
    2cae:	80 81       	ld	r24, Z
    2cb0:	87 34       	cpi	r24, 0x47	; 71
    2cb2:	49 f4       	brne	.+18     	; 0x2cc6 <httpGetRequest+0x20>
    2cb4:	91 81       	ldd	r25, Z+1	; 0x01
    2cb6:	95 34       	cpi	r25, 0x45	; 69
    2cb8:	31 f4       	brne	.+12     	; 0x2cc6 <httpGetRequest+0x20>
    2cba:	82 81       	ldd	r24, Z+2	; 0x02
    2cbc:	84 35       	cpi	r24, 0x54	; 84
    2cbe:	f9 f4       	brne	.+62     	; 0x2cfe <httpGetRequest+0x58>
	//if(findstr("GET",buffer,3) == 0){
		rqst->method = HTTP_REQUEST_GET;
    2cc0:	81 e0       	ldi	r24, 0x01	; 1
    2cc2:	88 83       	st	Y, r24
    2cc4:	1e c0       	rjmp	.+60     	; 0x2d02 <httpGetRequest+0x5c>
		#ifdef HTTP_DEBUG
		printf("GET\r\n");
		#endif
	}else if((buffer[0] == 'P')&&(buffer[1] == 'O')&&(buffer[2] == 'S')&&(buffer[3] == 'T')){
    2cc6:	80 35       	cpi	r24, 0x50	; 80
    2cc8:	61 f4       	brne	.+24     	; 0x2ce2 <httpGetRequest+0x3c>
    2cca:	81 81       	ldd	r24, Z+1	; 0x01
    2ccc:	8f 34       	cpi	r24, 0x4F	; 79
    2cce:	b9 f4       	brne	.+46     	; 0x2cfe <httpGetRequest+0x58>
    2cd0:	82 81       	ldd	r24, Z+2	; 0x02
    2cd2:	83 35       	cpi	r24, 0x53	; 83
    2cd4:	a1 f4       	brne	.+40     	; 0x2cfe <httpGetRequest+0x58>
    2cd6:	83 81       	ldd	r24, Z+3	; 0x03
    2cd8:	84 35       	cpi	r24, 0x54	; 84
    2cda:	89 f4       	brne	.+34     	; 0x2cfe <httpGetRequest+0x58>
	//}else if(findstr("POST",buffer,4) == 0){
		rqst->method = HTTP_REQUEST_POST;
    2cdc:	82 e0       	ldi	r24, 0x02	; 2
    2cde:	88 83       	st	Y, r24
    2ce0:	10 c0       	rjmp	.+32     	; 0x2d02 <httpGetRequest+0x5c>
		#ifdef HTTP_DEBUG
		printf("POST\r\n");
		#endif
	}else if((buffer[0] == 'H')&&(buffer[1] == 'E')&&(buffer[2] == 'A')&&(buffer[3] == 'D')){
    2ce2:	88 34       	cpi	r24, 0x48	; 72
    2ce4:	61 f4       	brne	.+24     	; 0x2cfe <httpGetRequest+0x58>
    2ce6:	81 81       	ldd	r24, Z+1	; 0x01
    2ce8:	85 34       	cpi	r24, 0x45	; 69
    2cea:	49 f4       	brne	.+18     	; 0x2cfe <httpGetRequest+0x58>
    2cec:	82 81       	ldd	r24, Z+2	; 0x02
    2cee:	81 34       	cpi	r24, 0x41	; 65
    2cf0:	31 f4       	brne	.+12     	; 0x2cfe <httpGetRequest+0x58>
    2cf2:	83 81       	ldd	r24, Z+3	; 0x03
    2cf4:	84 34       	cpi	r24, 0x44	; 68
    2cf6:	19 f4       	brne	.+6      	; 0x2cfe <httpGetRequest+0x58>
	//}else if(findstr("HEAD",buffer,4) == 0){
		rqst->method = HTTP_REQUEST_HEAD;
    2cf8:	83 e0       	ldi	r24, 0x03	; 3
    2cfa:	88 83       	st	Y, r24
    2cfc:	02 c0       	rjmp	.+4      	; 0x2d02 <httpGetRequest+0x5c>
		#ifdef HTTP_DEBUG
		printf("HEAD\r\n");
		#endif
	}else{
		rqst->method = HTTP_REQUEST_UNKNOWN;
    2cfe:	84 e0       	ldi	r24, 0x04	; 4
    2d00:	88 83       	st	Y, r24
	}
	//UpdateCtrlSts(0x00);
}
//----------------------------------------------------------------------------
//Ham xu ly mot request cua giao thuc HTTP
void httpGetRequest(unsigned char *buffer,unsigned int bufferLen,struct httpRequest* rqst)
    2d02:	df 01       	movw	r26, r30
    2d04:	11 96       	adiw	r26, 0x01	; 1
		#ifdef HTTP_DEBUG
		printf("UNKNOWN\r\n");
		#endif
	}
	//Bat dau tim URI va HTTP version
	i = 0;
    2d06:	80 e0       	ldi	r24, 0x00	; 0
    2d08:	90 e0       	ldi	r25, 0x00	; 0
	while(++i<bufferLen){
    2d0a:	0b c0       	rjmp	.+22     	; 0x2d22 <httpGetRequest+0x7c>
		if(buffer[i] == ' '){	//khoang trang dau tien
    2d0c:	2d 91       	ld	r18, X+
    2d0e:	20 32       	cpi	r18, 0x20	; 32
    2d10:	41 f4       	brne	.+16     	; 0x2d22 <httpGetRequest+0x7c>
			rqst->requestURI = &buffer[i+1];
    2d12:	9c 01       	movw	r18, r24
    2d14:	2f 5f       	subi	r18, 0xFF	; 255
    2d16:	3f 4f       	sbci	r19, 0xFF	; 255
    2d18:	2e 0f       	add	r18, r30
    2d1a:	3f 1f       	adc	r19, r31
    2d1c:	3a 83       	std	Y+2, r19	; 0x02
    2d1e:	29 83       	std	Y+1, r18	; 0x01
			break;
    2d20:	14 c0       	rjmp	.+40     	; 0x2d4a <httpGetRequest+0xa4>
		printf("UNKNOWN\r\n");
		#endif
	}
	//Bat dau tim URI va HTTP version
	i = 0;
	while(++i<bufferLen){
    2d22:	01 96       	adiw	r24, 0x01	; 1
    2d24:	86 17       	cp	r24, r22
    2d26:	97 07       	cpc	r25, r23
    2d28:	88 f3       	brcs	.-30     	; 0x2d0c <httpGetRequest+0x66>
    2d2a:	0f c0       	rjmp	.+30     	; 0x2d4a <httpGetRequest+0xa4>
			rqst->requestURI = &buffer[i+1];
			break;
		}
	}
	while(++i<bufferLen){
		if(buffer[i] == ' '){	//khoang trang dau tien
    2d2c:	2d 91       	ld	r18, X+
    2d2e:	20 32       	cpi	r18, 0x20	; 32
    2d30:	81 f4       	brne	.+32     	; 0x2d52 <httpGetRequest+0xac>
			rqst->version = &buffer[i+1];
    2d32:	9c 01       	movw	r18, r24
    2d34:	2f 5f       	subi	r18, 0xFF	; 255
    2d36:	3f 4f       	sbci	r19, 0xFF	; 255
    2d38:	2e 0f       	add	r18, r30
    2d3a:	3f 1f       	adc	r19, r31
    2d3c:	3c 83       	std	Y+4, r19	; 0x04
    2d3e:	2b 83       	std	Y+3, r18	; 0x03
	}
	//UpdateCtrlSts(0x00);
}
//----------------------------------------------------------------------------
//Ham xu ly mot request cua giao thuc HTTP
void httpGetRequest(unsigned char *buffer,unsigned int bufferLen,struct httpRequest* rqst)
    2d40:	dc 01       	movw	r26, r24
    2d42:	11 96       	adiw	r26, 0x01	; 1
    2d44:	ae 0f       	add	r26, r30
    2d46:	bf 1f       	adc	r27, r31
    2d48:	1b c0       	rjmp	.+54     	; 0x2d80 <httpGetRequest+0xda>
    2d4a:	dc 01       	movw	r26, r24
    2d4c:	11 96       	adiw	r26, 0x01	; 1
    2d4e:	ae 0f       	add	r26, r30
    2d50:	bf 1f       	adc	r27, r31
		if(buffer[i] == ' '){	//khoang trang dau tien
			rqst->requestURI = &buffer[i+1];
			break;
		}
	}
	while(++i<bufferLen){
    2d52:	01 96       	adiw	r24, 0x01	; 1
    2d54:	86 17       	cp	r24, r22
    2d56:	97 07       	cpc	r25, r23
    2d58:	48 f3       	brcs	.-46     	; 0x2d2c <httpGetRequest+0x86>
    2d5a:	f2 cf       	rjmp	.-28     	; 0x2d40 <httpGetRequest+0x9a>
			break;
		}
	}
	//Tim header
	while(++i<bufferLen){
		if((buffer[i] == 0x0d) && (buffer[i+1] == 0x0a)){	//\n\r dau tien, bat dau header
    2d5c:	2d 91       	ld	r18, X+
    2d5e:	2d 30       	cpi	r18, 0x0D	; 13
    2d60:	79 f4       	brne	.+30     	; 0x2d80 <httpGetRequest+0xda>
    2d62:	2c 91       	ld	r18, X
    2d64:	2a 30       	cpi	r18, 0x0A	; 10
    2d66:	61 f4       	brne	.+24     	; 0x2d80 <httpGetRequest+0xda>
			rqst->header = &buffer[i+2];
    2d68:	9c 01       	movw	r18, r24
    2d6a:	2e 5f       	subi	r18, 0xFE	; 254
    2d6c:	3f 4f       	sbci	r19, 0xFF	; 255
    2d6e:	2e 0f       	add	r18, r30
    2d70:	3f 1f       	adc	r19, r31
    2d72:	3e 83       	std	Y+6, r19	; 0x06
    2d74:	2d 83       	std	Y+5, r18	; 0x05
	}
	//UpdateCtrlSts(0x00);
}
//----------------------------------------------------------------------------
//Ham xu ly mot request cua giao thuc HTTP
void httpGetRequest(unsigned char *buffer,unsigned int bufferLen,struct httpRequest* rqst)
    2d76:	dc 01       	movw	r26, r24
    2d78:	11 96       	adiw	r26, 0x01	; 1
    2d7a:	ae 0f       	add	r26, r30
    2d7c:	bf 1f       	adc	r27, r31
    2d7e:	12 c0       	rjmp	.+36     	; 0x2da4 <httpGetRequest+0xfe>
			rqst->version = &buffer[i+1];
			break;
		}
	}
	//Tim header
	while(++i<bufferLen){
    2d80:	01 96       	adiw	r24, 0x01	; 1
    2d82:	86 17       	cp	r24, r22
    2d84:	97 07       	cpc	r25, r23
    2d86:	50 f3       	brcs	.-44     	; 0x2d5c <httpGetRequest+0xb6>
    2d88:	f6 cf       	rjmp	.-20     	; 0x2d76 <httpGetRequest+0xd0>
			break;
		}
	}
	//Tim ket thuc header
	while(++i<bufferLen){
		if((buffer[i] == 0x0d) && (buffer[i+1] == 0x0a) && (buffer[i+2] == 0x0d)){	//\n\r\n\r
    2d8a:	2d 91       	ld	r18, X+
    2d8c:	2d 30       	cpi	r18, 0x0D	; 13
    2d8e:	51 f4       	brne	.+20     	; 0x2da4 <httpGetRequest+0xfe>
    2d90:	2c 91       	ld	r18, X
    2d92:	2a 30       	cpi	r18, 0x0A	; 10
    2d94:	39 f4       	brne	.+14     	; 0x2da4 <httpGetRequest+0xfe>
    2d96:	11 96       	adiw	r26, 0x01	; 1
    2d98:	2c 91       	ld	r18, X
    2d9a:	11 97       	sbiw	r26, 0x01	; 1
    2d9c:	2d 30       	cpi	r18, 0x0D	; 13
    2d9e:	11 f4       	brne	.+4      	; 0x2da4 <httpGetRequest+0xfe>
			i += 4;
    2da0:	04 96       	adiw	r24, 0x04	; 4
			break;
    2da2:	04 c0       	rjmp	.+8      	; 0x2dac <httpGetRequest+0x106>
			rqst->header = &buffer[i+2];
			break;
		}
	}
	//Tim ket thuc header
	while(++i<bufferLen){
    2da4:	01 96       	adiw	r24, 0x01	; 1
    2da6:	86 17       	cp	r24, r22
    2da8:	97 07       	cpc	r25, r23
    2daa:	78 f3       	brcs	.-34     	; 0x2d8a <httpGetRequest+0xe4>
		if((buffer[i] == 0x0d) && (buffer[i+1] == 0x0a) && (buffer[i+2] == 0x0d)){	//\n\r\n\r
			i += 4;
			break;
		}
	}
	rqst->body = &buffer[i];
    2dac:	e8 0f       	add	r30, r24
    2dae:	f9 1f       	adc	r31, r25
    2db0:	f8 87       	std	Y+8, r31	; 0x08
    2db2:	ef 83       	std	Y+7, r30	; 0x07
	rqst->bodyLen = bufferLen - i;
    2db4:	68 1b       	sub	r22, r24
    2db6:	79 0b       	sbc	r23, r25
    2db8:	7a 87       	std	Y+10, r23	; 0x0a
    2dba:	69 87       	std	Y+9, r22	; 0x09
	printf("Header:%d\n\r",(rqst->header - buffer));
	printf("Body:%d\n\r",(unsigned int)(rqst->body - buffer));
	printf("Body:%x-%x\n\r",(unsigned int)(rqst->body),(unsigned int)buffer);
	printf("Body i:%d\n\r",i);
	#endif
}
    2dbc:	df 91       	pop	r29
    2dbe:	cf 91       	pop	r28
    2dc0:	08 95       	ret

00002dc2 <httpHeaderGetField>:
//----------------------------------------------------------------------------
//Ham lay gia tri mot truong trong HTTP Header,
// tra lai con tro vi tri bat dau value cua truong nay
unsigned char * httpHeaderGetField(const prog_char fieldname[],struct httpRequest *rqst)
{
    2dc2:	ff 92       	push	r15
    2dc4:	0f 93       	push	r16
    2dc6:	1f 93       	push	r17
    2dc8:	cf 93       	push	r28
    2dca:	df 93       	push	r29
    2dcc:	fb 01       	movw	r30, r22
	unsigned char *header;
	unsigned int i,j,headerLen;
	header = rqst->header;
    2dce:	05 81       	ldd	r16, Z+5	; 0x05
    2dd0:	16 81       	ldd	r17, Z+6	; 0x06
	headerLen = (rqst->header) - (rqst->body) - 4;
    2dd2:	b8 01       	movw	r22, r16
    2dd4:	64 50       	subi	r22, 0x04	; 4
    2dd6:	70 40       	sbci	r23, 0x00	; 0
    2dd8:	27 81       	ldd	r18, Z+7	; 0x07
    2dda:	30 85       	ldd	r19, Z+8	; 0x08
    2ddc:	62 1b       	sub	r22, r18
    2dde:	73 0b       	sbc	r23, r19
	i=0;
	j=0;
	while(i<headerLen){
    2de0:	29 f1       	breq	.+74     	; 0x2e2c <httpHeaderGetField+0x6a>
    2de2:	d8 01       	movw	r26, r16
	unsigned char *header;
	unsigned int i,j,headerLen;
	header = rqst->header;
	headerLen = (rqst->header) - (rqst->body) - 4;
	i=0;
	j=0;
    2de4:	20 e0       	ldi	r18, 0x00	; 0
    2de6:	30 e0       	ldi	r19, 0x00	; 0
{
	unsigned char *header;
	unsigned int i,j,headerLen;
	header = rqst->header;
	headerLen = (rqst->header) - (rqst->body) - 4;
	i=0;
    2de8:	40 e0       	ldi	r20, 0x00	; 0
    2dea:	50 e0       	ldi	r21, 0x00	; 0
	j=0;
	while(i<headerLen){
		if(header[i++] != pgm_read_byte(fieldname + j++)){
			j = 0;
    2dec:	c0 e0       	ldi	r28, 0x00	; 0
    2dee:	d0 e0       	ldi	r29, 0x00	; 0
	header = rqst->header;
	headerLen = (rqst->header) - (rqst->body) - 4;
	i=0;
	j=0;
	while(i<headerLen){
		if(header[i++] != pgm_read_byte(fieldname + j++)){
    2df0:	fd 90       	ld	r15, X+
    2df2:	fc 01       	movw	r30, r24
    2df4:	e2 0f       	add	r30, r18
    2df6:	f3 1f       	adc	r31, r19
    2df8:	e4 91       	lpm	r30, Z+
    2dfa:	4f 5f       	subi	r20, 0xFF	; 255
    2dfc:	5f 4f       	sbci	r21, 0xFF	; 255
    2dfe:	fe 16       	cp	r15, r30
    2e00:	19 f4       	brne	.+6      	; 0x2e08 <httpHeaderGetField+0x46>
    2e02:	2f 5f       	subi	r18, 0xFF	; 255
    2e04:	3f 4f       	sbci	r19, 0xFF	; 255
    2e06:	01 c0       	rjmp	.+2      	; 0x2e0a <httpHeaderGetField+0x48>
			j = 0;
    2e08:	9e 01       	movw	r18, r28
		}
		if(pgm_read_byte(fieldname + j) == 0){
    2e0a:	fc 01       	movw	r30, r24
    2e0c:	e2 0f       	add	r30, r18
    2e0e:	f3 1f       	adc	r31, r19
    2e10:	e4 91       	lpm	r30, Z+
    2e12:	ee 23       	and	r30, r30
    2e14:	29 f4       	brne	.+10     	; 0x2e20 <httpHeaderGetField+0x5e>
			return(header+i+2);
    2e16:	4e 5f       	subi	r20, 0xFE	; 254
    2e18:	5f 4f       	sbci	r21, 0xFF	; 255
    2e1a:	04 0f       	add	r16, r20
    2e1c:	15 1f       	adc	r17, r21
    2e1e:	08 c0       	rjmp	.+16     	; 0x2e30 <httpHeaderGetField+0x6e>
	unsigned int i,j,headerLen;
	header = rqst->header;
	headerLen = (rqst->header) - (rqst->body) - 4;
	i=0;
	j=0;
	while(i<headerLen){
    2e20:	46 17       	cp	r20, r22
    2e22:	57 07       	cpc	r21, r23
    2e24:	28 f3       	brcs	.-54     	; 0x2df0 <httpHeaderGetField+0x2e>
		}
		if(pgm_read_byte(fieldname + j) == 0){
			return(header+i+2);
		}
	}
	return(0);
    2e26:	00 e0       	ldi	r16, 0x00	; 0
    2e28:	10 e0       	ldi	r17, 0x00	; 0
    2e2a:	02 c0       	rjmp	.+4      	; 0x2e30 <httpHeaderGetField+0x6e>
    2e2c:	00 e0       	ldi	r16, 0x00	; 0
    2e2e:	10 e0       	ldi	r17, 0x00	; 0
}
    2e30:	80 2f       	mov	r24, r16
    2e32:	91 2f       	mov	r25, r17
    2e34:	df 91       	pop	r29
    2e36:	cf 91       	pop	r28
    2e38:	1f 91       	pop	r17
    2e3a:	0f 91       	pop	r16
    2e3c:	ff 90       	pop	r15
    2e3e:	08 95       	ret

00002e40 <HTTPSend>:
//----------------------------------------------------------------------------
//Ham gui mot doan du lieu chua trong bo nho chuong trinh ra theo giao thuc HTTP
void	HTTPSend(const prog_char progdata[],unsigned int dataLen,struct tcpSession *pSession, unsigned char endData)
{
    2e40:	2f 92       	push	r2
    2e42:	3f 92       	push	r3
    2e44:	4f 92       	push	r4
    2e46:	5f 92       	push	r5
    2e48:	6f 92       	push	r6
    2e4a:	7f 92       	push	r7
    2e4c:	8f 92       	push	r8
    2e4e:	9f 92       	push	r9
    2e50:	af 92       	push	r10
    2e52:	bf 92       	push	r11
    2e54:	cf 92       	push	r12
    2e56:	df 92       	push	r13
    2e58:	ef 92       	push	r14
    2e5a:	ff 92       	push	r15
    2e5c:	0f 93       	push	r16
    2e5e:	1f 93       	push	r17
    2e60:	df 93       	push	r29
    2e62:	cf 93       	push	r28
    2e64:	00 d0       	rcall	.+0      	; 0x2e66 <HTTPSend+0x26>
    2e66:	0f 92       	push	r0
    2e68:	cd b7       	in	r28, 0x3d	; 61
    2e6a:	de b7       	in	r29, 0x3e	; 62
    2e6c:	6c 01       	movw	r12, r24
    2e6e:	4b 01       	movw	r8, r22
    2e70:	2a 01       	movw	r4, r20
    2e72:	29 83       	std	Y+1, r18	; 0x01
	unsigned char tmpChr,tmpVar;
	//unsigned char temp_adc;
	Flags = TCP_PSH_FLAG;

	Flags = TCP_PSH_FLAG;
	dataBuffer = ethGetBuffer() + ETH_HEADER_LEN + IP_HEADER_LEN + TCP_HEADER_LEN;
    2e74:	0e 94 5f 15 	call	0x2abe	; 0x2abe <ethGetBuffer>
    2e78:	0f 2e       	mov	r0, r31
    2e7a:	f6 e3       	ldi	r31, 0x36	; 54
    2e7c:	af 2e       	mov	r10, r31
    2e7e:	bb 24       	eor	r11, r11
    2e80:	f0 2d       	mov	r31, r0
    2e82:	a8 0e       	add	r10, r24
    2e84:	b9 1e       	adc	r11, r25
	if(dataLen == 0){
    2e86:	81 14       	cp	r8, r1
    2e88:	91 04       	cpc	r9, r1
    2e8a:	09 f0       	breq	.+2      	; 0x2e8e <HTTPSend+0x4e>
    2e8c:	ea c0       	rjmp	.+468    	; 0x3062 <HTTPSend+0x222>
		Flags |= TCP_ACK_FLAG;
		if(endData){
    2e8e:	29 81       	ldd	r18, Y+1	; 0x01
    2e90:	22 23       	and	r18, r18
    2e92:	29 f0       	breq	.+10     	; 0x2e9e <HTTPSend+0x5e>
			if(srcDataIdx == dataLen){
				Flags |= TCP_FIN_FLAG;
				pSession->sesState = TCP_STATE_FIN_WAIT1;
    2e94:	85 e0       	ldi	r24, 0x05	; 5
    2e96:	f2 01       	movw	r30, r4
    2e98:	80 8b       	std	Z+16, r24	; 0x10
	dataBuffer = ethGetBuffer() + ETH_HEADER_LEN + IP_HEADER_LEN + TCP_HEADER_LEN;
	if(dataLen == 0){
		Flags |= TCP_ACK_FLAG;
		if(endData){
			if(srcDataIdx == dataLen){
				Flags |= TCP_FIN_FLAG;
    2e9a:	69 e1       	ldi	r22, 0x19	; 25
    2e9c:	01 c0       	rjmp	.+2      	; 0x2ea0 <HTTPSend+0x60>
	Flags = TCP_PSH_FLAG;

	Flags = TCP_PSH_FLAG;
	dataBuffer = ethGetBuffer() + ETH_HEADER_LEN + IP_HEADER_LEN + TCP_HEADER_LEN;
	if(dataLen == 0){
		Flags |= TCP_ACK_FLAG;
    2e9e:	68 e1       	ldi	r22, 0x18	; 24
			if(srcDataIdx == dataLen){
				Flags |= TCP_FIN_FLAG;
				pSession->sesState = TCP_STATE_FIN_WAIT1;
			}
		}
		TCPPackedSend(pSession,Flags,0,dataBuffer);
    2ea0:	c2 01       	movw	r24, r4
    2ea2:	40 e0       	ldi	r20, 0x00	; 0
    2ea4:	50 e0       	ldi	r21, 0x00	; 0
    2ea6:	95 01       	movw	r18, r10
    2ea8:	0e 94 82 21 	call	0x4304	; 0x4304 <TCPPackedSend>
    2eac:	0f c1       	rjmp	.+542    	; 0x30cc <HTTPSend+0x28c>
	}
	while(srcDataIdx < dataLen){
		i = 0;
		while(i<MAX_SEGMENT_SIZE)
			{
			tmpChr = pgm_read_byte(progdata + srcDataIdx++);
    2eae:	78 01       	movw	r14, r16
    2eb0:	08 94       	sec
    2eb2:	e1 1c       	adc	r14, r1
    2eb4:	f1 1c       	adc	r15, r1
    2eb6:	f6 01       	movw	r30, r12
    2eb8:	e0 0f       	add	r30, r16
    2eba:	f1 1f       	adc	r31, r17
    2ebc:	e4 91       	lpm	r30, Z+
			//Truyen nhan du lieu
			if(tmpChr == '%')
    2ebe:	e5 32       	cpi	r30, 0x25	; 37
    2ec0:	09 f0       	breq	.+2      	; 0x2ec4 <HTTPSend+0x84>
    2ec2:	bc c0       	rjmp	.+376    	; 0x303c <HTTPSend+0x1fc>
				{
					//Neu khong con du cho trong tren buffer
					if( (i + 9) > MAX_SEGMENT_SIZE)
    2ec4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ec6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ec8:	09 96       	adiw	r24, 0x09	; 9
    2eca:	f3 e0       	ldi	r31, 0x03	; 3
    2ecc:	89 3e       	cpi	r24, 0xE9	; 233
    2ece:	9f 07       	cpc	r25, r31
    2ed0:	08 f0       	brcs	.+2      	; 0x2ed4 <HTTPSend+0x94>
    2ed2:	de c0       	rjmp	.+444    	; 0x3090 <HTTPSend+0x250>
							srcDataIdx--;
							break;
						}
						
					//Tiep tuc neu du cho trong tren buffer
					tmpVar = pgm_read_byte(progdata + srcDataIdx + 3) - 0x30;
    2ed4:	87 01       	movw	r16, r14
    2ed6:	0d 5f       	subi	r16, 0xFD	; 253
    2ed8:	1f 4f       	sbci	r17, 0xFF	; 255
					//Truong hop tim duoc CL
					if((pgm_read_byte(progdata + srcDataIdx) == 'C') && (pgm_read_byte(progdata + srcDataIdx + 1) == 'L'))
    2eda:	c6 01       	movw	r24, r12
    2edc:	8e 0d       	add	r24, r14
    2ede:	9f 1d       	adc	r25, r15
    2ee0:	fc 01       	movw	r30, r24
    2ee2:	24 91       	lpm	r18, Z+
    2ee4:	23 34       	cpi	r18, 0x43	; 67
    2ee6:	09 f0       	breq	.+2      	; 0x2eea <HTTPSend+0xaa>
    2ee8:	3f c0       	rjmp	.+126    	; 0x2f68 <HTTPSend+0x128>
    2eea:	f7 01       	movw	r30, r14
    2eec:	31 96       	adiw	r30, 0x01	; 1
    2eee:	ec 0d       	add	r30, r12
    2ef0:	fd 1d       	adc	r31, r13
    2ef2:	e4 91       	lpm	r30, Z+
    2ef4:	ec 34       	cpi	r30, 0x4C	; 76
    2ef6:	c1 f5       	brne	.+112    	; 0x2f68 <HTTPSend+0x128>
						{
						if(GetState(pgm_read_byte(progdata + srcDataIdx + 2) - 0x30) == 240)// Get trang thai cua tung role
    2ef8:	f7 01       	movw	r30, r14
    2efa:	32 96       	adiw	r30, 0x02	; 2
    2efc:	ec 0d       	add	r30, r12
    2efe:	fd 1d       	adc	r31, r13
    2f00:	84 91       	lpm	r24, Z+
    2f02:	80 53       	subi	r24, 0x30	; 48
    2f04:	0e 94 c7 1e 	call	0x3d8e	; 0x3d8e <GetState>
    2f08:	80 3f       	cpi	r24, 0xF0	; 240
    2f0a:	a1 f4       	brne	.+40     	; 0x2f34 <HTTPSend+0xf4>
							{dataBuffer[i++] = 'o';dataBuffer[i++] = 'n';}
    2f0c:	ea 81       	ldd	r30, Y+2	; 0x02
    2f0e:	fb 81       	ldd	r31, Y+3	; 0x03
    2f10:	ea 0d       	add	r30, r10
    2f12:	fb 1d       	adc	r31, r11
    2f14:	2f e6       	ldi	r18, 0x6F	; 111
    2f16:	20 83       	st	Z, r18
    2f18:	2a 81       	ldd	r18, Y+2	; 0x02
    2f1a:	3b 81       	ldd	r19, Y+3	; 0x03
    2f1c:	2f 5f       	subi	r18, 0xFF	; 255
    2f1e:	3f 4f       	sbci	r19, 0xFF	; 255
    2f20:	f5 01       	movw	r30, r10
    2f22:	e2 0f       	add	r30, r18
    2f24:	f3 1f       	adc	r31, r19
    2f26:	8e e6       	ldi	r24, 0x6E	; 110
    2f28:	80 83       	st	Z, r24
    2f2a:	f9 01       	movw	r30, r18
    2f2c:	31 96       	adiw	r30, 0x01	; 1
    2f2e:	fb 83       	std	Y+3, r31	; 0x03
    2f30:	ea 83       	std	Y+2, r30	; 0x02
    2f32:	91 c0       	rjmp	.+290    	; 0x3056 <HTTPSend+0x216>
						else
							{dataBuffer[i++] = 'o';dataBuffer[i++] = 'f'; dataBuffer[i++] = 'f';}
    2f34:	ea 81       	ldd	r30, Y+2	; 0x02
    2f36:	fb 81       	ldd	r31, Y+3	; 0x03
    2f38:	ea 0d       	add	r30, r10
    2f3a:	fb 1d       	adc	r31, r11
    2f3c:	2f e6       	ldi	r18, 0x6F	; 111
    2f3e:	20 83       	st	Z, r18
    2f40:	2a 81       	ldd	r18, Y+2	; 0x02
    2f42:	3b 81       	ldd	r19, Y+3	; 0x03
    2f44:	2f 5f       	subi	r18, 0xFF	; 255
    2f46:	3f 4f       	sbci	r19, 0xFF	; 255
    2f48:	f5 01       	movw	r30, r10
    2f4a:	e2 0f       	add	r30, r18
    2f4c:	f3 1f       	adc	r31, r19
    2f4e:	86 e6       	ldi	r24, 0x66	; 102
    2f50:	80 83       	st	Z, r24
    2f52:	2f 5f       	subi	r18, 0xFF	; 255
    2f54:	3f 4f       	sbci	r19, 0xFF	; 255
    2f56:	f5 01       	movw	r30, r10
    2f58:	e2 0f       	add	r30, r18
    2f5a:	f3 1f       	adc	r31, r19
    2f5c:	80 83       	st	Z, r24
    2f5e:	f9 01       	movw	r30, r18
    2f60:	31 96       	adiw	r30, 0x01	; 1
    2f62:	fb 83       	std	Y+3, r31	; 0x03
    2f64:	ea 83       	std	Y+2, r30	; 0x02
						srcDataIdx+=3;
    2f66:	77 c0       	rjmp	.+238    	; 0x3056 <HTTPSend+0x216>
						}
					else
					//Truong hop tim duoc RL
					if((pgm_read_byte(progdata + srcDataIdx) == 'R') && (pgm_read_byte(progdata + srcDataIdx + 1) == 'L'))
    2f68:	fc 01       	movw	r30, r24
    2f6a:	84 91       	lpm	r24, Z+
    2f6c:	82 35       	cpi	r24, 0x52	; 82
    2f6e:	09 f0       	breq	.+2      	; 0x2f72 <HTTPSend+0x132>
    2f70:	59 c0       	rjmp	.+178    	; 0x3024 <HTTPSend+0x1e4>
    2f72:	f7 01       	movw	r30, r14
    2f74:	31 96       	adiw	r30, 0x01	; 1
    2f76:	ec 0d       	add	r30, r12
    2f78:	fd 1d       	adc	r31, r13
    2f7a:	e4 91       	lpm	r30, Z+
    2f7c:	ec 34       	cpi	r30, 0x4C	; 76
    2f7e:	09 f0       	breq	.+2      	; 0x2f82 <HTTPSend+0x142>
    2f80:	51 c0       	rjmp	.+162    	; 0x3024 <HTTPSend+0x1e4>
						{
						if((GetState(pgm_read_byte(progdata + srcDataIdx + 2) - 0x30)) == 240)// Get trang thai cua tung role
    2f82:	f7 01       	movw	r30, r14
    2f84:	32 96       	adiw	r30, 0x02	; 2
    2f86:	ec 0d       	add	r30, r12
    2f88:	fd 1d       	adc	r31, r13
    2f8a:	84 91       	lpm	r24, Z+
    2f8c:	80 53       	subi	r24, 0x30	; 48
    2f8e:	0e 94 c7 1e 	call	0x3d8e	; 0x3d8e <GetState>
    2f92:	80 3f       	cpi	r24, 0xF0	; 240
    2f94:	09 f0       	breq	.+2      	; 0x2f98 <HTTPSend+0x158>
    2f96:	5e c0       	rjmp	.+188    	; 0x3054 <HTTPSend+0x214>
							{
							dataBuffer[i++] = ' ';dataBuffer[i++] = 'c';dataBuffer[i++] = 'h';dataBuffer[i++] = 'e';
    2f98:	ea 81       	ldd	r30, Y+2	; 0x02
    2f9a:	fb 81       	ldd	r31, Y+3	; 0x03
    2f9c:	ea 0d       	add	r30, r10
    2f9e:	fb 1d       	adc	r31, r11
    2fa0:	20 e2       	ldi	r18, 0x20	; 32
    2fa2:	20 83       	st	Z, r18
    2fa4:	2a 81       	ldd	r18, Y+2	; 0x02
    2fa6:	3b 81       	ldd	r19, Y+3	; 0x03
    2fa8:	2f 5f       	subi	r18, 0xFF	; 255
    2faa:	3f 4f       	sbci	r19, 0xFF	; 255
    2fac:	f5 01       	movw	r30, r10
    2fae:	e2 0f       	add	r30, r18
    2fb0:	f3 1f       	adc	r31, r19
    2fb2:	83 e6       	ldi	r24, 0x63	; 99
    2fb4:	80 83       	st	Z, r24
    2fb6:	2f 5f       	subi	r18, 0xFF	; 255
    2fb8:	3f 4f       	sbci	r19, 0xFF	; 255
    2fba:	f5 01       	movw	r30, r10
    2fbc:	e2 0f       	add	r30, r18
    2fbe:	f3 1f       	adc	r31, r19
    2fc0:	98 e6       	ldi	r25, 0x68	; 104
    2fc2:	90 83       	st	Z, r25
    2fc4:	2f 5f       	subi	r18, 0xFF	; 255
    2fc6:	3f 4f       	sbci	r19, 0xFF	; 255
    2fc8:	f5 01       	movw	r30, r10
    2fca:	e2 0f       	add	r30, r18
    2fcc:	f3 1f       	adc	r31, r19
    2fce:	85 e6       	ldi	r24, 0x65	; 101
    2fd0:	80 83       	st	Z, r24
    2fd2:	2f 5f       	subi	r18, 0xFF	; 255
    2fd4:	3f 4f       	sbci	r19, 0xFF	; 255
							dataBuffer[i++] = 'c';dataBuffer[i++] = 'k';dataBuffer[i++] = 'e';dataBuffer[i++] = 'd'; dataBuffer[i++] = ' ';
    2fd6:	f5 01       	movw	r30, r10
    2fd8:	e2 0f       	add	r30, r18
    2fda:	f3 1f       	adc	r31, r19
    2fdc:	93 e6       	ldi	r25, 0x63	; 99
    2fde:	90 83       	st	Z, r25
    2fe0:	2f 5f       	subi	r18, 0xFF	; 255
    2fe2:	3f 4f       	sbci	r19, 0xFF	; 255
    2fe4:	f5 01       	movw	r30, r10
    2fe6:	e2 0f       	add	r30, r18
    2fe8:	f3 1f       	adc	r31, r19
    2fea:	8b e6       	ldi	r24, 0x6B	; 107
    2fec:	80 83       	st	Z, r24
    2fee:	2f 5f       	subi	r18, 0xFF	; 255
    2ff0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ff2:	f5 01       	movw	r30, r10
    2ff4:	e2 0f       	add	r30, r18
    2ff6:	f3 1f       	adc	r31, r19
    2ff8:	95 e6       	ldi	r25, 0x65	; 101
    2ffa:	90 83       	st	Z, r25
    2ffc:	2f 5f       	subi	r18, 0xFF	; 255
    2ffe:	3f 4f       	sbci	r19, 0xFF	; 255
    3000:	f5 01       	movw	r30, r10
    3002:	e2 0f       	add	r30, r18
    3004:	f3 1f       	adc	r31, r19
    3006:	84 e6       	ldi	r24, 0x64	; 100
    3008:	80 83       	st	Z, r24
    300a:	2f 5f       	subi	r18, 0xFF	; 255
    300c:	3f 4f       	sbci	r19, 0xFF	; 255
    300e:	f5 01       	movw	r30, r10
    3010:	e2 0f       	add	r30, r18
    3012:	f3 1f       	adc	r31, r19
    3014:	90 e2       	ldi	r25, 0x20	; 32
    3016:	90 83       	st	Z, r25
    3018:	f9 01       	movw	r30, r18
    301a:	31 96       	adiw	r30, 0x01	; 1
    301c:	fb 83       	std	Y+3, r31	; 0x03
    301e:	ea 83       	std	Y+2, r30	; 0x02
	}
	while(srcDataIdx < dataLen){
		i = 0;
		while(i<MAX_SEGMENT_SIZE)
			{
			tmpChr = pgm_read_byte(progdata + srcDataIdx++);
    3020:	87 01       	movw	r16, r14
    3022:	19 c0       	rjmp	.+50     	; 0x3056 <HTTPSend+0x216>
							dataBuffer[i++] = 'c';dataBuffer[i++] = 'k';dataBuffer[i++] = 'e';dataBuffer[i++] = 'd'; dataBuffer[i++] = ' ';
							}
						}						
					//Cac truong hop con lai
					else
						dataBuffer[i++] = tmpChr;																																					
    3024:	ea 81       	ldd	r30, Y+2	; 0x02
    3026:	fb 81       	ldd	r31, Y+3	; 0x03
    3028:	ea 0d       	add	r30, r10
    302a:	fb 1d       	adc	r31, r11
    302c:	60 82       	st	Z, r6
    302e:	8a 81       	ldd	r24, Y+2	; 0x02
    3030:	9b 81       	ldd	r25, Y+3	; 0x03
    3032:	01 96       	adiw	r24, 0x01	; 1
    3034:	9b 83       	std	Y+3, r25	; 0x03
    3036:	8a 83       	std	Y+2, r24	; 0x02
	}
	while(srcDataIdx < dataLen){
		i = 0;
		while(i<MAX_SEGMENT_SIZE)
			{
			tmpChr = pgm_read_byte(progdata + srcDataIdx++);
    3038:	87 01       	movw	r16, r14
    303a:	0d c0       	rjmp	.+26     	; 0x3056 <HTTPSend+0x216>
					//Cac truong hop con lai
					else
						dataBuffer[i++] = tmpChr;																																					
				}
			else
				dataBuffer[i++] = tmpChr;	//Copy data to tcp data buffer
    303c:	aa 81       	ldd	r26, Y+2	; 0x02
    303e:	bb 81       	ldd	r27, Y+3	; 0x03
    3040:	aa 0d       	add	r26, r10
    3042:	bb 1d       	adc	r27, r11
    3044:	ec 93       	st	X, r30
    3046:	ea 81       	ldd	r30, Y+2	; 0x02
    3048:	fb 81       	ldd	r31, Y+3	; 0x03
    304a:	31 96       	adiw	r30, 0x01	; 1
    304c:	fb 83       	std	Y+3, r31	; 0x03
    304e:	ea 83       	std	Y+2, r30	; 0x02
	}
	while(srcDataIdx < dataLen){
		i = 0;
		while(i<MAX_SEGMENT_SIZE)
			{
			tmpChr = pgm_read_byte(progdata + srcDataIdx++);
    3050:	87 01       	movw	r16, r14
    3052:	01 c0       	rjmp	.+2      	; 0x3056 <HTTPSend+0x216>
    3054:	87 01       	movw	r16, r14
					else
						dataBuffer[i++] = tmpChr;																																					
				}
			else
				dataBuffer[i++] = tmpChr;	//Copy data to tcp data buffer
			if(srcDataIdx==dataLen)
    3056:	08 15       	cp	r16, r8
    3058:	19 05       	cpc	r17, r9
    305a:	89 f4       	brne	.+34     	; 0x307e <HTTPSend+0x23e>
    305c:	ea 80       	ldd	r14, Y+2	; 0x02
    305e:	fb 80       	ldd	r15, Y+3	; 0x03
    3060:	19 c0       	rjmp	.+50     	; 0x3094 <HTTPSend+0x254>
	unsigned char Flags;
	unsigned char tmpChr,tmpVar;
	//unsigned char temp_adc;
	Flags = TCP_PSH_FLAG;

	Flags = TCP_PSH_FLAG;
    3062:	77 24       	eor	r7, r7
    3064:	68 94       	set
    3066:	73 f8       	bld	r7, 3
	dataBuffer = ethGetBuffer() + ETH_HEADER_LEN + IP_HEADER_LEN + TCP_HEADER_LEN;
	if(dataLen == 0){
    3068:	00 e0       	ldi	r16, 0x00	; 0
    306a:	10 e0       	ldi	r17, 0x00	; 0
		Flags |= TCP_ACK_FLAG;
		if(endData){
			if(srcDataIdx == dataLen){
				Flags |= TCP_FIN_FLAG;
    306c:	22 24       	eor	r2, r2
    306e:	33 24       	eor	r3, r3
							dataBuffer[i++] = 'c';dataBuffer[i++] = 'k';dataBuffer[i++] = 'e';dataBuffer[i++] = 'd'; dataBuffer[i++] = ' ';
							}
						}						
					//Cac truong hop con lai
					else
						dataBuffer[i++] = tmpChr;																																					
    3070:	0f 2e       	mov	r0, r31
    3072:	f5 e2       	ldi	r31, 0x25	; 37
    3074:	6f 2e       	mov	r6, r31
    3076:	f0 2d       	mov	r31, r0
    3078:	3b 82       	std	Y+3, r3	; 0x03
    307a:	2a 82       	std	Y+2, r2	; 0x02
    307c:	18 cf       	rjmp	.-464    	; 0x2eae <HTTPSend+0x6e>
		}
		TCPPackedSend(pSession,Flags,0,dataBuffer);
	}
	while(srcDataIdx < dataLen){
		i = 0;
		while(i<MAX_SEGMENT_SIZE)
    307e:	8a 81       	ldd	r24, Y+2	; 0x02
    3080:	9b 81       	ldd	r25, Y+3	; 0x03
    3082:	e3 e0       	ldi	r30, 0x03	; 3
    3084:	88 3e       	cpi	r24, 0xE8	; 232
    3086:	9e 07       	cpc	r25, r30
    3088:	08 f4       	brcc	.+2      	; 0x308c <HTTPSend+0x24c>
    308a:	11 cf       	rjmp	.-478    	; 0x2eae <HTTPSend+0x6e>
    308c:	7c 01       	movw	r14, r24
    308e:	02 c0       	rjmp	.+4      	; 0x3094 <HTTPSend+0x254>
    3090:	ea 80       	ldd	r14, Y+2	; 0x02
    3092:	fb 80       	ldd	r15, Y+3	; 0x03
			else
				dataBuffer[i++] = tmpChr;	//Copy data to tcp data buffer
			if(srcDataIdx==dataLen)
				break;
		}
		Flags |= TCP_ACK_FLAG;
    3094:	f0 e1       	ldi	r31, 0x10	; 16
    3096:	7f 2a       	or	r7, r31
		if(endData){
    3098:	29 81       	ldd	r18, Y+1	; 0x01
    309a:	22 23       	and	r18, r18
    309c:	71 f0       	breq	.+28     	; 0x30ba <HTTPSend+0x27a>
			if(srcDataIdx == dataLen){
    309e:	08 15       	cp	r16, r8
    30a0:	19 05       	cpc	r17, r9
    30a2:	59 f4       	brne	.+22     	; 0x30ba <HTTPSend+0x27a>
				Flags |= TCP_FIN_FLAG;
				pSession->sesState = TCP_STATE_FIN_WAIT1;
    30a4:	85 e0       	ldi	r24, 0x05	; 5
    30a6:	f2 01       	movw	r30, r4
    30a8:	80 8b       	std	Z+16, r24	; 0x10
				break;
		}
		Flags |= TCP_ACK_FLAG;
		if(endData){
			if(srcDataIdx == dataLen){
				Flags |= TCP_FIN_FLAG;
    30aa:	67 2d       	mov	r22, r7
    30ac:	61 60       	ori	r22, 0x01	; 1
				pSession->sesState = TCP_STATE_FIN_WAIT1;
			}
		}
		TCPPackedSend(pSession,Flags,i,dataBuffer);
    30ae:	c2 01       	movw	r24, r4
    30b0:	a7 01       	movw	r20, r14
    30b2:	95 01       	movw	r18, r10
    30b4:	0e 94 82 21 	call	0x4304	; 0x4304 <TCPPackedSend>
    30b8:	09 c0       	rjmp	.+18     	; 0x30cc <HTTPSend+0x28c>
    30ba:	c2 01       	movw	r24, r4
    30bc:	67 2d       	mov	r22, r7
    30be:	a7 01       	movw	r20, r14
    30c0:	95 01       	movw	r18, r10
    30c2:	0e 94 82 21 	call	0x4304	; 0x4304 <TCPPackedSend>
				pSession->sesState = TCP_STATE_FIN_WAIT1;
			}
		}
		TCPPackedSend(pSession,Flags,0,dataBuffer);
	}
	while(srcDataIdx < dataLen){
    30c6:	08 15       	cp	r16, r8
    30c8:	19 05       	cpc	r17, r9
    30ca:	b0 f2       	brcs	.-84     	; 0x3078 <HTTPSend+0x238>
				pSession->sesState = TCP_STATE_FIN_WAIT1;
			}
		}
		TCPPackedSend(pSession,Flags,i,dataBuffer);
	}
}
    30cc:	0f 90       	pop	r0
    30ce:	0f 90       	pop	r0
    30d0:	0f 90       	pop	r0
    30d2:	cf 91       	pop	r28
    30d4:	df 91       	pop	r29
    30d6:	1f 91       	pop	r17
    30d8:	0f 91       	pop	r16
    30da:	ff 90       	pop	r15
    30dc:	ef 90       	pop	r14
    30de:	df 90       	pop	r13
    30e0:	cf 90       	pop	r12
    30e2:	bf 90       	pop	r11
    30e4:	af 90       	pop	r10
    30e6:	9f 90       	pop	r9
    30e8:	8f 90       	pop	r8
    30ea:	7f 90       	pop	r7
    30ec:	6f 90       	pop	r6
    30ee:	5f 90       	pop	r5
    30f0:	4f 90       	pop	r4
    30f2:	3f 90       	pop	r3
    30f4:	2f 90       	pop	r2
    30f6:	08 95       	ret

000030f8 <findstr>:
//----------------------------------------------------------------------------
unsigned int findstr(const prog_char progstr[],unsigned char* str,unsigned int len)
{
    30f8:	1f 93       	push	r17
    30fa:	cf 93       	push	r28
    30fc:	df 93       	push	r29
	unsigned int i,j;
	i=0;
	j=0;
	while(i<len){
    30fe:	41 15       	cp	r20, r1
    3100:	51 05       	cpc	r21, r1
    3102:	21 f1       	breq	.+72     	; 0x314c <findstr+0x54>
    3104:	a6 2f       	mov	r26, r22
    3106:	b7 2f       	mov	r27, r23
//----------------------------------------------------------------------------
unsigned int findstr(const prog_char progstr[],unsigned char* str,unsigned int len)
{
	unsigned int i,j;
	i=0;
	j=0;
    3108:	20 e0       	ldi	r18, 0x00	; 0
    310a:	30 e0       	ldi	r19, 0x00	; 0
}
//----------------------------------------------------------------------------
unsigned int findstr(const prog_char progstr[],unsigned char* str,unsigned int len)
{
	unsigned int i,j;
	i=0;
    310c:	60 e0       	ldi	r22, 0x00	; 0
    310e:	70 e0       	ldi	r23, 0x00	; 0
	j=0;
	while(i<len){
		if(str[i++] != pgm_read_byte(progstr + j++)){
			j = 0;
    3110:	c0 e0       	ldi	r28, 0x00	; 0
    3112:	d0 e0       	ldi	r29, 0x00	; 0
{
	unsigned int i,j;
	i=0;
	j=0;
	while(i<len){
		if(str[i++] != pgm_read_byte(progstr + j++)){
    3114:	1d 91       	ld	r17, X+
    3116:	fc 01       	movw	r30, r24
    3118:	e2 0f       	add	r30, r18
    311a:	f3 1f       	adc	r31, r19
    311c:	e4 91       	lpm	r30, Z+
    311e:	6f 5f       	subi	r22, 0xFF	; 255
    3120:	7f 4f       	sbci	r23, 0xFF	; 255
    3122:	1e 17       	cp	r17, r30
    3124:	19 f4       	brne	.+6      	; 0x312c <findstr+0x34>
    3126:	2f 5f       	subi	r18, 0xFF	; 255
    3128:	3f 4f       	sbci	r19, 0xFF	; 255
    312a:	01 c0       	rjmp	.+2      	; 0x312e <findstr+0x36>
			j = 0;
    312c:	9e 01       	movw	r18, r28
		}
		if(pgm_read_byte(progstr + j) == 0){
    312e:	fc 01       	movw	r30, r24
    3130:	e2 0f       	add	r30, r18
    3132:	f3 1f       	adc	r31, r19
    3134:	e4 91       	lpm	r30, Z+
    3136:	ee 23       	and	r30, r30
    3138:	19 f4       	brne	.+6      	; 0x3140 <findstr+0x48>
			return(i-j);
    313a:	62 1b       	sub	r22, r18
    313c:	73 0b       	sbc	r23, r19
    313e:	08 c0       	rjmp	.+16     	; 0x3150 <findstr+0x58>
unsigned int findstr(const prog_char progstr[],unsigned char* str,unsigned int len)
{
	unsigned int i,j;
	i=0;
	j=0;
	while(i<len){
    3140:	64 17       	cp	r22, r20
    3142:	75 07       	cpc	r23, r21
    3144:	38 f3       	brcs	.-50     	; 0x3114 <findstr+0x1c>
		}
		if(pgm_read_byte(progstr + j) == 0){
			return(i-j);
		}
	}
	return(-1);
    3146:	6f ef       	ldi	r22, 0xFF	; 255
    3148:	7f ef       	ldi	r23, 0xFF	; 255
    314a:	02 c0       	rjmp	.+4      	; 0x3150 <findstr+0x58>
    314c:	6f ef       	ldi	r22, 0xFF	; 255
    314e:	7f ef       	ldi	r23, 0xFF	; 255
}
    3150:	86 2f       	mov	r24, r22
    3152:	97 2f       	mov	r25, r23
    3154:	df 91       	pop	r29
    3156:	cf 91       	pop	r28
    3158:	1f 91       	pop	r17
    315a:	08 95       	ret

0000315c <findstrdatamem>:
//----------------------------------------------------------------------------
unsigned int findstrdatamem(unsigned char* str1,unsigned char* str2,unsigned int len)
{
    315c:	1f 93       	push	r17
    315e:	cf 93       	push	r28
    3160:	df 93       	push	r29
	unsigned int i,j;
	i=0;
	j=0;
	while(i<len){
    3162:	41 15       	cp	r20, r1
    3164:	51 05       	cpc	r21, r1
    3166:	39 f1       	breq	.+78     	; 0x31b6 <findstrdatamem+0x5a>
    3168:	e6 2f       	mov	r30, r22
    316a:	f7 2f       	mov	r31, r23
//----------------------------------------------------------------------------
unsigned int findstrdatamem(unsigned char* str1,unsigned char* str2,unsigned int len)
{
	unsigned int i,j;
	i=0;
	j=0;
    316c:	60 e0       	ldi	r22, 0x00	; 0
    316e:	70 e0       	ldi	r23, 0x00	; 0
}
//----------------------------------------------------------------------------
unsigned int findstrdatamem(unsigned char* str1,unsigned char* str2,unsigned int len)
{
	unsigned int i,j;
	i=0;
    3170:	20 e0       	ldi	r18, 0x00	; 0
    3172:	30 e0       	ldi	r19, 0x00	; 0
	j=0;
	while(i<len){
		if(str2[i++] != str1[j++]){
			j = 0;
    3174:	c0 e0       	ldi	r28, 0x00	; 0
    3176:	d0 e0       	ldi	r29, 0x00	; 0
{
	unsigned int i,j;
	i=0;
	j=0;
	while(i<len){
		if(str2[i++] != str1[j++]){
    3178:	11 91       	ld	r17, Z+
    317a:	2f 5f       	subi	r18, 0xFF	; 255
    317c:	3f 4f       	sbci	r19, 0xFF	; 255
    317e:	dc 01       	movw	r26, r24
    3180:	a6 0f       	add	r26, r22
    3182:	b7 1f       	adc	r27, r23
    3184:	ac 91       	ld	r26, X
    3186:	1a 17       	cp	r17, r26
    3188:	19 f4       	brne	.+6      	; 0x3190 <findstrdatamem+0x34>
    318a:	6f 5f       	subi	r22, 0xFF	; 255
    318c:	7f 4f       	sbci	r23, 0xFF	; 255
    318e:	01 c0       	rjmp	.+2      	; 0x3192 <findstrdatamem+0x36>
			j = 0;
    3190:	be 01       	movw	r22, r28
		}
		if(str1[j] == 0){
    3192:	dc 01       	movw	r26, r24
    3194:	a6 0f       	add	r26, r22
    3196:	b7 1f       	adc	r27, r23
    3198:	ac 91       	ld	r26, X
    319a:	aa 23       	and	r26, r26
    319c:	19 f4       	brne	.+6      	; 0x31a4 <findstrdatamem+0x48>
			return(i-j);
    319e:	26 1b       	sub	r18, r22
    31a0:	37 0b       	sbc	r19, r23
    31a2:	0e c0       	rjmp	.+28     	; 0x31c0 <findstrdatamem+0x64>
		}
		if(str2[i] == 0){
    31a4:	a0 81       	ld	r26, Z
    31a6:	aa 23       	and	r26, r26
    31a8:	49 f0       	breq	.+18     	; 0x31bc <findstrdatamem+0x60>
unsigned int findstrdatamem(unsigned char* str1,unsigned char* str2,unsigned int len)
{
	unsigned int i,j;
	i=0;
	j=0;
	while(i<len){
    31aa:	24 17       	cp	r18, r20
    31ac:	35 07       	cpc	r19, r21
    31ae:	20 f3       	brcs	.-56     	; 0x3178 <findstrdatamem+0x1c>
		}
		if(str2[i] == 0){
			return(-1);
		}
	}
	return(-1);
    31b0:	2f ef       	ldi	r18, 0xFF	; 255
    31b2:	3f ef       	ldi	r19, 0xFF	; 255
    31b4:	05 c0       	rjmp	.+10     	; 0x31c0 <findstrdatamem+0x64>
    31b6:	2f ef       	ldi	r18, 0xFF	; 255
    31b8:	3f ef       	ldi	r19, 0xFF	; 255
    31ba:	02 c0       	rjmp	.+4      	; 0x31c0 <findstrdatamem+0x64>
		}
		if(str1[j] == 0){
			return(i-j);
		}
		if(str2[i] == 0){
			return(-1);
    31bc:	2f ef       	ldi	r18, 0xFF	; 255
    31be:	3f ef       	ldi	r19, 0xFF	; 255
		}
	}
	return(-1);
}
    31c0:	82 2f       	mov	r24, r18
    31c2:	93 2f       	mov	r25, r19
    31c4:	df 91       	pop	r29
    31c6:	cf 91       	pop	r28
    31c8:	1f 91       	pop	r17
    31ca:	08 95       	ret

000031cc <httpDataIn>:
//----------------------------------------------------------------------------
//Ham xu ly mot goi thuoc giao thuc HTP nhan duoc
void httpDataIn(unsigned char *buffer,unsigned int bufferLen,struct tcpSession *pSession)
{
    31cc:	af 92       	push	r10
    31ce:	bf 92       	push	r11
    31d0:	cf 92       	push	r12
    31d2:	df 92       	push	r13
    31d4:	ef 92       	push	r14
    31d6:	ff 92       	push	r15
    31d8:	0f 93       	push	r16
    31da:	1f 93       	push	r17
    31dc:	cf 93       	push	r28
    31de:	df 93       	push	r29
    31e0:	7c 01       	movw	r14, r24
    31e2:	6b 01       	movw	r12, r22
    31e4:	8a 01       	movw	r16, r20
			break;
	}
	if(i == MAX_HTTP_SESSION){
		//Tim 1 phien trong
		for(i=0; i < MAX_HTTP_SESSION; i++){
			if(httpSessionTable[i].status == HTTP_STATUS_IDLE){
    31e6:	ed e1       	ldi	r30, 0x1D	; 29
    31e8:	f5 e0       	ldi	r31, 0x05	; 5
void httpDataIn(unsigned char *buffer,unsigned int bufferLen,struct tcpSession *pSession)
{
	unsigned char i;
	unsigned char *tmpstr;
	//Tim xem cophien HTTP service da co cho phien TCP nay khong
	for(i=0; i < MAX_HTTP_SESSION; i++){
    31ea:	40 e0       	ldi	r20, 0x00	; 0
		if((httpSessionTable[i].status != HTTP_STATUS_IDLE) && (httpSessionTable[i].pTCPSession == pSession))
    31ec:	80 81       	ld	r24, Z
    31ee:	88 23       	and	r24, r24
    31f0:	29 f0       	breq	.+10     	; 0x31fc <httpDataIn+0x30>
    31f2:	83 89       	ldd	r24, Z+19	; 0x13
    31f4:	94 89       	ldd	r25, Z+20	; 0x14
    31f6:	80 17       	cp	r24, r16
    31f8:	91 07       	cpc	r25, r17
    31fa:	29 f0       	breq	.+10     	; 0x3206 <httpDataIn+0x3a>
void httpDataIn(unsigned char *buffer,unsigned int bufferLen,struct tcpSession *pSession)
{
	unsigned char i;
	unsigned char *tmpstr;
	//Tim xem cophien HTTP service da co cho phien TCP nay khong
	for(i=0; i < MAX_HTTP_SESSION; i++){
    31fc:	4f 5f       	subi	r20, 0xFF	; 255
    31fe:	75 96       	adiw	r30, 0x15	; 21
    3200:	48 30       	cpi	r20, 0x08	; 8
    3202:	a1 f7       	brne	.-24     	; 0x31ec <httpDataIn+0x20>
    3204:	02 c0       	rjmp	.+4      	; 0x320a <httpDataIn+0x3e>
		if((httpSessionTable[i].status != HTTP_STATUS_IDLE) && (httpSessionTable[i].pTCPSession == pSession))
			break;
	}
	if(i == MAX_HTTP_SESSION){
    3206:	48 30       	cpi	r20, 0x08	; 8
    3208:	49 f5       	brne	.+82     	; 0x325c <httpDataIn+0x90>
		//Tim 1 phien trong
		for(i=0; i < MAX_HTTP_SESSION; i++){
			if(httpSessionTable[i].status == HTTP_STATUS_IDLE){
    320a:	80 91 1d 05 	lds	r24, 0x051D
    320e:	88 23       	and	r24, r24
    3210:	59 f0       	breq	.+22     	; 0x3228 <httpDataIn+0x5c>
    3212:	e2 e3       	ldi	r30, 0x32	; 50
    3214:	f5 e0       	ldi	r31, 0x05	; 5
    3216:	80 e0       	ldi	r24, 0x00	; 0
    3218:	90 e0       	ldi	r25, 0x00	; 0
		if((httpSessionTable[i].status != HTTP_STATUS_IDLE) && (httpSessionTable[i].pTCPSession == pSession))
			break;
	}
	if(i == MAX_HTTP_SESSION){
		//Tim 1 phien trong
		for(i=0; i < MAX_HTTP_SESSION; i++){
    321a:	41 e0       	ldi	r20, 0x01	; 1
	}
	return(-1);
}
//----------------------------------------------------------------------------
//Ham xu ly mot goi thuoc giao thuc HTP nhan duoc
void httpDataIn(unsigned char *buffer,unsigned int bufferLen,struct tcpSession *pSession)
    321c:	01 96       	adiw	r24, 0x01	; 1
    321e:	9c 01       	movw	r18, r24
			break;
	}
	if(i == MAX_HTTP_SESSION){
		//Tim 1 phien trong
		for(i=0; i < MAX_HTTP_SESSION; i++){
			if(httpSessionTable[i].status == HTTP_STATUS_IDLE){
    3220:	50 81       	ld	r21, Z
    3222:	55 23       	and	r21, r21
    3224:	b9 f4       	brne	.+46     	; 0x3254 <httpDataIn+0x88>
    3226:	03 c0       	rjmp	.+6      	; 0x322e <httpDataIn+0x62>
    3228:	20 e0       	ldi	r18, 0x00	; 0
    322a:	30 e0       	ldi	r19, 0x00	; 0
    322c:	40 e0       	ldi	r20, 0x00	; 0
				httpSessionTable[i].pTCPSession = pSession;
    322e:	c9 01       	movw	r24, r18
    3230:	88 0f       	add	r24, r24
    3232:	99 1f       	adc	r25, r25
    3234:	28 0f       	add	r18, r24
    3236:	39 1f       	adc	r19, r25
    3238:	f9 01       	movw	r30, r18
    323a:	ee 0f       	add	r30, r30
    323c:	ff 1f       	adc	r31, r31
    323e:	ee 0f       	add	r30, r30
    3240:	ff 1f       	adc	r31, r31
    3242:	ee 0f       	add	r30, r30
    3244:	ff 1f       	adc	r31, r31
    3246:	e2 1b       	sub	r30, r18
    3248:	f3 0b       	sbc	r31, r19
    324a:	e3 5e       	subi	r30, 0xE3	; 227
    324c:	fa 4f       	sbci	r31, 0xFA	; 250
    324e:	14 8b       	std	Z+20, r17	; 0x14
    3250:	03 8b       	std	Z+19, r16	; 0x13
				break;
    3252:	04 c0       	rjmp	.+8      	; 0x325c <httpDataIn+0x90>
		if((httpSessionTable[i].status != HTTP_STATUS_IDLE) && (httpSessionTable[i].pTCPSession == pSession))
			break;
	}
	if(i == MAX_HTTP_SESSION){
		//Tim 1 phien trong
		for(i=0; i < MAX_HTTP_SESSION; i++){
    3254:	4f 5f       	subi	r20, 0xFF	; 255
    3256:	75 96       	adiw	r30, 0x15	; 21
    3258:	48 30       	cpi	r20, 0x08	; 8
    325a:	01 f7       	brne	.-64     	; 0x321c <httpDataIn+0x50>
				httpSessionTable[i].pTCPSession = pSession;
				break;
			}
		}
	}
	if(httpSessionTable[i].status == HTTP_STATUS_IDLE){
    325c:	c4 2f       	mov	r28, r20
    325e:	d0 e0       	ldi	r29, 0x00	; 0
    3260:	ce 01       	movw	r24, r28
    3262:	88 0f       	add	r24, r24
    3264:	99 1f       	adc	r25, r25
    3266:	8c 0f       	add	r24, r28
    3268:	9d 1f       	adc	r25, r29
    326a:	fc 01       	movw	r30, r24
    326c:	ee 0f       	add	r30, r30
    326e:	ff 1f       	adc	r31, r31
    3270:	ee 0f       	add	r30, r30
    3272:	ff 1f       	adc	r31, r31
    3274:	ee 0f       	add	r30, r30
    3276:	ff 1f       	adc	r31, r31
    3278:	e8 1b       	sub	r30, r24
    327a:	f9 0b       	sbc	r31, r25
    327c:	e3 5e       	subi	r30, 0xE3	; 227
    327e:	fa 4f       	sbci	r31, 0xFA	; 250
    3280:	80 81       	ld	r24, Z
    3282:	88 23       	and	r24, r24
    3284:	99 f5       	brne	.+102    	; 0x32ec <httpDataIn+0x120>
	//Neu day la 1 HTTP request moi
		//Kiem tra method cua request
		httpGetRequest(buffer,bufferLen,&(httpSessionTable[i].rqst));
    3286:	ce 01       	movw	r24, r28
    3288:	88 0f       	add	r24, r24
    328a:	99 1f       	adc	r25, r25
    328c:	8c 0f       	add	r24, r28
    328e:	9d 1f       	adc	r25, r29
    3290:	5c 01       	movw	r10, r24
    3292:	aa 0c       	add	r10, r10
    3294:	bb 1c       	adc	r11, r11
    3296:	aa 0c       	add	r10, r10
    3298:	bb 1c       	adc	r11, r11
    329a:	aa 0c       	add	r10, r10
    329c:	bb 1c       	adc	r11, r11
    329e:	a8 1a       	sub	r10, r24
    32a0:	b9 0a       	sbc	r11, r25
    32a2:	a5 01       	movw	r20, r10
    32a4:	4b 5d       	subi	r20, 0xDB	; 219
    32a6:	5a 4f       	sbci	r21, 0xFA	; 250
    32a8:	c7 01       	movw	r24, r14
    32aa:	b6 01       	movw	r22, r12
    32ac:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <httpGetRequest>
		if(httpSessionTable[i].rqst.method == HTTP_REQUEST_UNKNOWN){
    32b0:	f5 01       	movw	r30, r10
    32b2:	e3 5e       	subi	r30, 0xE3	; 227
    32b4:	fa 4f       	sbci	r31, 0xFA	; 250
    32b6:	80 85       	ldd	r24, Z+8	; 0x08
    32b8:	84 30       	cpi	r24, 0x04	; 4
    32ba:	29 f4       	brne	.+10     	; 0x32c6 <httpDataIn+0xfa>
		//Neu request khong biet, thoat tro ve trang thai idle
			httpSessionTable[i].status = HTTP_STATUS_IDLE;
    32bc:	f5 01       	movw	r30, r10
    32be:	e3 5e       	subi	r30, 0xE3	; 227
    32c0:	fa 4f       	sbci	r31, 0xFA	; 250
    32c2:	10 82       	st	Z, r1
			return;
    32c4:	78 c1       	rjmp	.+752    	; 0x35b6 <httpDataIn+0x3ea>
		}else{
		//Set trang thai cua HTTP session thanh HEADER_RECEIVED (da nhan header)
			httpSessionTable[i].status = HTTP_STATUS_HEADER_RECEIVED;
    32c6:	ce 01       	movw	r24, r28
    32c8:	88 0f       	add	r24, r24
    32ca:	99 1f       	adc	r25, r25
    32cc:	8c 0f       	add	r24, r28
    32ce:	9d 1f       	adc	r25, r29
    32d0:	fc 01       	movw	r30, r24
    32d2:	ee 0f       	add	r30, r30
    32d4:	ff 1f       	adc	r31, r31
    32d6:	ee 0f       	add	r30, r30
    32d8:	ff 1f       	adc	r31, r31
    32da:	ee 0f       	add	r30, r30
    32dc:	ff 1f       	adc	r31, r31
    32de:	e8 1b       	sub	r30, r24
    32e0:	f9 0b       	sbc	r31, r25
    32e2:	e3 5e       	subi	r30, 0xE3	; 227
    32e4:	fa 4f       	sbci	r31, 0xFA	; 250
    32e6:	83 e0       	ldi	r24, 0x03	; 3
    32e8:	80 83       	st	Z, r24
    32ea:	03 c0       	rjmp	.+6      	; 0x32f2 <httpDataIn+0x126>
		}
	}
	//Neu da nhan header
	if(httpSessionTable[i].status == HTTP_STATUS_HEADER_RECEIVED){
    32ec:	83 30       	cpi	r24, 0x03	; 3
    32ee:	09 f0       	breq	.+2      	; 0x32f2 <httpDataIn+0x126>
    32f0:	62 c1       	rjmp	.+708    	; 0x35b6 <httpDataIn+0x3ea>
		//Kiem tra xem da xac thuc hay chua
		if(httpSessionTable[i].auth != 1){
    32f2:	ce 01       	movw	r24, r28
    32f4:	88 0f       	add	r24, r24
    32f6:	99 1f       	adc	r25, r25
    32f8:	8c 0f       	add	r24, r28
    32fa:	9d 1f       	adc	r25, r29
    32fc:	fc 01       	movw	r30, r24
    32fe:	ee 0f       	add	r30, r30
    3300:	ff 1f       	adc	r31, r31
    3302:	ee 0f       	add	r30, r30
    3304:	ff 1f       	adc	r31, r31
    3306:	ee 0f       	add	r30, r30
    3308:	ff 1f       	adc	r31, r31
    330a:	e8 1b       	sub	r30, r24
    330c:	f9 0b       	sbc	r31, r25
    330e:	e3 5e       	subi	r30, 0xE3	; 227
    3310:	fa 4f       	sbci	r31, 0xFA	; 250
    3312:	87 81       	ldd	r24, Z+7	; 0x07
    3314:	81 30       	cpi	r24, 0x01	; 1
    3316:	09 f4       	brne	.+2      	; 0x331a <httpDataIn+0x14e>
    3318:	4d c0       	rjmp	.+154    	; 0x33b4 <httpDataIn+0x1e8>
			tmpstr = httpHeaderGetField(Auth_str,&(httpSessionTable[i].rqst));
    331a:	ce 01       	movw	r24, r28
    331c:	88 0f       	add	r24, r24
    331e:	99 1f       	adc	r25, r25
    3320:	8c 0f       	add	r24, r28
    3322:	9d 1f       	adc	r25, r29
    3324:	5c 01       	movw	r10, r24
    3326:	aa 0c       	add	r10, r10
    3328:	bb 1c       	adc	r11, r11
    332a:	aa 0c       	add	r10, r10
    332c:	bb 1c       	adc	r11, r11
    332e:	aa 0c       	add	r10, r10
    3330:	bb 1c       	adc	r11, r11
    3332:	a8 1a       	sub	r10, r24
    3334:	b9 0a       	sbc	r11, r25
    3336:	b5 01       	movw	r22, r10
    3338:	6b 5d       	subi	r22, 0xDB	; 219
    333a:	7a 4f       	sbci	r23, 0xFA	; 250
    333c:	8c e2       	ldi	r24, 0x2C	; 44
    333e:	90 e1       	ldi	r25, 0x10	; 16
    3340:	0e 94 e1 16 	call	0x2dc2	; 0x2dc2 <httpHeaderGetField>
    3344:	bc 01       	movw	r22, r24
			if(findstrdatamem(http_auth_password,tmpstr,httpSessionTable[i].rqst.body-tmpstr) != -1){
    3346:	f5 01       	movw	r30, r10
    3348:	e3 5e       	subi	r30, 0xE3	; 227
    334a:	fa 4f       	sbci	r31, 0xFA	; 250
    334c:	47 85       	ldd	r20, Z+15	; 0x0f
    334e:	50 89       	ldd	r21, Z+16	; 0x10
    3350:	48 1b       	sub	r20, r24
    3352:	59 0b       	sbc	r21, r25
    3354:	85 ec       	ldi	r24, 0xC5	; 197
    3356:	95 e0       	ldi	r25, 0x05	; 5
    3358:	0e 94 ae 18 	call	0x315c	; 0x315c <findstrdatamem>
    335c:	2f ef       	ldi	r18, 0xFF	; 255
    335e:	8f 3f       	cpi	r24, 0xFF	; 255
    3360:	92 07       	cpc	r25, r18
    3362:	31 f0       	breq	.+12     	; 0x3370 <httpDataIn+0x1a4>
				printf("Auth OK\n\r");
				printfStr(http_auth_password);
				printf("Input\n\r");
				printfStr(tmpstr);
				#endif
				httpSessionTable[i].auth = 1;
    3364:	f5 01       	movw	r30, r10
    3366:	e3 5e       	subi	r30, 0xE3	; 227
    3368:	fa 4f       	sbci	r31, 0xFA	; 250
    336a:	81 e0       	ldi	r24, 0x01	; 1
    336c:	87 83       	std	Z+7, r24	; 0x07
    336e:	22 c0       	rjmp	.+68     	; 0x33b4 <httpDataIn+0x1e8>
				printfStr(http_auth_password);
				printf("\n\r");
				printf("Received string:");
				printfStrLen(tmpstr,0,20);
				#endif
				HTTPSend(http_pageheader_unauth,sizeof(http_pageheader_unauth)-1,pSession,0);
    3370:	82 e9       	ldi	r24, 0x92	; 146
    3372:	90 e1       	ldi	r25, 0x10	; 16
    3374:	61 e8       	ldi	r22, 0x81	; 129
    3376:	70 e0       	ldi	r23, 0x00	; 0
    3378:	a8 01       	movw	r20, r16
    337a:	20 e0       	ldi	r18, 0x00	; 0
    337c:	0e 94 20 17 	call	0x2e40	; 0x2e40 <HTTPSend>
				HTTPSend(http_pageheader_auth_error,sizeof(http_pageheader_auth_error)-1,pSession,1);
    3380:	84 e1       	ldi	r24, 0x14	; 20
    3382:	91 e1       	ldi	r25, 0x11	; 17
    3384:	64 e1       	ldi	r22, 0x14	; 20
    3386:	70 e0       	ldi	r23, 0x00	; 0
    3388:	a8 01       	movw	r20, r16
    338a:	21 e0       	ldi	r18, 0x01	; 1
    338c:	0e 94 20 17 	call	0x2e40	; 0x2e40 <HTTPSend>
				httpSessionTable[i].status = HTTP_STATUS_IDLE;
    3390:	ce 01       	movw	r24, r28
    3392:	88 0f       	add	r24, r24
    3394:	99 1f       	adc	r25, r25
    3396:	c8 0f       	add	r28, r24
    3398:	d9 1f       	adc	r29, r25
    339a:	fe 01       	movw	r30, r28
    339c:	ee 0f       	add	r30, r30
    339e:	ff 1f       	adc	r31, r31
    33a0:	ee 0f       	add	r30, r30
    33a2:	ff 1f       	adc	r31, r31
    33a4:	ee 0f       	add	r30, r30
    33a6:	ff 1f       	adc	r31, r31
    33a8:	ec 1b       	sub	r30, r28
    33aa:	fd 0b       	sbc	r31, r29
    33ac:	e3 5e       	subi	r30, 0xE3	; 227
    33ae:	fa 4f       	sbci	r31, 0xFA	; 250
    33b0:	10 82       	st	Z, r1
				return;
    33b2:	01 c1       	rjmp	.+514    	; 0x35b6 <httpDataIn+0x3ea>
			}
		}
		//Process for each method
		//If GET method
		if(httpSessionTable[i].rqst.method == HTTP_REQUEST_GET){
    33b4:	ce 01       	movw	r24, r28
    33b6:	88 0f       	add	r24, r24
    33b8:	99 1f       	adc	r25, r25
    33ba:	8c 0f       	add	r24, r28
    33bc:	9d 1f       	adc	r25, r29
    33be:	fc 01       	movw	r30, r24
    33c0:	ee 0f       	add	r30, r30
    33c2:	ff 1f       	adc	r31, r31
    33c4:	ee 0f       	add	r30, r30
    33c6:	ff 1f       	adc	r31, r31
    33c8:	ee 0f       	add	r30, r30
    33ca:	ff 1f       	adc	r31, r31
    33cc:	e8 1b       	sub	r30, r24
    33ce:	f9 0b       	sbc	r31, r25
    33d0:	e3 5e       	subi	r30, 0xE3	; 227
    33d2:	fa 4f       	sbci	r31, 0xFA	; 250
    33d4:	80 85       	ldd	r24, Z+8	; 0x08
    33d6:	81 30       	cpi	r24, 0x01	; 1
    33d8:	09 f0       	breq	.+2      	; 0x33dc <httpDataIn+0x210>
    33da:	55 c0       	rjmp	.+170    	; 0x3486 <httpDataIn+0x2ba>
			printf("GET HEADER:\n\r");
			printfStrLen(httpSessionTable[i].rqst.header,0
					,(httpSessionTable[i].rqst.body - httpSessionTable[i].rqst.header) + httpSessionTable[i].rqst.bodyLen);
			#endif
			//If GET the main website
			if((httpSessionTable[i].rqst.requestURI[0] == '/') && (httpSessionTable[i].rqst.requestURI[1] == ' ')){
    33dc:	ce 01       	movw	r24, r28
    33de:	88 0f       	add	r24, r24
    33e0:	99 1f       	adc	r25, r25
    33e2:	8c 0f       	add	r24, r28
    33e4:	9d 1f       	adc	r25, r29
    33e6:	fc 01       	movw	r30, r24
    33e8:	ee 0f       	add	r30, r30
    33ea:	ff 1f       	adc	r31, r31
    33ec:	ee 0f       	add	r30, r30
    33ee:	ff 1f       	adc	r31, r31
    33f0:	ee 0f       	add	r30, r30
    33f2:	ff 1f       	adc	r31, r31
    33f4:	e8 1b       	sub	r30, r24
    33f6:	f9 0b       	sbc	r31, r25
    33f8:	e3 5e       	subi	r30, 0xE3	; 227
    33fa:	fa 4f       	sbci	r31, 0xFA	; 250
    33fc:	01 84       	ldd	r0, Z+9	; 0x09
    33fe:	f2 85       	ldd	r31, Z+10	; 0x0a
    3400:	e0 2d       	mov	r30, r0
    3402:	80 81       	ld	r24, Z
    3404:	8f 32       	cpi	r24, 0x2F	; 47
    3406:	29 f5       	brne	.+74     	; 0x3452 <httpDataIn+0x286>
    3408:	81 81       	ldd	r24, Z+1	; 0x01
    340a:	80 32       	cpi	r24, 0x20	; 32
    340c:	11 f5       	brne	.+68     	; 0x3452 <httpDataIn+0x286>
				HTTPSend(http_pageheader_ok,sizeof(http_pageheader_ok)-1,pSession,0);
    340e:	8a e3       	ldi	r24, 0x3A	; 58
    3410:	90 e1       	ldi	r25, 0x10	; 16
    3412:	67 e5       	ldi	r22, 0x57	; 87
    3414:	70 e0       	ldi	r23, 0x00	; 0
    3416:	a8 01       	movw	r20, r16
    3418:	20 e0       	ldi	r18, 0x00	; 0
    341a:	0e 94 20 17 	call	0x2e40	; 0x2e40 <HTTPSend>
				HTTPSend(Page1,sizeof(Page1)-1,pSession,1);
    341e:	85 ee       	ldi	r24, 0xE5	; 229
    3420:	91 e0       	ldi	r25, 0x01	; 1
    3422:	66 e4       	ldi	r22, 0x46	; 70
    3424:	7e e0       	ldi	r23, 0x0E	; 14
    3426:	a8 01       	movw	r20, r16
    3428:	21 e0       	ldi	r18, 0x01	; 1
    342a:	0e 94 20 17 	call	0x2e40	; 0x2e40 <HTTPSend>
				httpSessionTable[i].status = HTTP_STATUS_IDLE;
    342e:	ce 01       	movw	r24, r28
    3430:	88 0f       	add	r24, r24
    3432:	99 1f       	adc	r25, r25
    3434:	c8 0f       	add	r28, r24
    3436:	d9 1f       	adc	r29, r25
    3438:	fe 01       	movw	r30, r28
    343a:	ee 0f       	add	r30, r30
    343c:	ff 1f       	adc	r31, r31
    343e:	ee 0f       	add	r30, r30
    3440:	ff 1f       	adc	r31, r31
    3442:	ee 0f       	add	r30, r30
    3444:	ff 1f       	adc	r31, r31
    3446:	ec 1b       	sub	r30, r28
    3448:	fd 0b       	sbc	r31, r29
    344a:	e3 5e       	subi	r30, 0xE3	; 227
    344c:	fa 4f       	sbci	r31, 0xFA	; 250
    344e:	10 82       	st	Z, r1
    3450:	b2 c0       	rjmp	.+356    	; 0x35b6 <httpDataIn+0x3ea>
			//If error
			}else{
				HTTPSend(http_error_notimp,sizeof(http_error_notimp),pSession,1);
    3452:	89 e2       	ldi	r24, 0x29	; 41
    3454:	91 e1       	ldi	r25, 0x11	; 17
    3456:	6a e8       	ldi	r22, 0x8A	; 138
    3458:	70 e0       	ldi	r23, 0x00	; 0
    345a:	a8 01       	movw	r20, r16
    345c:	21 e0       	ldi	r18, 0x01	; 1
    345e:	0e 94 20 17 	call	0x2e40	; 0x2e40 <HTTPSend>
				httpSessionTable[i].status = HTTP_STATUS_IDLE;
    3462:	ce 01       	movw	r24, r28
    3464:	88 0f       	add	r24, r24
    3466:	99 1f       	adc	r25, r25
    3468:	c8 0f       	add	r28, r24
    346a:	d9 1f       	adc	r29, r25
    346c:	fe 01       	movw	r30, r28
    346e:	ee 0f       	add	r30, r30
    3470:	ff 1f       	adc	r31, r31
    3472:	ee 0f       	add	r30, r30
    3474:	ff 1f       	adc	r31, r31
    3476:	ee 0f       	add	r30, r30
    3478:	ff 1f       	adc	r31, r31
    347a:	ec 1b       	sub	r30, r28
    347c:	fd 0b       	sbc	r31, r29
    347e:	e3 5e       	subi	r30, 0xE3	; 227
    3480:	fa 4f       	sbci	r31, 0xFA	; 250
    3482:	10 82       	st	Z, r1
    3484:	98 c0       	rjmp	.+304    	; 0x35b6 <httpDataIn+0x3ea>
			}
			return;
		//If POST method
		}else if(httpSessionTable[i].rqst.method == HTTP_REQUEST_POST){
    3486:	82 30       	cpi	r24, 0x02	; 2
    3488:	09 f0       	breq	.+2      	; 0x348c <httpDataIn+0x2c0>
    348a:	95 c0       	rjmp	.+298    	; 0x35b6 <httpDataIn+0x3ea>

			//Update POST data
			if(findstr(PSTR("SUB=Submit"),buffer,bufferLen) != -1){
    348c:	89 e2       	ldi	r24, 0x29	; 41
    348e:	92 e1       	ldi	r25, 0x12	; 18
    3490:	b7 01       	movw	r22, r14
    3492:	a6 01       	movw	r20, r12
    3494:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <findstr>
    3498:	2f ef       	ldi	r18, 0xFF	; 255
    349a:	8f 3f       	cpi	r24, 0xFF	; 255
    349c:	92 07       	cpc	r25, r18
    349e:	09 f4       	brne	.+2      	; 0x34a2 <httpDataIn+0x2d6>
    34a0:	56 c0       	rjmp	.+172    	; 0x354e <httpDataIn+0x382>
				//Submit
				if(findstr(PSTR("RELAY1=ON"),buffer,bufferLen) != -1)	ON1	else OFF1
    34a2:	8f e1       	ldi	r24, 0x1F	; 31
    34a4:	92 e1       	ldi	r25, 0x12	; 18
    34a6:	b7 01       	movw	r22, r14
    34a8:	a6 01       	movw	r20, r12
    34aa:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <findstr>
    34ae:	2f ef       	ldi	r18, 0xFF	; 255
    34b0:	8f 3f       	cpi	r24, 0xFF	; 255
    34b2:	92 07       	cpc	r25, r18
    34b4:	11 f0       	breq	.+4      	; 0x34ba <httpDataIn+0x2ee>
    34b6:	af 98       	cbi	0x15, 7	; 21
    34b8:	01 c0       	rjmp	.+2      	; 0x34bc <httpDataIn+0x2f0>
    34ba:	af 9a       	sbi	0x15, 7	; 21
				if(findstr(PSTR("RELAY2=ON"),buffer,bufferLen) != -1)	ON2	else OFF2
    34bc:	85 e1       	ldi	r24, 0x15	; 21
    34be:	92 e1       	ldi	r25, 0x12	; 18
    34c0:	b7 01       	movw	r22, r14
    34c2:	a6 01       	movw	r20, r12
    34c4:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <findstr>
    34c8:	2f ef       	ldi	r18, 0xFF	; 255
    34ca:	8f 3f       	cpi	r24, 0xFF	; 255
    34cc:	92 07       	cpc	r25, r18
    34ce:	11 f0       	breq	.+4      	; 0x34d4 <httpDataIn+0x308>
    34d0:	ae 98       	cbi	0x15, 6	; 21
    34d2:	01 c0       	rjmp	.+2      	; 0x34d6 <httpDataIn+0x30a>
    34d4:	ae 9a       	sbi	0x15, 6	; 21
				if(findstr(PSTR("RELAY3=ON"),buffer,bufferLen) != -1)	ON3 else OFF3
    34d6:	8b e0       	ldi	r24, 0x0B	; 11
    34d8:	92 e1       	ldi	r25, 0x12	; 18
    34da:	b7 01       	movw	r22, r14
    34dc:	a6 01       	movw	r20, r12
    34de:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <findstr>
    34e2:	2f ef       	ldi	r18, 0xFF	; 255
    34e4:	8f 3f       	cpi	r24, 0xFF	; 255
    34e6:	92 07       	cpc	r25, r18
    34e8:	11 f0       	breq	.+4      	; 0x34ee <httpDataIn+0x322>
    34ea:	ad 98       	cbi	0x15, 5	; 21
    34ec:	01 c0       	rjmp	.+2      	; 0x34f0 <httpDataIn+0x324>
    34ee:	ad 9a       	sbi	0x15, 5	; 21
				if(findstr(PSTR("RELAY4=ON"),buffer,bufferLen) != -1)	ON4 else OFF4	
    34f0:	81 e0       	ldi	r24, 0x01	; 1
    34f2:	92 e1       	ldi	r25, 0x12	; 18
    34f4:	b7 01       	movw	r22, r14
    34f6:	a6 01       	movw	r20, r12
    34f8:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <findstr>
    34fc:	2f ef       	ldi	r18, 0xFF	; 255
    34fe:	8f 3f       	cpi	r24, 0xFF	; 255
    3500:	92 07       	cpc	r25, r18
    3502:	11 f0       	breq	.+4      	; 0x3508 <httpDataIn+0x33c>
    3504:	ac 98       	cbi	0x15, 4	; 21
    3506:	01 c0       	rjmp	.+2      	; 0x350a <httpDataIn+0x33e>
    3508:	ac 9a       	sbi	0x15, 4	; 21
				
				//Send HTTP data
				HTTPSend(http_pageheader_ok,sizeof(http_pageheader_ok)-1,pSession,0);
    350a:	8a e3       	ldi	r24, 0x3A	; 58
    350c:	90 e1       	ldi	r25, 0x10	; 16
    350e:	67 e5       	ldi	r22, 0x57	; 87
    3510:	70 e0       	ldi	r23, 0x00	; 0
    3512:	a8 01       	movw	r20, r16
    3514:	20 e0       	ldi	r18, 0x00	; 0
    3516:	0e 94 20 17 	call	0x2e40	; 0x2e40 <HTTPSend>
				HTTPSend(Page1,sizeof(Page1)-1,pSession,1);
    351a:	85 ee       	ldi	r24, 0xE5	; 229
    351c:	91 e0       	ldi	r25, 0x01	; 1
    351e:	66 e4       	ldi	r22, 0x46	; 70
    3520:	7e e0       	ldi	r23, 0x0E	; 14
    3522:	a8 01       	movw	r20, r16
    3524:	21 e0       	ldi	r18, 0x01	; 1
    3526:	0e 94 20 17 	call	0x2e40	; 0x2e40 <HTTPSend>
				httpSessionTable[i].status = HTTP_STATUS_IDLE;
    352a:	ce 01       	movw	r24, r28
    352c:	88 0f       	add	r24, r24
    352e:	99 1f       	adc	r25, r25
    3530:	c8 0f       	add	r28, r24
    3532:	d9 1f       	adc	r29, r25
    3534:	fe 01       	movw	r30, r28
    3536:	ee 0f       	add	r30, r30
    3538:	ff 1f       	adc	r31, r31
    353a:	ee 0f       	add	r30, r30
    353c:	ff 1f       	adc	r31, r31
    353e:	ee 0f       	add	r30, r30
    3540:	ff 1f       	adc	r31, r31
    3542:	ec 1b       	sub	r30, r28
    3544:	fd 0b       	sbc	r31, r29
    3546:	e3 5e       	subi	r30, 0xE3	; 227
    3548:	fa 4f       	sbci	r31, 0xFA	; 250
    354a:	10 82       	st	Z, r1
				return;
    354c:	34 c0       	rjmp	.+104    	; 0x35b6 <httpDataIn+0x3ea>
			}else if(findstr(PSTR("APPLY=Apply"),buffer,bufferLen) != -1){
    354e:	85 ef       	ldi	r24, 0xF5	; 245
    3550:	91 e1       	ldi	r25, 0x11	; 17
    3552:	b7 01       	movw	r22, r14
    3554:	a6 01       	movw	r20, r12
    3556:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <findstr>
    355a:	2f ef       	ldi	r18, 0xFF	; 255
    355c:	8f 3f       	cpi	r24, 0xFF	; 255
    355e:	92 07       	cpc	r25, r18
    3560:	11 f1       	breq	.+68     	; 0x35a6 <httpDataIn+0x3da>
				HTTPSend(http_pageheader_ok,sizeof(http_pageheader_ok)-1,pSession,0);
    3562:	8a e3       	ldi	r24, 0x3A	; 58
    3564:	90 e1       	ldi	r25, 0x10	; 16
    3566:	67 e5       	ldi	r22, 0x57	; 87
    3568:	70 e0       	ldi	r23, 0x00	; 0
    356a:	a8 01       	movw	r20, r16
    356c:	20 e0       	ldi	r18, 0x00	; 0
    356e:	0e 94 20 17 	call	0x2e40	; 0x2e40 <HTTPSend>
				HTTPSend(Page1,sizeof(Page1)-1,pSession,1);
    3572:	85 ee       	ldi	r24, 0xE5	; 229
    3574:	91 e0       	ldi	r25, 0x01	; 1
    3576:	66 e4       	ldi	r22, 0x46	; 70
    3578:	7e e0       	ldi	r23, 0x0E	; 14
    357a:	a8 01       	movw	r20, r16
    357c:	21 e0       	ldi	r18, 0x01	; 1
    357e:	0e 94 20 17 	call	0x2e40	; 0x2e40 <HTTPSend>
				httpSessionTable[i].status = HTTP_STATUS_IDLE;
    3582:	ce 01       	movw	r24, r28
    3584:	88 0f       	add	r24, r24
    3586:	99 1f       	adc	r25, r25
    3588:	c8 0f       	add	r28, r24
    358a:	d9 1f       	adc	r29, r25
    358c:	fe 01       	movw	r30, r28
    358e:	ee 0f       	add	r30, r30
    3590:	ff 1f       	adc	r31, r31
    3592:	ee 0f       	add	r30, r30
    3594:	ff 1f       	adc	r31, r31
    3596:	ee 0f       	add	r30, r30
    3598:	ff 1f       	adc	r31, r31
    359a:	ec 1b       	sub	r30, r28
    359c:	fd 0b       	sbc	r31, r29
    359e:	e3 5e       	subi	r30, 0xE3	; 227
    35a0:	fa 4f       	sbci	r31, 0xFA	; 250
    35a2:	10 82       	st	Z, r1
    35a4:	08 c0       	rjmp	.+16     	; 0x35b6 <httpDataIn+0x3ea>
			}else{
				HTTPSend("",0,pSession,0);
    35a6:	8b e6       	ldi	r24, 0x6B	; 107
    35a8:	90 e0       	ldi	r25, 0x00	; 0
    35aa:	60 e0       	ldi	r22, 0x00	; 0
    35ac:	70 e0       	ldi	r23, 0x00	; 0
    35ae:	a8 01       	movw	r20, r16
    35b0:	20 e0       	ldi	r18, 0x00	; 0
    35b2:	0e 94 20 17 	call	0x2e40	; 0x2e40 <HTTPSend>
			}
		}
	}
}
    35b6:	df 91       	pop	r29
    35b8:	cf 91       	pop	r28
    35ba:	1f 91       	pop	r17
    35bc:	0f 91       	pop	r16
    35be:	ff 90       	pop	r15
    35c0:	ef 90       	pop	r14
    35c2:	df 90       	pop	r13
    35c4:	cf 90       	pop	r12
    35c6:	bf 90       	pop	r11
    35c8:	af 90       	pop	r10
    35ca:	08 95       	ret

000035cc <icmpEchoReply>:
#include "ip.h"
#include "icmp.h"
//--------------------------------------------------------------------------------------
//Ham gui di ban tin tra loi cho Echo Request (Echo Reply)
void icmpEchoReply(struct ntIPHeader* ipHeader)
{
    35cc:	0f 93       	push	r16
    35ce:	1f 93       	push	r17
    35d0:	cf 93       	push	r28
    35d2:	df 93       	push	r29
    35d4:	ec 01       	movw	r28, r24
	unsigned long tempIp;
	unsigned char* ethFrame;
	struct ntICMPHeader* icmpHeader;
	icmpHeader = (struct ntICMPHeader*)((unsigned char*)ipHeader + IP_HEADER_LEN);
    35d6:	8c 01       	movw	r16, r24
    35d8:	0c 5e       	subi	r16, 0xEC	; 236
    35da:	1f 4f       	sbci	r17, 0xFF	; 255
	icmpHeader->Type = ICMP_TYPE_ECHOREPLY;
    35dc:	1c 8a       	std	Y+20, r1	; 0x14
	icmpHeader->Checksum = 0;
    35de:	f8 01       	movw	r30, r16
    35e0:	13 82       	std	Z+3, r1	; 0x03
    35e2:	12 82       	std	Z+2, r1	; 0x02
	icmpHeader->Checksum = ipChecksum((unsigned char*)icmpHeader, HTONS(ipHeader->Len)-IP_HEADER_LEN);
    35e4:	6a 81       	ldd	r22, Y+2	; 0x02
    35e6:	7b 81       	ldd	r23, Y+3	; 0x03
    35e8:	76 27       	eor	r23, r22
    35ea:	67 27       	eor	r22, r23
    35ec:	76 27       	eor	r23, r22
    35ee:	64 51       	subi	r22, 0x14	; 20
    35f0:	70 40       	sbci	r23, 0x00	; 0
    35f2:	c8 01       	movw	r24, r16
    35f4:	0e 94 2d 1b 	call	0x365a	; 0x365a <ipChecksum>
    35f8:	f8 01       	movw	r30, r16
    35fa:	93 83       	std	Z+3, r25	; 0x03
    35fc:	82 83       	std	Z+2, r24	; 0x02
	tempIp = ipHeader->desIPAddr;
    35fe:	88 89       	ldd	r24, Y+16	; 0x10
    3600:	99 89       	ldd	r25, Y+17	; 0x11
    3602:	aa 89       	ldd	r26, Y+18	; 0x12
    3604:	bb 89       	ldd	r27, Y+19	; 0x13
	ipHeader->desIPAddr = ipHeader->srcIPAddr;
    3606:	2c 85       	ldd	r18, Y+12	; 0x0c
    3608:	3d 85       	ldd	r19, Y+13	; 0x0d
    360a:	4e 85       	ldd	r20, Y+14	; 0x0e
    360c:	5f 85       	ldd	r21, Y+15	; 0x0f
    360e:	28 8b       	std	Y+16, r18	; 0x10
    3610:	39 8b       	std	Y+17, r19	; 0x11
    3612:	4a 8b       	std	Y+18, r20	; 0x12
    3614:	5b 8b       	std	Y+19, r21	; 0x13
	ipHeader->srcIPAddr = tempIp;
    3616:	8c 87       	std	Y+12, r24	; 0x0c
    3618:	9d 87       	std	Y+13, r25	; 0x0d
    361a:	ae 87       	std	Y+14, r26	; 0x0e
    361c:	bf 87       	std	Y+15, r27	; 0x0f
	ethFrame = ((unsigned char*)ipHeader);
	ethFrame -= ETH_HEADER_LEN;
    361e:	8e 01       	movw	r16, r28
    3620:	0e 50       	subi	r16, 0x0E	; 14
    3622:	10 40       	sbci	r17, 0x00	; 0
	arpIpOut(ethFrame, 0);
    3624:	c8 01       	movw	r24, r16
    3626:	40 e0       	ldi	r20, 0x00	; 0
    3628:	50 e0       	ldi	r21, 0x00	; 0
    362a:	ba 01       	movw	r22, r20
    362c:	0e 94 27 0c 	call	0x184e	; 0x184e <arpIpOut>
	#ifdef ICMP_DEBUG
	icmpPrintHeader(ipHeader);
	#endif
	ethSendFrame(HTONS(ipHeader->Len)+ETH_HEADER_LEN, ethFrame);
    3630:	8a 81       	ldd	r24, Y+2	; 0x02
    3632:	9b 81       	ldd	r25, Y+3	; 0x03
    3634:	98 27       	eor	r25, r24
    3636:	89 27       	eor	r24, r25
    3638:	98 27       	eor	r25, r24
    363a:	0e 96       	adiw	r24, 0x0e	; 14
    363c:	b8 01       	movw	r22, r16
    363e:	0e 94 ec 14 	call	0x29d8	; 0x29d8 <ethSendFrame>
}
    3642:	df 91       	pop	r29
    3644:	cf 91       	pop	r28
    3646:	1f 91       	pop	r17
    3648:	0f 91       	pop	r16
    364a:	08 95       	ret

0000364c <icmpIpIn>:
void icmpIpIn(struct ntIPHeader* ipHeader)
{
	struct ntICMPHeader* icmpHeader;
	icmpHeader = (struct ntICMPHeader*)((unsigned char*)ipHeader + IP_HEADER_LEN);
	// check ICMP type
	switch(icmpHeader->Type)
    364c:	fc 01       	movw	r30, r24
    364e:	24 89       	ldd	r18, Z+20	; 0x14
    3650:	28 30       	cpi	r18, 0x08	; 8
    3652:	11 f4       	brne	.+4      	; 0x3658 <icmpIpIn+0xc>
	{
	case ICMP_TYPE_ECHOREQUEST:
		// echo request
		icmpEchoReply(ipHeader);
    3654:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <icmpEchoReply>
    3658:	08 95       	ret

0000365a <ipChecksum>:
//--------------------------------------------------------------------------------------
struct ipConfig IpMyConfig;	///< Local IP address/config structure
//--------------------------------------------------------------------------------------
//Ham tinh checksum cho goi ip
unsigned int ipChecksum(unsigned char *data, unsigned int len)
{
    365a:	0f 93       	push	r16
    365c:	1f 93       	push	r17
    365e:	cf 93       	push	r28
    3660:	df 93       	push	r29
    3662:	8c 01       	movw	r16, r24
    register unsigned long sum = 0;

    for (;;) {
        if (len < 2)
    3664:	62 30       	cpi	r22, 0x02	; 2
    3666:	71 05       	cpc	r23, r1
    3668:	e0 f0       	brcs	.+56     	; 0x36a2 <ipChecksum+0x48>
    366a:	fb 01       	movw	r30, r22
    366c:	ec 01       	movw	r28, r24
struct ipConfig IpMyConfig;	///< Local IP address/config structure
//--------------------------------------------------------------------------------------
//Ham tinh checksum cho goi ip
unsigned int ipChecksum(unsigned char *data, unsigned int len)
{
    register unsigned long sum = 0;
    366e:	80 e0       	ldi	r24, 0x00	; 0
    3670:	90 e0       	ldi	r25, 0x00	; 0
    3672:	dc 01       	movw	r26, r24

    for (;;) {
        if (len < 2)
            break;
		sum += *((unsigned int *)data);
    3674:	29 91       	ld	r18, Y+
    3676:	39 91       	ld	r19, Y+
    3678:	40 e0       	ldi	r20, 0x00	; 0
    367a:	50 e0       	ldi	r21, 0x00	; 0
    367c:	82 0f       	add	r24, r18
    367e:	93 1f       	adc	r25, r19
    3680:	a4 1f       	adc	r26, r20
    3682:	b5 1f       	adc	r27, r21
		data+=2;
        len -= 2;
    3684:	32 97       	sbiw	r30, 0x02	; 2
unsigned int ipChecksum(unsigned char *data, unsigned int len)
{
    register unsigned long sum = 0;

    for (;;) {
        if (len < 2)
    3686:	e2 30       	cpi	r30, 0x02	; 2
    3688:	f1 05       	cpc	r31, r1
    368a:	a0 f7       	brcc	.-24     	; 0x3674 <ipChecksum+0x1a>
#include "uart.h"
//--------------------------------------------------------------------------------------
struct ipConfig IpMyConfig;	///< Local IP address/config structure
//--------------------------------------------------------------------------------------
//Ham tinh checksum cho goi ip
unsigned int ipChecksum(unsigned char *data, unsigned int len)
    368c:	62 50       	subi	r22, 0x02	; 2
    368e:	70 40       	sbci	r23, 0x00	; 0
    3690:	9b 01       	movw	r18, r22
    3692:	2e 7f       	andi	r18, 0xFE	; 254
    3694:	2e 5f       	subi	r18, 0xFE	; 254
    3696:	3f 4f       	sbci	r19, 0xFF	; 255
    3698:	02 0f       	add	r16, r18
    369a:	13 1f       	adc	r17, r19
    369c:	61 70       	andi	r22, 0x01	; 1
    369e:	70 70       	andi	r23, 0x00	; 0
    36a0:	03 c0       	rjmp	.+6      	; 0x36a8 <ipChecksum+0x4e>
{
    register unsigned long sum = 0;
    36a2:	80 e0       	ldi	r24, 0x00	; 0
    36a4:	90 e0       	ldi	r25, 0x00	; 0
    36a6:	dc 01       	movw	r26, r24
            break;
		sum += *((unsigned int *)data);
		data+=2;
        len -= 2;
    }
    if (len)
    36a8:	61 15       	cp	r22, r1
    36aa:	71 05       	cpc	r23, r1
    36ac:	31 f0       	breq	.+12     	; 0x36ba <ipChecksum+0x60>
        sum += *(unsigned char *) data;
    36ae:	f8 01       	movw	r30, r16
    36b0:	20 81       	ld	r18, Z
    36b2:	82 0f       	add	r24, r18
    36b4:	91 1d       	adc	r25, r1
    36b6:	a1 1d       	adc	r26, r1
    36b8:	b1 1d       	adc	r27, r1

    while ((len = (unsigned int) (sum >> 16)) != 0)
    36ba:	9d 01       	movw	r18, r26
    36bc:	10 97       	sbiw	r26, 0x00	; 0
    36be:	39 f0       	breq	.+14     	; 0x36ce <ipChecksum+0x74>
        sum = (unsigned int) sum + len;
    36c0:	82 0f       	add	r24, r18
    36c2:	93 1f       	adc	r25, r19
    36c4:	a0 e0       	ldi	r26, 0x00	; 0
    36c6:	b0 e0       	ldi	r27, 0x00	; 0
        len -= 2;
    }
    if (len)
        sum += *(unsigned char *) data;

    while ((len = (unsigned int) (sum >> 16)) != 0)
    36c8:	9d 01       	movw	r18, r26
    36ca:	10 97       	sbiw	r26, 0x00	; 0
    36cc:	c9 f7       	brne	.-14     	; 0x36c0 <ipChecksum+0x66>
        sum = (unsigned int) sum + len;

    return (unsigned int) sum ^ 0xFFFF;
    36ce:	9c 01       	movw	r18, r24
    36d0:	20 95       	com	r18
    36d2:	30 95       	com	r19
}
    36d4:	82 2f       	mov	r24, r18
    36d6:	93 2f       	mov	r25, r19
    36d8:	df 91       	pop	r29
    36da:	cf 91       	pop	r28
    36dc:	1f 91       	pop	r17
    36de:	0f 91       	pop	r16
    36e0:	08 95       	ret

000036e2 <ipSetConfig>:
//--------------------------------------------------------------------------------------
//Set cac gia tri cau hinh cho giao thuc ip
void ipSetConfig(unsigned long myIp, unsigned long netmask, unsigned long gatewayIp)
{
    36e2:	af 92       	push	r10
    36e4:	bf 92       	push	r11
    36e6:	cf 92       	push	r12
    36e8:	df 92       	push	r13
    36ea:	ef 92       	push	r14
    36ec:	ff 92       	push	r15
    36ee:	0f 93       	push	r16
    36f0:	1f 93       	push	r17
    36f2:	df 93       	push	r29
    36f4:	cf 93       	push	r28
    36f6:	00 d0       	rcall	.+0      	; 0x36f8 <ipSetConfig+0x16>
    36f8:	00 d0       	rcall	.+0      	; 0x36fa <ipSetConfig+0x18>
    36fa:	00 d0       	rcall	.+0      	; 0x36fc <ipSetConfig+0x1a>
    36fc:	cd b7       	in	r28, 0x3d	; 61
    36fe:	de b7       	in	r29, 0x3e	; 62
    3700:	5b 01       	movw	r10, r22
    3702:	6c 01       	movw	r12, r24
	ethGetMacAddress(IpMyConfig.ethaddr.addr);
	*/
	struct ntEthAddr ethaddr;

	// set local addressing
	IpMyConfig.ip = myIp;
    3704:	60 93 d9 05 	sts	0x05D9, r22
    3708:	70 93 da 05 	sts	0x05DA, r23
    370c:	80 93 db 05 	sts	0x05DB, r24
    3710:	90 93 dc 05 	sts	0x05DC, r25
	IpMyConfig.netmask = netmask;
    3714:	20 93 dd 05 	sts	0x05DD, r18
    3718:	30 93 de 05 	sts	0x05DE, r19
    371c:	40 93 df 05 	sts	0x05DF, r20
    3720:	50 93 e0 05 	sts	0x05E0, r21
	IpMyConfig.gateway = gatewayIp;
    3724:	e0 92 e1 05 	sts	0x05E1, r14
    3728:	f0 92 e2 05 	sts	0x05E2, r15
    372c:	00 93 e3 05 	sts	0x05E3, r16
    3730:	10 93 e4 05 	sts	0x05E4, r17

	// set ARP association
	ethGetMacAddress(ethaddr.addr);
    3734:	8e 01       	movw	r16, r28
    3736:	0f 5f       	subi	r16, 0xFF	; 255
    3738:	1f 4f       	sbci	r17, 0xFF	; 255
    373a:	c8 01       	movw	r24, r16
    373c:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <ethGetMacAddress>
	arpSetAddress(&ethaddr, myIp);
    3740:	c8 01       	movw	r24, r16
    3742:	b6 01       	movw	r22, r12
    3744:	a5 01       	movw	r20, r10
    3746:	0e 94 ed 09 	call	0x13da	; 0x13da <arpSetAddress>

}
    374a:	26 96       	adiw	r28, 0x06	; 6
    374c:	0f b6       	in	r0, 0x3f	; 63
    374e:	f8 94       	cli
    3750:	de bf       	out	0x3e, r29	; 62
    3752:	0f be       	out	0x3f, r0	; 63
    3754:	cd bf       	out	0x3d, r28	; 61
    3756:	cf 91       	pop	r28
    3758:	df 91       	pop	r29
    375a:	1f 91       	pop	r17
    375c:	0f 91       	pop	r16
    375e:	ff 90       	pop	r15
    3760:	ef 90       	pop	r14
    3762:	df 90       	pop	r13
    3764:	cf 90       	pop	r12
    3766:	bf 90       	pop	r11
    3768:	af 90       	pop	r10
    376a:	08 95       	ret

0000376c <ipGetConfig>:
//--------------------------------------------------------------------------------------
//Tra lai con tro den struct ipConfig
struct ipConfig* ipGetConfig(void)
{
	return &IpMyConfig;
}
    376c:	89 ed       	ldi	r24, 0xD9	; 217
    376e:	95 e0       	ldi	r25, 0x05	; 5
    3770:	08 95       	ret

00003772 <ethPrintAddr>:
//--------------------------------------------------------------------------------------
//In ra dia chi ethernet
void ethPrintAddr(struct ntEthAddr* ethAddr)
{
    3772:	cf 93       	push	r28
    3774:	df 93       	push	r29
    3776:	dc 01       	movw	r26, r24
	printf("%x:%x:%x:%x:%x:%x",(ethAddr->addr[0]),(ethAddr->addr[1]),(ethAddr->addr[2]),\
    3778:	8d b7       	in	r24, 0x3d	; 61
    377a:	9e b7       	in	r25, 0x3e	; 62
    377c:	0e 97       	sbiw	r24, 0x0e	; 14
    377e:	0f b6       	in	r0, 0x3f	; 63
    3780:	f8 94       	cli
    3782:	9e bf       	out	0x3e, r25	; 62
    3784:	0f be       	out	0x3f, r0	; 63
    3786:	8d bf       	out	0x3d, r24	; 61
    3788:	ed b7       	in	r30, 0x3d	; 61
    378a:	fe b7       	in	r31, 0x3e	; 62
    378c:	31 96       	adiw	r30, 0x01	; 1
    378e:	8f e8       	ldi	r24, 0x8F	; 143
    3790:	92 e1       	ldi	r25, 0x12	; 18
    3792:	cd b7       	in	r28, 0x3d	; 61
    3794:	de b7       	in	r29, 0x3e	; 62
    3796:	9a 83       	std	Y+2, r25	; 0x02
    3798:	89 83       	std	Y+1, r24	; 0x01
    379a:	8c 91       	ld	r24, X
    379c:	82 83       	std	Z+2, r24	; 0x02
    379e:	13 82       	std	Z+3, r1	; 0x03
    37a0:	11 96       	adiw	r26, 0x01	; 1
    37a2:	8c 91       	ld	r24, X
    37a4:	11 97       	sbiw	r26, 0x01	; 1
    37a6:	84 83       	std	Z+4, r24	; 0x04
    37a8:	15 82       	std	Z+5, r1	; 0x05
    37aa:	12 96       	adiw	r26, 0x02	; 2
    37ac:	8c 91       	ld	r24, X
    37ae:	12 97       	sbiw	r26, 0x02	; 2
    37b0:	86 83       	std	Z+6, r24	; 0x06
    37b2:	17 82       	std	Z+7, r1	; 0x07
    37b4:	13 96       	adiw	r26, 0x03	; 3
    37b6:	8c 91       	ld	r24, X
    37b8:	13 97       	sbiw	r26, 0x03	; 3
    37ba:	80 87       	std	Z+8, r24	; 0x08
    37bc:	11 86       	std	Z+9, r1	; 0x09
    37be:	14 96       	adiw	r26, 0x04	; 4
    37c0:	8c 91       	ld	r24, X
    37c2:	14 97       	sbiw	r26, 0x04	; 4
    37c4:	82 87       	std	Z+10, r24	; 0x0a
    37c6:	13 86       	std	Z+11, r1	; 0x0b
    37c8:	15 96       	adiw	r26, 0x05	; 5
    37ca:	8c 91       	ld	r24, X
    37cc:	84 87       	std	Z+12, r24	; 0x0c
    37ce:	15 86       	std	Z+13, r1	; 0x0d
    37d0:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    37d4:	8d b7       	in	r24, 0x3d	; 61
    37d6:	9e b7       	in	r25, 0x3e	; 62
    37d8:	0e 96       	adiw	r24, 0x0e	; 14
    37da:	0f b6       	in	r0, 0x3f	; 63
    37dc:	f8 94       	cli
    37de:	9e bf       	out	0x3e, r25	; 62
    37e0:	0f be       	out	0x3f, r0	; 63
    37e2:	8d bf       	out	0x3d, r24	; 61
		(ethAddr->addr[3]),(ethAddr->addr[4]),(ethAddr->addr[5]));
}
    37e4:	df 91       	pop	r29
    37e6:	cf 91       	pop	r28
    37e8:	08 95       	ret

000037ea <ipPrintAddr>:
//--------------------------------------------------------------------------------------
//In ra dia chi IP
void ipPrintAddr(unsigned long ipaddr)
{
    37ea:	df 93       	push	r29
    37ec:	cf 93       	push	r28
    37ee:	00 d0       	rcall	.+0      	; 0x37f0 <ipPrintAddr+0x6>
    37f0:	00 d0       	rcall	.+0      	; 0x37f2 <ipPrintAddr+0x8>
    37f2:	cd b7       	in	r28, 0x3d	; 61
    37f4:	de b7       	in	r29, 0x3e	; 62
    37f6:	69 83       	std	Y+1, r22	; 0x01
    37f8:	7a 83       	std	Y+2, r23	; 0x02
    37fa:	8b 83       	std	Y+3, r24	; 0x03
    37fc:	9c 83       	std	Y+4, r25	; 0x04
	printf("%d.%d.%d.%d",
    37fe:	9e 01       	movw	r18, r28
    3800:	2f 5f       	subi	r18, 0xFF	; 255
    3802:	3f 4f       	sbci	r19, 0xFF	; 255
    3804:	8d b7       	in	r24, 0x3d	; 61
    3806:	9e b7       	in	r25, 0x3e	; 62
    3808:	0a 97       	sbiw	r24, 0x0a	; 10
    380a:	0f b6       	in	r0, 0x3f	; 63
    380c:	f8 94       	cli
    380e:	9e bf       	out	0x3e, r25	; 62
    3810:	0f be       	out	0x3f, r0	; 63
    3812:	8d bf       	out	0x3d, r24	; 61
    3814:	ed b7       	in	r30, 0x3d	; 61
    3816:	fe b7       	in	r31, 0x3e	; 62
    3818:	31 96       	adiw	r30, 0x01	; 1
    381a:	83 e8       	ldi	r24, 0x83	; 131
    381c:	92 e1       	ldi	r25, 0x12	; 18
    381e:	ad b7       	in	r26, 0x3d	; 61
    3820:	be b7       	in	r27, 0x3e	; 62
    3822:	12 96       	adiw	r26, 0x02	; 2
    3824:	9c 93       	st	X, r25
    3826:	8e 93       	st	-X, r24
    3828:	11 97       	sbiw	r26, 0x01	; 1
    382a:	d9 01       	movw	r26, r18
    382c:	13 96       	adiw	r26, 0x03	; 3
    382e:	8c 91       	ld	r24, X
    3830:	13 97       	sbiw	r26, 0x03	; 3
    3832:	82 83       	std	Z+2, r24	; 0x02
    3834:	13 82       	std	Z+3, r1	; 0x03
    3836:	12 96       	adiw	r26, 0x02	; 2
    3838:	8c 91       	ld	r24, X
    383a:	12 97       	sbiw	r26, 0x02	; 2
    383c:	84 83       	std	Z+4, r24	; 0x04
    383e:	15 82       	std	Z+5, r1	; 0x05
    3840:	11 96       	adiw	r26, 0x01	; 1
    3842:	8c 91       	ld	r24, X
    3844:	86 83       	std	Z+6, r24	; 0x06
    3846:	17 82       	std	Z+7, r1	; 0x07
    3848:	89 81       	ldd	r24, Y+1	; 0x01
    384a:	80 87       	std	Z+8, r24	; 0x08
    384c:	11 86       	std	Z+9, r1	; 0x09
    384e:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    3852:	8d b7       	in	r24, 0x3d	; 61
    3854:	9e b7       	in	r25, 0x3e	; 62
    3856:	0a 96       	adiw	r24, 0x0a	; 10
    3858:	0f b6       	in	r0, 0x3f	; 63
    385a:	f8 94       	cli
    385c:	9e bf       	out	0x3e, r25	; 62
    385e:	0f be       	out	0x3f, r0	; 63
    3860:	8d bf       	out	0x3d, r24	; 61
		((unsigned char*)&ipaddr)[3],
		((unsigned char*)&ipaddr)[2],
		((unsigned char*)&ipaddr)[1],
		((unsigned char*)&ipaddr)[0]);
}
    3862:	0f 90       	pop	r0
    3864:	0f 90       	pop	r0
    3866:	0f 90       	pop	r0
    3868:	0f 90       	pop	r0
    386a:	cf 91       	pop	r28
    386c:	df 91       	pop	r29
    386e:	08 95       	ret

00003870 <ipPrintConfig>:
//--------------------------------------------------------------------------------------
//In ra cac gia tri cau hinh cho giao thuc IP
void ipPrintConfig(struct ipConfig* config)
{
    3870:	cf 93       	push	r28
    3872:	df 93       	push	r29
    3874:	ec 01       	movw	r28, r24
	printf("IP Addr : "); ipPrintAddr(config->ip);		printf("\n\r");
    3876:	00 d0       	rcall	.+0      	; 0x3878 <ipPrintConfig+0x8>
    3878:	88 e7       	ldi	r24, 0x78	; 120
    387a:	92 e1       	ldi	r25, 0x12	; 18
    387c:	ed b7       	in	r30, 0x3d	; 61
    387e:	fe b7       	in	r31, 0x3e	; 62
    3880:	92 83       	std	Z+2, r25	; 0x02
    3882:	81 83       	std	Z+1, r24	; 0x01
    3884:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    3888:	0f 90       	pop	r0
    388a:	0f 90       	pop	r0
    388c:	68 81       	ld	r22, Y
    388e:	79 81       	ldd	r23, Y+1	; 0x01
    3890:	8a 81       	ldd	r24, Y+2	; 0x02
    3892:	9b 81       	ldd	r25, Y+3	; 0x03
    3894:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <ipPrintAddr>
    3898:	00 d0       	rcall	.+0      	; 0x389a <ipPrintConfig+0x2a>
    389a:	85 e7       	ldi	r24, 0x75	; 117
    389c:	92 e1       	ldi	r25, 0x12	; 18
    389e:	ed b7       	in	r30, 0x3d	; 61
    38a0:	fe b7       	in	r31, 0x3e	; 62
    38a2:	92 83       	std	Z+2, r25	; 0x02
    38a4:	81 83       	std	Z+1, r24	; 0x01
    38a6:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	printf("Netmask : "); ipPrintAddr(config->netmask);	printf("\n\r");
    38aa:	8a e6       	ldi	r24, 0x6A	; 106
    38ac:	92 e1       	ldi	r25, 0x12	; 18
    38ae:	ed b7       	in	r30, 0x3d	; 61
    38b0:	fe b7       	in	r31, 0x3e	; 62
    38b2:	92 83       	std	Z+2, r25	; 0x02
    38b4:	81 83       	std	Z+1, r24	; 0x01
    38b6:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    38ba:	0f 90       	pop	r0
    38bc:	0f 90       	pop	r0
    38be:	6c 81       	ldd	r22, Y+4	; 0x04
    38c0:	7d 81       	ldd	r23, Y+5	; 0x05
    38c2:	8e 81       	ldd	r24, Y+6	; 0x06
    38c4:	9f 81       	ldd	r25, Y+7	; 0x07
    38c6:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <ipPrintAddr>
    38ca:	00 d0       	rcall	.+0      	; 0x38cc <ipPrintConfig+0x5c>
    38cc:	87 e6       	ldi	r24, 0x67	; 103
    38ce:	92 e1       	ldi	r25, 0x12	; 18
    38d0:	ed b7       	in	r30, 0x3d	; 61
    38d2:	fe b7       	in	r31, 0x3e	; 62
    38d4:	92 83       	std	Z+2, r25	; 0x02
    38d6:	81 83       	std	Z+1, r24	; 0x01
    38d8:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	printf("Gateway : "); ipPrintAddr(config->gateway);	printf("\n\r");
    38dc:	8c e5       	ldi	r24, 0x5C	; 92
    38de:	92 e1       	ldi	r25, 0x12	; 18
    38e0:	ed b7       	in	r30, 0x3d	; 61
    38e2:	fe b7       	in	r31, 0x3e	; 62
    38e4:	92 83       	std	Z+2, r25	; 0x02
    38e6:	81 83       	std	Z+1, r24	; 0x01
    38e8:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    38ec:	0f 90       	pop	r0
    38ee:	0f 90       	pop	r0
    38f0:	68 85       	ldd	r22, Y+8	; 0x08
    38f2:	79 85       	ldd	r23, Y+9	; 0x09
    38f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    38f6:	9b 85       	ldd	r25, Y+11	; 0x0b
    38f8:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <ipPrintAddr>
    38fc:	00 d0       	rcall	.+0      	; 0x38fe <ipPrintConfig+0x8e>
    38fe:	89 e5       	ldi	r24, 0x59	; 89
    3900:	92 e1       	ldi	r25, 0x12	; 18
    3902:	ed b7       	in	r30, 0x3d	; 61
    3904:	fe b7       	in	r31, 0x3e	; 62
    3906:	92 83       	std	Z+2, r25	; 0x02
    3908:	81 83       	std	Z+1, r24	; 0x01
    390a:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    390e:	0f 90       	pop	r0
    3910:	0f 90       	pop	r0
}
    3912:	df 91       	pop	r29
    3914:	cf 91       	pop	r28
    3916:	08 95       	ret

00003918 <ipSend>:
//--------------------------------------------------------------------------------------
//Ham gui 1 goi IP
void ipSend(unsigned long dstIp, unsigned char protocol, unsigned int len, unsigned char* ipData)
{
    3918:	6f 92       	push	r6
    391a:	7f 92       	push	r7
    391c:	8f 92       	push	r8
    391e:	9f 92       	push	r9
    3920:	af 92       	push	r10
    3922:	bf 92       	push	r11
    3924:	cf 92       	push	r12
    3926:	df 92       	push	r13
    3928:	ef 92       	push	r14
    392a:	ff 92       	push	r15
    392c:	0f 93       	push	r16
    392e:	1f 93       	push	r17
    3930:	cf 93       	push	r28
    3932:	df 93       	push	r29
    3934:	5b 01       	movw	r10, r22
    3936:	6c 01       	movw	r12, r24
    3938:	e4 2f       	mov	r30, r20
	struct ntEthHeader* ethHeader;
	struct ntIPHeader* ipHeader;
	ipHeader = (struct ntIPHeader*)(ipData - IP_HEADER_LEN);
    393a:	e8 01       	movw	r28, r16
    393c:	64 97       	sbiw	r28, 0x14	; 20
	ethHeader = (struct ntEthHeader*)(ipData - IP_HEADER_LEN - ETH_HEADER_LEN);
    393e:	0f 2e       	mov	r0, r31
    3940:	fe ed       	ldi	r31, 0xDE	; 222
    3942:	8f 2e       	mov	r8, r31
    3944:	ff ef       	ldi	r31, 0xFF	; 255
    3946:	9f 2e       	mov	r9, r31
    3948:	f0 2d       	mov	r31, r0
    394a:	80 0e       	add	r8, r16
    394c:	91 1e       	adc	r9, r17
	len += IP_HEADER_LEN;
    394e:	0f 2e       	mov	r0, r31
    3950:	f4 e1       	ldi	r31, 0x14	; 20
    3952:	6f 2e       	mov	r6, r31
    3954:	77 24       	eor	r7, r7
    3956:	f0 2d       	mov	r31, r0
    3958:	62 0e       	add	r6, r18
    395a:	73 1e       	adc	r7, r19

	ipHeader->desIPAddr = HTONL(dstIp);
    395c:	29 2f       	mov	r18, r25
    395e:	33 27       	eor	r19, r19
    3960:	44 27       	eor	r20, r20
    3962:	55 27       	eor	r21, r21
    3964:	b6 2f       	mov	r27, r22
    3966:	aa 27       	eor	r26, r26
    3968:	99 27       	eor	r25, r25
    396a:	88 27       	eor	r24, r24
    396c:	82 2b       	or	r24, r18
    396e:	93 2b       	or	r25, r19
    3970:	a4 2b       	or	r26, r20
    3972:	b5 2b       	or	r27, r21
    3974:	b6 01       	movw	r22, r12
    3976:	a5 01       	movw	r20, r10
    3978:	40 70       	andi	r20, 0x00	; 0
    397a:	50 70       	andi	r21, 0x00	; 0
    397c:	70 70       	andi	r23, 0x00	; 0
    397e:	45 2f       	mov	r20, r21
    3980:	56 2f       	mov	r21, r22
    3982:	67 2f       	mov	r22, r23
    3984:	77 27       	eor	r23, r23
    3986:	9a 01       	movw	r18, r20
    3988:	ab 01       	movw	r20, r22
    398a:	28 2b       	or	r18, r24
    398c:	39 2b       	or	r19, r25
    398e:	4a 2b       	or	r20, r26
    3990:	5b 2b       	or	r21, r27
    3992:	d6 01       	movw	r26, r12
    3994:	c5 01       	movw	r24, r10
    3996:	80 70       	andi	r24, 0x00	; 0
    3998:	a0 70       	andi	r26, 0x00	; 0
    399a:	b0 70       	andi	r27, 0x00	; 0
    399c:	ba 2f       	mov	r27, r26
    399e:	a9 2f       	mov	r26, r25
    39a0:	98 2f       	mov	r25, r24
    39a2:	88 27       	eor	r24, r24
    39a4:	82 2b       	or	r24, r18
    39a6:	93 2b       	or	r25, r19
    39a8:	a4 2b       	or	r26, r20
    39aa:	b5 2b       	or	r27, r21
    39ac:	88 8b       	std	Y+16, r24	; 0x10
    39ae:	99 8b       	std	Y+17, r25	; 0x11
    39b0:	aa 8b       	std	Y+18, r26	; 0x12
    39b2:	bb 8b       	std	Y+19, r27	; 0x13
	ipHeader->srcIPAddr = HTONL(IpMyConfig.ip);
    39b4:	80 91 d9 05 	lds	r24, 0x05D9
    39b8:	90 91 da 05 	lds	r25, 0x05DA
    39bc:	a0 91 db 05 	lds	r26, 0x05DB
    39c0:	b0 91 dc 05 	lds	r27, 0x05DC
    39c4:	eb 2e       	mov	r14, r27
    39c6:	ff 24       	eor	r15, r15
    39c8:	00 27       	eor	r16, r16
    39ca:	11 27       	eor	r17, r17
    39cc:	58 2f       	mov	r21, r24
    39ce:	44 27       	eor	r20, r20
    39d0:	33 27       	eor	r19, r19
    39d2:	22 27       	eor	r18, r18
    39d4:	e2 2a       	or	r14, r18
    39d6:	f3 2a       	or	r15, r19
    39d8:	04 2b       	or	r16, r20
    39da:	15 2b       	or	r17, r21
    39dc:	9c 01       	movw	r18, r24
    39de:	ad 01       	movw	r20, r26
    39e0:	20 70       	andi	r18, 0x00	; 0
    39e2:	30 70       	andi	r19, 0x00	; 0
    39e4:	50 70       	andi	r21, 0x00	; 0
    39e6:	23 2f       	mov	r18, r19
    39e8:	34 2f       	mov	r19, r20
    39ea:	45 2f       	mov	r20, r21
    39ec:	55 27       	eor	r21, r21
    39ee:	2e 29       	or	r18, r14
    39f0:	3f 29       	or	r19, r15
    39f2:	40 2b       	or	r20, r16
    39f4:	51 2b       	or	r21, r17
    39f6:	80 70       	andi	r24, 0x00	; 0
    39f8:	a0 70       	andi	r26, 0x00	; 0
    39fa:	b0 70       	andi	r27, 0x00	; 0
    39fc:	ee 24       	eor	r14, r14
    39fe:	f8 2e       	mov	r15, r24
    3a00:	09 2f       	mov	r16, r25
    3a02:	1a 2f       	mov	r17, r26
    3a04:	2e 29       	or	r18, r14
    3a06:	3f 29       	or	r19, r15
    3a08:	40 2b       	or	r20, r16
    3a0a:	51 2b       	or	r21, r17
    3a0c:	2c 87       	std	Y+12, r18	; 0x0c
    3a0e:	3d 87       	std	Y+13, r19	; 0x0d
    3a10:	4e 87       	std	Y+14, r20	; 0x0e
    3a12:	5f 87       	std	Y+15, r21	; 0x0f
	ipHeader->Protocol = protocol;
    3a14:	e9 87       	std	Y+9, r30	; 0x09
	ipHeader->Len = HTONS(len);
    3a16:	96 2d       	mov	r25, r6
    3a18:	87 2d       	mov	r24, r7
    3a1a:	9b 83       	std	Y+3, r25	; 0x03
    3a1c:	8a 83       	std	Y+2, r24	; 0x02
	ipHeader->verHdrLen = 0x45;
    3a1e:	85 e4       	ldi	r24, 0x45	; 69
    3a20:	88 83       	st	Y, r24
	ipHeader->ToS = 0;
    3a22:	19 82       	std	Y+1, r1	; 0x01
	ipHeader->IDNumber = 0;
    3a24:	1d 82       	std	Y+5, r1	; 0x05
    3a26:	1c 82       	std	Y+4, r1	; 0x04
	ipHeader->Offset = 0;
    3a28:	1f 82       	std	Y+7, r1	; 0x07
    3a2a:	1e 82       	std	Y+6, r1	; 0x06
	ipHeader->TTL = IP_TIME_TO_LIVE;
    3a2c:	80 e8       	ldi	r24, 0x80	; 128
    3a2e:	88 87       	std	Y+8, r24	; 0x08
	ipHeader->Checksum = 0;
    3a30:	1b 86       	std	Y+11, r1	; 0x0b
    3a32:	1a 86       	std	Y+10, r1	; 0x0a

	ipHeader->Checksum = ipChecksum((unsigned char*)ipHeader, IP_HEADER_LEN);
    3a34:	ce 01       	movw	r24, r28
    3a36:	64 e1       	ldi	r22, 0x14	; 20
    3a38:	70 e0       	ldi	r23, 0x00	; 0
    3a3a:	0e 94 2d 1b 	call	0x365a	; 0x365a <ipChecksum>
    3a3e:	9b 87       	std	Y+11, r25	; 0x0b
    3a40:	8a 87       	std	Y+10, r24	; 0x0a
	if( (dstIp & IpMyConfig.netmask) == (IpMyConfig.ip & IpMyConfig.netmask) )
    3a42:	20 91 d9 05 	lds	r18, 0x05D9
    3a46:	30 91 da 05 	lds	r19, 0x05DA
    3a4a:	40 91 db 05 	lds	r20, 0x05DB
    3a4e:	50 91 dc 05 	lds	r21, 0x05DC
    3a52:	2a 25       	eor	r18, r10
    3a54:	3b 25       	eor	r19, r11
    3a56:	4c 25       	eor	r20, r12
    3a58:	5d 25       	eor	r21, r13
    3a5a:	80 91 dd 05 	lds	r24, 0x05DD
    3a5e:	90 91 de 05 	lds	r25, 0x05DE
    3a62:	a0 91 df 05 	lds	r26, 0x05DF
    3a66:	b0 91 e0 05 	lds	r27, 0x05E0
    3a6a:	82 23       	and	r24, r18
    3a6c:	93 23       	and	r25, r19
    3a6e:	a4 23       	and	r26, r20
    3a70:	b5 23       	and	r27, r21
    3a72:	00 97       	sbiw	r24, 0x00	; 0
    3a74:	a1 05       	cpc	r26, r1
    3a76:	b1 05       	cpc	r27, r1
    3a78:	39 f4       	brne	.+14     	; 0x3a88 <ipSend+0x170>
	{
		arpIpOut((unsigned char*)ethHeader,0);					// local send
    3a7a:	c4 01       	movw	r24, r8
    3a7c:	40 e0       	ldi	r20, 0x00	; 0
    3a7e:	50 e0       	ldi	r21, 0x00	; 0
    3a80:	ba 01       	movw	r22, r20
    3a82:	0e 94 27 0c 	call	0x184e	; 0x184e <arpIpOut>
    3a86:	0b c0       	rjmp	.+22     	; 0x3a9e <ipSend+0x186>
	}
	else
	{
		arpIpOut((unsigned char*)ethHeader,IpMyConfig.gateway);	// gateway send
    3a88:	40 91 e1 05 	lds	r20, 0x05E1
    3a8c:	50 91 e2 05 	lds	r21, 0x05E2
    3a90:	60 91 e3 05 	lds	r22, 0x05E3
    3a94:	70 91 e4 05 	lds	r23, 0x05E4
    3a98:	c4 01       	movw	r24, r8
    3a9a:	0e 94 27 0c 	call	0x184e	; 0x184e <arpIpOut>
	}
	len += ETH_HEADER_LEN;
	//#ifdef IP_DEBUG
	printf("Sending IP packet\r\nAddr: ");
    3a9e:	00 d0       	rcall	.+0      	; 0x3aa0 <ipSend+0x188>
    3aa0:	8f e3       	ldi	r24, 0x3F	; 63
    3aa2:	92 e1       	ldi	r25, 0x12	; 18
    3aa4:	ed b7       	in	r30, 0x3d	; 61
    3aa6:	fe b7       	in	r31, 0x3e	; 62
    3aa8:	92 83       	std	Z+2, r25	; 0x02
    3aaa:	81 83       	std	Z+1, r24	; 0x01
    3aac:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	ipPrintAddr(dstIp);printf("\n\rMAC: ");
    3ab0:	0f 90       	pop	r0
    3ab2:	0f 90       	pop	r0
    3ab4:	c6 01       	movw	r24, r12
    3ab6:	b5 01       	movw	r22, r10
    3ab8:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <ipPrintAddr>
    3abc:	00 d0       	rcall	.+0      	; 0x3abe <ipSend+0x1a6>
    3abe:	87 e3       	ldi	r24, 0x37	; 55
    3ac0:	92 e1       	ldi	r25, 0x12	; 18
    3ac2:	ed b7       	in	r30, 0x3d	; 61
    3ac4:	fe b7       	in	r31, 0x3e	; 62
    3ac6:	92 83       	std	Z+2, r25	; 0x02
    3ac8:	81 83       	std	Z+1, r24	; 0x01
    3aca:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	ethPrintAddr(&(ethHeader->desAddr));printf("\n\r");
    3ace:	0f 90       	pop	r0
    3ad0:	0f 90       	pop	r0
    3ad2:	c4 01       	movw	r24, r8
    3ad4:	0e 94 b9 1b 	call	0x3772	; 0x3772 <ethPrintAddr>
    3ad8:	00 d0       	rcall	.+0      	; 0x3ada <ipSend+0x1c2>
    3ada:	84 e3       	ldi	r24, 0x34	; 52
    3adc:	92 e1       	ldi	r25, 0x12	; 18
    3ade:	ed b7       	in	r30, 0x3d	; 61
    3ae0:	fe b7       	in	r31, 0x3e	; 62
    3ae2:	92 83       	std	Z+2, r25	; 0x02
    3ae4:	81 83       	std	Z+1, r24	; 0x01
    3ae6:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	//#endif
	ethSendFrame(len, (unsigned char*)ethHeader);
    3aea:	0f 90       	pop	r0
    3aec:	0f 90       	pop	r0
    3aee:	c3 01       	movw	r24, r6
    3af0:	0e 96       	adiw	r24, 0x0e	; 14
    3af2:	b4 01       	movw	r22, r8
    3af4:	0e 94 ec 14 	call	0x29d8	; 0x29d8 <ethSendFrame>
}
    3af8:	df 91       	pop	r29
    3afa:	cf 91       	pop	r28
    3afc:	1f 91       	pop	r17
    3afe:	0f 91       	pop	r16
    3b00:	ff 90       	pop	r15
    3b02:	ef 90       	pop	r14
    3b04:	df 90       	pop	r13
    3b06:	cf 90       	pop	r12
    3b08:	bf 90       	pop	r11
    3b0a:	af 90       	pop	r10
    3b0c:	9f 90       	pop	r9
    3b0e:	8f 90       	pop	r8
    3b10:	7f 90       	pop	r7
    3b12:	6f 90       	pop	r6
    3b14:	08 95       	ret

00003b16 <IPProcess>:
//--------------------------------------------------------------------------------------
//Ham x? ly goi IP, duoc goi boi giao thuc ethernet khi paket type duoc xac dinh la IP
void IPProcess(unsigned int len, struct ntIPHeader* packet)
{
    3b16:	cf 92       	push	r12
    3b18:	df 92       	push	r13
    3b1a:	ef 92       	push	r14
    3b1c:	ff 92       	push	r15
    3b1e:	0f 93       	push	r16
    3b20:	1f 93       	push	r17
    3b22:	cf 93       	push	r28
    3b24:	df 93       	push	r29
    3b26:	6c 01       	movw	r12, r24
    3b28:	eb 01       	movw	r28, r22
	// check IP addressing, stop processing if not for me and not a broadcast
	if( (HTONL(packet->desIPAddr) != ipGetConfig()->ip) &&
    3b2a:	88 89       	ldd	r24, Y+16	; 0x10
    3b2c:	99 89       	ldd	r25, Y+17	; 0x11
    3b2e:	aa 89       	ldd	r26, Y+18	; 0x12
    3b30:	bb 89       	ldd	r27, Y+19	; 0x13
    3b32:	eb 2e       	mov	r14, r27
    3b34:	ff 24       	eor	r15, r15
    3b36:	00 27       	eor	r16, r16
    3b38:	11 27       	eor	r17, r17
    3b3a:	58 2f       	mov	r21, r24
    3b3c:	44 27       	eor	r20, r20
    3b3e:	33 27       	eor	r19, r19
    3b40:	22 27       	eor	r18, r18
    3b42:	e2 2a       	or	r14, r18
    3b44:	f3 2a       	or	r15, r19
    3b46:	04 2b       	or	r16, r20
    3b48:	15 2b       	or	r17, r21
    3b4a:	9c 01       	movw	r18, r24
    3b4c:	ad 01       	movw	r20, r26
    3b4e:	20 70       	andi	r18, 0x00	; 0
    3b50:	30 70       	andi	r19, 0x00	; 0
    3b52:	50 70       	andi	r21, 0x00	; 0
    3b54:	23 2f       	mov	r18, r19
    3b56:	34 2f       	mov	r19, r20
    3b58:	45 2f       	mov	r20, r21
    3b5a:	55 27       	eor	r21, r21
    3b5c:	2e 29       	or	r18, r14
    3b5e:	3f 29       	or	r19, r15
    3b60:	40 2b       	or	r20, r16
    3b62:	51 2b       	or	r21, r17
    3b64:	80 70       	andi	r24, 0x00	; 0
    3b66:	a0 70       	andi	r26, 0x00	; 0
    3b68:	b0 70       	andi	r27, 0x00	; 0
    3b6a:	ee 24       	eor	r14, r14
    3b6c:	f8 2e       	mov	r15, r24
    3b6e:	09 2f       	mov	r16, r25
    3b70:	1a 2f       	mov	r17, r26
    3b72:	e2 2a       	or	r14, r18
    3b74:	f3 2a       	or	r15, r19
    3b76:	04 2b       	or	r16, r20
    3b78:	15 2b       	or	r17, r21
    3b7a:	0e 94 b6 1b 	call	0x376c	; 0x376c <ipGetConfig>
    3b7e:	fc 01       	movw	r30, r24
    3b80:	20 81       	ld	r18, Z
    3b82:	31 81       	ldd	r19, Z+1	; 0x01
    3b84:	42 81       	ldd	r20, Z+2	; 0x02
    3b86:	53 81       	ldd	r21, Z+3	; 0x03
    3b88:	e2 16       	cp	r14, r18
    3b8a:	f3 06       	cpc	r15, r19
    3b8c:	04 07       	cpc	r16, r20
    3b8e:	15 07       	cpc	r17, r21
    3b90:	d9 f0       	breq	.+54     	; 0x3bc8 <IPProcess+0xb2>
		(HTONL(packet->desIPAddr) != (ipGetConfig()->ip|ipGetConfig()->netmask)) &&
    3b92:	84 81       	ldd	r24, Z+4	; 0x04
    3b94:	95 81       	ldd	r25, Z+5	; 0x05
    3b96:	a6 81       	ldd	r26, Z+6	; 0x06
    3b98:	b7 81       	ldd	r27, Z+7	; 0x07
    3b9a:	82 2b       	or	r24, r18
    3b9c:	93 2b       	or	r25, r19
    3b9e:	a4 2b       	or	r26, r20
    3ba0:	b5 2b       	or	r27, r21
//--------------------------------------------------------------------------------------
//Ham x? ly goi IP, duoc goi boi giao thuc ethernet khi paket type duoc xac dinh la IP
void IPProcess(unsigned int len, struct ntIPHeader* packet)
{
	// check IP addressing, stop processing if not for me and not a broadcast
	if( (HTONL(packet->desIPAddr) != ipGetConfig()->ip) &&
    3ba2:	e8 16       	cp	r14, r24
    3ba4:	f9 06       	cpc	r15, r25
    3ba6:	0a 07       	cpc	r16, r26
    3ba8:	1b 07       	cpc	r17, r27
    3baa:	71 f0       	breq	.+28     	; 0x3bc8 <IPProcess+0xb2>
		(HTONL(packet->desIPAddr) != (ipGetConfig()->ip|ipGetConfig()->netmask)) &&
    3bac:	8f ef       	ldi	r24, 0xFF	; 255
    3bae:	e8 16       	cp	r14, r24
    3bb0:	8f ef       	ldi	r24, 0xFF	; 255
    3bb2:	f8 06       	cpc	r15, r24
    3bb4:	8f ef       	ldi	r24, 0xFF	; 255
    3bb6:	08 07       	cpc	r16, r24
    3bb8:	8f ef       	ldi	r24, 0xFF	; 255
    3bba:	18 07       	cpc	r17, r24
    3bbc:	29 f0       	breq	.+10     	; 0x3bc8 <IPProcess+0xb2>
		(HTONL(packet->desIPAddr) != 0xFFFFFFFF) &&
    3bbe:	21 15       	cp	r18, r1
    3bc0:	31 05       	cpc	r19, r1
    3bc2:	41 05       	cpc	r20, r1
    3bc4:	51 05       	cpc	r21, r1
    3bc6:	f1 f4       	brne	.+60     	; 0x3c04 <IPProcess+0xee>
		(ipGetConfig()->ip != 0x00000000) ) 
		return;

	// handle ICMP packet
	if( packet->Protocol == IP_PROTO_ICMP )
    3bc8:	89 85       	ldd	r24, Y+9	; 0x09
    3bca:	81 30       	cpi	r24, 0x01	; 1
    3bcc:	21 f4       	brne	.+8      	; 0x3bd6 <IPProcess+0xc0>
	{
		#ifdef IP_DEBUG
		printf("IP->Rx: ICMP/IP packet\r\n");
		//icmpPrintHeader((icmpip_hdr*)packet);
		#endif
		icmpIpIn((struct ntIPHeader*)packet);
    3bce:	ce 01       	movw	r24, r28
    3bd0:	0e 94 26 1b 	call	0x364c	; 0x364c <icmpIpIn>
    3bd4:	17 c0       	rjmp	.+46     	; 0x3c04 <IPProcess+0xee>
	}
	else if( packet->Protocol == IP_PROTO_UDP )
    3bd6:	81 31       	cpi	r24, 0x11	; 17
    3bd8:	29 f4       	brne	.+10     	; 0x3be4 <IPProcess+0xce>
	{
		#ifdef IP_DEBUG
		printf("IP->Rx: UDP/IP packet\r\n");
		//debugPrintHexTable(NetBufferLen-14, &NetBuffer[14]);
		#endif
		UDPProcess(len, ((struct ntIPHeader*)packet) );////
    3bda:	c6 01       	movw	r24, r12
    3bdc:	be 01       	movw	r22, r28
    3bde:	0e 94 7a 2c 	call	0x58f4	; 0x58f4 <UDPProcess>
    3be2:	10 c0       	rjmp	.+32     	; 0x3c04 <IPProcess+0xee>
	}
	else if( packet->Protocol == IP_PROTO_TCP )
    3be4:	86 30       	cpi	r24, 0x06	; 6
    3be6:	71 f4       	brne	.+28     	; 0x3c04 <IPProcess+0xee>
	{
		#ifdef IP_DEBUG
		printf("IP->Rx: TCP/IP packet\r\n");
		#endif
		TCPProcess((unsigned char *)packet,len-((packet->verHdrLen & 0x0F)<<2));////
    3be8:	88 81       	ld	r24, Y
    3bea:	90 e0       	ldi	r25, 0x00	; 0
    3bec:	8f 70       	andi	r24, 0x0F	; 15
    3bee:	90 70       	andi	r25, 0x00	; 0
    3bf0:	88 0f       	add	r24, r24
    3bf2:	99 1f       	adc	r25, r25
    3bf4:	88 0f       	add	r24, r24
    3bf6:	99 1f       	adc	r25, r25
    3bf8:	b6 01       	movw	r22, r12
    3bfa:	68 1b       	sub	r22, r24
    3bfc:	79 0b       	sbc	r23, r25
    3bfe:	ce 01       	movw	r24, r28
    3c00:	0e 94 2a 23 	call	0x4654	; 0x4654 <TCPProcess>
	{
		#ifdef IP_DEBUG
		printf("IP->Rx: IP packet\r\n");
		#endif
	}
}
    3c04:	df 91       	pop	r29
    3c06:	cf 91       	pop	r28
    3c08:	1f 91       	pop	r17
    3c0a:	0f 91       	pop	r16
    3c0c:	ff 90       	pop	r15
    3c0e:	ef 90       	pop	r14
    3c10:	df 90       	pop	r13
    3c12:	cf 90       	pop	r12
    3c14:	08 95       	ret

00003c16 <Read2Nib>:
#define DDR_DATA	DDRD
*/

char Read2Nib(){
	char HNib, LNib;
	DATA_O |=0xF0;
    3c16:	8b b3       	in	r24, 0x1b	; 27
    3c18:	80 6f       	ori	r24, 0xF0	; 240
    3c1a:	8b bb       	out	0x1b, r24	; 27

    DDR_DATA &=0x0F;
    3c1c:	8a b3       	in	r24, 0x1a	; 26
    3c1e:	8f 70       	andi	r24, 0x0F	; 15
    3c20:	8a bb       	out	0x1a, r24	; 26
	sbi(CTRL,EN); //enable
    3c22:	db 9a       	sbi	0x1b, 3	; 27
	sbi(CTRL,EN); // dong nay chi co tac dung delay vi chan EN da o muc cao roi
    3c24:	db 9a       	sbi	0x1b, 3	; 27
	

	HNib=DATA_I & 0xF0;
    3c26:	89 b3       	in	r24, 0x19	; 25
	cbi(CTRL,EN); //disable
    3c28:	db 98       	cbi	0x1b, 3	; 27

	sbi(CTRL,EN); //enable
    3c2a:	db 9a       	sbi	0x1b, 3	; 27
	sbi(CTRL,EN); //dong nay chi co tac dung delay vi chan EN da o muc cao roi	
    3c2c:	db 9a       	sbi	0x1b, 3	; 27
	LNib = DATA_I & 0xF0;
    3c2e:	99 b3       	in	r25, 0x19	; 25
	cbi(CTRL,EN); //disable
    3c30:	db 98       	cbi	0x1b, 3	; 27
	LNib>>=4;
    3c32:	92 95       	swap	r25
    3c34:	9f 70       	andi	r25, 0x0F	; 15
    DDR_DATA &=0x0F;
	sbi(CTRL,EN); //enable
	sbi(CTRL,EN); // dong nay chi co tac dung delay vi chan EN da o muc cao roi
	

	HNib=DATA_I & 0xF0;
    3c36:	80 7f       	andi	r24, 0xF0	; 240
	sbi(CTRL,EN); //dong nay chi co tac dung delay vi chan EN da o muc cao roi	
	LNib = DATA_I & 0xF0;
	cbi(CTRL,EN); //disable
	LNib>>=4;
	return (HNib|LNib);
}
    3c38:	89 2b       	or	r24, r25
    3c3a:	08 95       	ret

00003c3c <Write2Nib>:

void Write2Nib(uint8_t chr){

	uint8_t HNib, LNib, temp_data;	
	temp_data=DATA_O & 0x0F;
    3c3c:	9b b3       	in	r25, 0x1b	; 27
    3c3e:	9f 70       	andi	r25, 0x0F	; 15

	HNib=chr & 0xF0;
    3c40:	28 2f       	mov	r18, r24
    3c42:	20 7f       	andi	r18, 0xF0	; 240
	LNib=(chr<<4) & 0xF0;		
		
	DATA_O =(HNib |temp_data);	
    3c44:	29 2b       	or	r18, r25
    3c46:	2b bb       	out	0x1b, r18	; 27
	sbi(CTRL,EN); //enable
    3c48:	db 9a       	sbi	0x1b, 3	; 27
	cbi(CTRL,EN); //disable	
    3c4a:	db 98       	cbi	0x1b, 3	; 27

	uint8_t HNib, LNib, temp_data;	
	temp_data=DATA_O & 0x0F;

	HNib=chr & 0xF0;
	LNib=(chr<<4) & 0xF0;		
    3c4c:	82 95       	swap	r24
    3c4e:	80 7f       	andi	r24, 0xF0	; 240
		
	DATA_O =(HNib |temp_data);	
	sbi(CTRL,EN); //enable
	cbi(CTRL,EN); //disable	
	
	DATA_O =(LNib|temp_data);		
    3c50:	98 2b       	or	r25, r24
    3c52:	9b bb       	out	0x1b, r25	; 27
	sbi(CTRL,EN); //enable
    3c54:	db 9a       	sbi	0x1b, 3	; 27
	cbi(CTRL,EN); //disable
    3c56:	db 98       	cbi	0x1b, 3	; 27
}
    3c58:	08 95       	ret

00003c5a <Write8Bit>:

void Write8Bit(uint8_t chr){
	DATA_O=chr;   //out 8 bits to DATA Line
    3c5a:	8b bb       	out	0x1b, r24	; 27
	sbi(CTRL,EN); //enable
    3c5c:	db 9a       	sbi	0x1b, 3	; 27
	cbi(CTRL,EN); //disable
    3c5e:	db 98       	cbi	0x1b, 3	; 27
}
    3c60:	08 95       	ret

00003c62 <wait_LCD>:

void wait_LCD(){	
    3c62:	0f 93       	push	r16
    3c64:	1f 93       	push	r17
    3c66:	df 93       	push	r29
    3c68:	cf 93       	push	r28
    3c6a:	0f 92       	push	r0
    3c6c:	cd b7       	in	r28, 0x3d	; 61
    3c6e:	de b7       	in	r29, 0x3e	; 62
		char temp_val;
		while(1){
			cbi(CTRL,RS); //RS=0 mean the following data is COMMAND (not normal DATA)
			sbi(CTRL,RW); //the Direction of this COMMAND is from LCD -> chip
			temp_val=Read2Nib();
			if (bit_is_clear(temp_val,7)) break;
    3c70:	8e 01       	movw	r16, r28
    3c72:	0f 5f       	subi	r16, 0xFF	; 255
    3c74:	1f 4f       	sbci	r17, 0xFF	; 255
		cbi(CTRL,RW); //ready for next step	
		DDR_DATA=0xFF;//Ready to Out
	#else
		char temp_val;
		while(1){
			cbi(CTRL,RS); //RS=0 mean the following data is COMMAND (not normal DATA)
    3c76:	d9 98       	cbi	0x1b, 1	; 27
			sbi(CTRL,RW); //the Direction of this COMMAND is from LCD -> chip
    3c78:	da 9a       	sbi	0x1b, 2	; 27
			temp_val=Read2Nib();
    3c7a:	0e 94 0b 1e 	call	0x3c16	; 0x3c16 <Read2Nib>
    3c7e:	89 83       	std	Y+1, r24	; 0x01
			if (bit_is_clear(temp_val,7)) break;
    3c80:	f8 01       	movw	r30, r16
    3c82:	80 81       	ld	r24, Z
    3c84:	88 23       	and	r24, r24
    3c86:	bc f3       	brlt	.-18     	; 0x3c76 <wait_LCD+0x14>
		}
		cbi(CTRL,RW); //ready for next step	
    3c88:	da 98       	cbi	0x1b, 2	; 27
		DDR_DATA=0xFF;//Ready to Out		
    3c8a:	8f ef       	ldi	r24, 0xFF	; 255
    3c8c:	8a bb       	out	0x1a, r24	; 26
	#endif
	
	//_delay_ms(1);
	
}
    3c8e:	0f 90       	pop	r0
    3c90:	cf 91       	pop	r28
    3c92:	df 91       	pop	r29
    3c94:	1f 91       	pop	r17
    3c96:	0f 91       	pop	r16
    3c98:	08 95       	ret

00003c9a <init_LCD>:


void init_LCD(){
	DDR_CTRL=0xFF;
    3c9a:	8f ef       	ldi	r24, 0xFF	; 255
    3c9c:	8a bb       	out	0x1a, r24	; 26
	DDR_DATA=0xFF;
    3c9e:	8a bb       	out	0x1a, r24	; 26
//Function set------------------------------------------------------------------------------
	cbi(CTRL,RS);   // the following data is COMMAND
    3ca0:	d9 98       	cbi	0x1b, 1	; 27
	cbi(CTRL, RW); // AVR->LCD
    3ca2:	da 98       	cbi	0x1b, 2	; 27
	cbi(CTRL, EN);
    3ca4:	db 98       	cbi	0x1b, 3	; 27
	#ifdef LCD8BIT	
		Write8Bit(0x38);
		wait_LCD();
	#else
		sbi(CTRL,EN); //enable
    3ca6:	db 9a       	sbi	0x1b, 3	; 27
		sbi(DATA_O, 5); 
    3ca8:	dd 9a       	sbi	0x1b, 5	; 27
		cbi(CTRL,EN); //disable
    3caa:	db 98       	cbi	0x1b, 3	; 27
		wait_LCD();		
    3cac:	0e 94 31 1e 	call	0x3c62	; 0x3c62 <wait_LCD>
		Write2Nib(0x28);//
    3cb0:	88 e2       	ldi	r24, 0x28	; 40
    3cb2:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <Write2Nib>
		wait_LCD();	
    3cb6:	0e 94 31 1e 	call	0x3c62	; 0x3c62 <wait_LCD>
	#endif
//Display control-------------------------------------------------------------------------	
	cbi(CTRL,RS); // the following data is COMMAND 
    3cba:	d9 98       	cbi	0x1b, 1	; 27
	#ifdef LCD8BIT	
		Write8Bit(0x0E);
		wait_LCD();
	#else
		Write2Nib(0x0E);
    3cbc:	8e e0       	ldi	r24, 0x0E	; 14
    3cbe:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <Write2Nib>
		wait_LCD();			
    3cc2:	0e 94 31 1e 	call	0x3c62	; 0x3c62 <wait_LCD>
	#endif
//Entry mode set------------------------------------------------------------------------
	cbi(CTRL,RS); // the following data is COMMAND 
    3cc6:	d9 98       	cbi	0x1b, 1	; 27
	#ifdef LCD8BIT
		Write8Bit(0x06);
		wait_LCD();
	#else
		Write2Nib(0x06);
    3cc8:	86 e0       	ldi	r24, 0x06	; 6
    3cca:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <Write2Nib>
		wait_LCD();
    3cce:	0e 94 31 1e 	call	0x3c62	; 0x3c62 <wait_LCD>
	#endif
}
    3cd2:	08 95       	ret

00003cd4 <home_LCD>:

void home_LCD(){
	cbi(CTRL,RS); // the following data is COMMAND 
    3cd4:	d9 98       	cbi	0x1b, 1	; 27
	#ifdef LCD8BIT	
		Write8Bit(0x02);
		wait_LCD();	
	#else
		Write2Nib(0x02);
    3cd6:	82 e0       	ldi	r24, 0x02	; 2
    3cd8:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <Write2Nib>
		wait_LCD();
    3cdc:	0e 94 31 1e 	call	0x3c62	; 0x3c62 <wait_LCD>
	#endif	
}
    3ce0:	08 95       	ret

00003ce2 <move_LCD>:
void move_LCD(uint8_t y,uint8_t x){
	uint8_t Ad;
	Ad=64*(y-1)+(x-1)+0x80; //
	cbi(CTRL,RS); // the following data is COMMAND
    3ce2:	d9 98       	cbi	0x1b, 1	; 27
		wait_LCD();
	#endif	
}
void move_LCD(uint8_t y,uint8_t x){
	uint8_t Ad;
	Ad=64*(y-1)+(x-1)+0x80; //
    3ce4:	82 95       	swap	r24
    3ce6:	88 0f       	add	r24, r24
    3ce8:	88 0f       	add	r24, r24
    3cea:	80 7c       	andi	r24, 0xC0	; 192
    3cec:	86 0f       	add	r24, r22
	cbi(CTRL,RS); // the following data is COMMAND
	#ifdef LCD8BIT	
		Write8Bit(Ad);
		wait_LCD();
	#else
		Write2Nib(Ad);
    3cee:	81 5c       	subi	r24, 0xC1	; 193
    3cf0:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <Write2Nib>
		wait_LCD();
    3cf4:	0e 94 31 1e 	call	0x3c62	; 0x3c62 <wait_LCD>
	#endif	
}
    3cf8:	08 95       	ret

00003cfa <clr_LCD>:

void clr_LCD(){
	cbi(CTRL,RS); //RS=0 mean the following data is COMMAND (not normal DATA)
    3cfa:	d9 98       	cbi	0x1b, 1	; 27
	#ifdef LCD8BIT	
		Write8Bit(0x01);
		wait_LCD();	
	#else
		Write2Nib(0x01);
    3cfc:	81 e0       	ldi	r24, 0x01	; 1
    3cfe:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <Write2Nib>
		wait_LCD();	
    3d02:	0e 94 31 1e 	call	0x3c62	; 0x3c62 <wait_LCD>
		
	#endif	
}
    3d06:	08 95       	ret

00003d08 <putChar_LCD>:

void putChar_LCD(uint8_t chr){
	sbi(CTRL,RS); //this is a normal DATA	
    3d08:	d9 9a       	sbi	0x1b, 1	; 27
	#ifdef LCD8BIT	
		Write8Bit(chr);
		wait_LCD();	
	#else
		Write2Nib(chr);
    3d0a:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <Write2Nib>
		wait_LCD();	
    3d0e:	0e 94 31 1e 	call	0x3c62	; 0x3c62 <wait_LCD>
	#endif		
}
    3d12:	08 95       	ret

00003d14 <print_LCD>:

void print_LCD(char* str){
    3d14:	1f 93       	push	r17
    3d16:	cf 93       	push	r28
    3d18:	df 93       	push	r29
    3d1a:	ec 01       	movw	r28, r24
	 unsigned char i;
	 for (i=0; str[i]!=0; i++) putChar_LCD(str[i]);	 
    3d1c:	88 81       	ld	r24, Y
    3d1e:	88 23       	and	r24, r24
    3d20:	51 f0       	breq	.+20     	; 0x3d36 <print_LCD+0x22>
    3d22:	10 e0       	ldi	r17, 0x00	; 0
    3d24:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <putChar_LCD>
    3d28:	1f 5f       	subi	r17, 0xFF	; 255
    3d2a:	fe 01       	movw	r30, r28
    3d2c:	e1 0f       	add	r30, r17
    3d2e:	f1 1d       	adc	r31, r1
    3d30:	80 81       	ld	r24, Z
    3d32:	88 23       	and	r24, r24
    3d34:	b9 f7       	brne	.-18     	; 0x3d24 <print_LCD+0x10>
    3d36:	df 91       	pop	r29
    3d38:	cf 91       	pop	r28
    3d3a:	1f 91       	pop	r17
    3d3c:	08 95       	ret

00003d3e <off_device>:
#include "lcd.h"
extern struct ipConfig IpMyConfig;
//Ham DK TB
void off_device (uint8_t val)
{
	switch (val)
    3d3e:	82 30       	cpi	r24, 0x02	; 2
    3d40:	61 f0       	breq	.+24     	; 0x3d5a <off_device+0x1c>
    3d42:	83 30       	cpi	r24, 0x03	; 3
    3d44:	18 f4       	brcc	.+6      	; 0x3d4c <off_device+0xe>
    3d46:	81 30       	cpi	r24, 0x01	; 1
    3d48:	69 f4       	brne	.+26     	; 0x3d64 <off_device+0x26>
    3d4a:	05 c0       	rjmp	.+10     	; 0x3d56 <off_device+0x18>
    3d4c:	83 30       	cpi	r24, 0x03	; 3
    3d4e:	39 f0       	breq	.+14     	; 0x3d5e <off_device+0x20>
    3d50:	84 30       	cpi	r24, 0x04	; 4
    3d52:	41 f4       	brne	.+16     	; 0x3d64 <off_device+0x26>
    3d54:	06 c0       	rjmp	.+12     	; 0x3d62 <off_device+0x24>
		{
			case 1:		OFF1	break;
    3d56:	af 9a       	sbi	0x15, 7	; 21
    3d58:	08 95       	ret
			case 2: 	OFF2	break;
    3d5a:	ae 9a       	sbi	0x15, 6	; 21
    3d5c:	08 95       	ret
			case 3: 	OFF3	break;
    3d5e:	ad 9a       	sbi	0x15, 5	; 21
    3d60:	08 95       	ret
			case 4: 	OFF4	break;
    3d62:	ac 9a       	sbi	0x15, 4	; 21
    3d64:	08 95       	ret

00003d66 <on_device>:
			default: break;
		}
}
void on_device (uint8_t val)
{
	switch (val)
    3d66:	82 30       	cpi	r24, 0x02	; 2
    3d68:	61 f0       	breq	.+24     	; 0x3d82 <on_device+0x1c>
    3d6a:	83 30       	cpi	r24, 0x03	; 3
    3d6c:	18 f4       	brcc	.+6      	; 0x3d74 <on_device+0xe>
    3d6e:	81 30       	cpi	r24, 0x01	; 1
    3d70:	69 f4       	brne	.+26     	; 0x3d8c <on_device+0x26>
    3d72:	05 c0       	rjmp	.+10     	; 0x3d7e <on_device+0x18>
    3d74:	83 30       	cpi	r24, 0x03	; 3
    3d76:	39 f0       	breq	.+14     	; 0x3d86 <on_device+0x20>
    3d78:	84 30       	cpi	r24, 0x04	; 4
    3d7a:	41 f4       	brne	.+16     	; 0x3d8c <on_device+0x26>
    3d7c:	06 c0       	rjmp	.+12     	; 0x3d8a <on_device+0x24>
		{
			case 1:		ON1		break;
    3d7e:	af 98       	cbi	0x15, 7	; 21
    3d80:	08 95       	ret
			case 2: 	ON2		break;
    3d82:	ae 98       	cbi	0x15, 6	; 21
    3d84:	08 95       	ret
			case 3: 	ON3		break;
    3d86:	ad 98       	cbi	0x15, 5	; 21
    3d88:	08 95       	ret
			case 4: 	ON4		break;
    3d8a:	ac 98       	cbi	0x15, 4	; 21
    3d8c:	08 95       	ret

00003d8e <GetState>:
			default: break;
		}
}
uint8_t GetState(uint8_t val) // =240 ON =15 OFF
{
	switch (val)
    3d8e:	82 30       	cpi	r24, 0x02	; 2
    3d90:	71 f0       	breq	.+28     	; 0x3dae <GetState+0x20>
    3d92:	83 30       	cpi	r24, 0x03	; 3
    3d94:	18 f4       	brcc	.+6      	; 0x3d9c <GetState+0xe>
    3d96:	81 30       	cpi	r24, 0x01	; 1
    3d98:	b1 f4       	brne	.+44     	; 0x3dc6 <GetState+0x38>
    3d9a:	05 c0       	rjmp	.+10     	; 0x3da6 <GetState+0x18>
    3d9c:	83 30       	cpi	r24, 0x03	; 3
    3d9e:	59 f0       	breq	.+22     	; 0x3db6 <GetState+0x28>
    3da0:	84 30       	cpi	r24, 0x04	; 4
    3da2:	89 f4       	brne	.+34     	; 0x3dc6 <GetState+0x38>
    3da4:	0c c0       	rjmp	.+24     	; 0x3dbe <GetState+0x30>
	{
			case 1: 	if(bit_is_clear(PORTC,PINC7))	return 240;	else	return 15;		break;
    3da6:	af 9b       	sbis	0x15, 7	; 21
    3da8:	0f c0       	rjmp	.+30     	; 0x3dc8 <GetState+0x3a>
    3daa:	8f e0       	ldi	r24, 0x0F	; 15
    3dac:	08 95       	ret
			case 2: 	if(bit_is_clear(PORTC,PINC6))	return 240;	else	return 15;		break;
    3dae:	ae 99       	sbic	0x15, 6	; 21
    3db0:	0d c0       	rjmp	.+26     	; 0x3dcc <GetState+0x3e>
    3db2:	80 ef       	ldi	r24, 0xF0	; 240
    3db4:	08 95       	ret
			case 3: 	if(bit_is_clear(PORTC,PINC5))	return 240;	else	return 15;		break;
    3db6:	ad 99       	sbic	0x15, 5	; 21
    3db8:	0b c0       	rjmp	.+22     	; 0x3dd0 <GetState+0x42>
    3dba:	80 ef       	ldi	r24, 0xF0	; 240
    3dbc:	08 95       	ret
			case 4: 	if(bit_is_clear(PORTC,PINC4))	return 240;	else	return 15;		break;
    3dbe:	ac 99       	sbic	0x15, 4	; 21
    3dc0:	09 c0       	rjmp	.+18     	; 0x3dd4 <GetState+0x46>
    3dc2:	80 ef       	ldi	r24, 0xF0	; 240
    3dc4:	08 95       	ret
    3dc6:	08 95       	ret
}
uint8_t GetState(uint8_t val) // =240 ON =15 OFF
{
	switch (val)
	{
			case 1: 	if(bit_is_clear(PORTC,PINC7))	return 240;	else	return 15;		break;
    3dc8:	80 ef       	ldi	r24, 0xF0	; 240
    3dca:	08 95       	ret
			case 2: 	if(bit_is_clear(PORTC,PINC6))	return 240;	else	return 15;		break;
    3dcc:	8f e0       	ldi	r24, 0x0F	; 15
    3dce:	08 95       	ret
			case 3: 	if(bit_is_clear(PORTC,PINC5))	return 240;	else	return 15;		break;
    3dd0:	8f e0       	ldi	r24, 0x0F	; 15
    3dd2:	08 95       	ret
			case 4: 	if(bit_is_clear(PORTC,PINC4))	return 240;	else	return 15;		break;
    3dd4:	8f e0       	ldi	r24, 0x0F	; 15
			default: break;
	}
}
    3dd6:	08 95       	ret

00003dd8 <lcd_show_number>:

//Pha khai bao
//Xuat 1 so co 3 chu so
void lcd_show_number(uint8_t val)
{
    3dd8:	0f 93       	push	r16
    3dda:	1f 93       	push	r17
    3ddc:	18 2f       	mov	r17, r24
	if(val /100 == 0 && (val %100) /10 != 0)	putChar_LCD((val %100) /10+48);
    3dde:	84 36       	cpi	r24, 0x64	; 100
    3de0:	68 f4       	brcc	.+26     	; 0x3dfc <lcd_show_number+0x24>
    3de2:	64 e6       	ldi	r22, 0x64	; 100
    3de4:	0e 94 80 2c 	call	0x5900	; 0x5900 <__udivmodqi4>
    3de8:	9a 30       	cpi	r25, 0x0A	; 10
    3dea:	b0 f0       	brcs	.+44     	; 0x3e18 <lcd_show_number+0x40>
    3dec:	89 2f       	mov	r24, r25
    3dee:	6a e0       	ldi	r22, 0x0A	; 10
    3df0:	0e 94 80 2c 	call	0x5900	; 0x5900 <__udivmodqi4>
    3df4:	80 5d       	subi	r24, 0xD0	; 208
    3df6:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <putChar_LCD>
    3dfa:	0e c0       	rjmp	.+28     	; 0x3e18 <lcd_show_number+0x40>
	else if(val /100 != 0) {putChar_LCD(val /100+48);	putChar_LCD((val %100) /10+48);}
    3dfc:	64 e6       	ldi	r22, 0x64	; 100
    3dfe:	0e 94 80 2c 	call	0x5900	; 0x5900 <__udivmodqi4>
    3e02:	09 2f       	mov	r16, r25
    3e04:	80 5d       	subi	r24, 0xD0	; 208
    3e06:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <putChar_LCD>
    3e0a:	80 2f       	mov	r24, r16
    3e0c:	6a e0       	ldi	r22, 0x0A	; 10
    3e0e:	0e 94 80 2c 	call	0x5900	; 0x5900 <__udivmodqi4>
    3e12:	80 5d       	subi	r24, 0xD0	; 208
    3e14:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <putChar_LCD>
	putChar_LCD((val %100) %10+48);
    3e18:	81 2f       	mov	r24, r17
    3e1a:	64 e6       	ldi	r22, 0x64	; 100
    3e1c:	0e 94 80 2c 	call	0x5900	; 0x5900 <__udivmodqi4>
    3e20:	89 2f       	mov	r24, r25
    3e22:	6a e0       	ldi	r22, 0x0A	; 10
    3e24:	0e 94 80 2c 	call	0x5900	; 0x5900 <__udivmodqi4>
    3e28:	89 2f       	mov	r24, r25
    3e2a:	80 5d       	subi	r24, 0xD0	; 208
    3e2c:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <putChar_LCD>
}
    3e30:	1f 91       	pop	r17
    3e32:	0f 91       	pop	r16
    3e34:	08 95       	ret

00003e36 <network_out>:
//In ip
void network_out(unsigned long ipaddr, uint8_t kind)
{
    3e36:	0f 93       	push	r16
    3e38:	1f 93       	push	r17
    3e3a:	df 93       	push	r29
    3e3c:	cf 93       	push	r28
    3e3e:	00 d0       	rcall	.+0      	; 0x3e40 <network_out+0xa>
    3e40:	00 d0       	rcall	.+0      	; 0x3e42 <network_out+0xc>
    3e42:	cd b7       	in	r28, 0x3d	; 61
    3e44:	de b7       	in	r29, 0x3e	; 62
    3e46:	69 83       	std	Y+1, r22	; 0x01
    3e48:	7a 83       	std	Y+2, r23	; 0x02
    3e4a:	8b 83       	std	Y+3, r24	; 0x03
    3e4c:	9c 83       	std	Y+4, r25	; 0x04
	switch(kind)
    3e4e:	42 30       	cpi	r20, 0x02	; 2
    3e50:	49 f0       	breq	.+18     	; 0x3e64 <network_out+0x2e>
    3e52:	43 30       	cpi	r20, 0x03	; 3
    3e54:	61 f0       	breq	.+24     	; 0x3e6e <network_out+0x38>
    3e56:	41 30       	cpi	r20, 0x01	; 1
    3e58:	71 f4       	brne	.+28     	; 0x3e76 <network_out+0x40>
	{
		case 1: print_LCD("IP:");	break;
    3e5a:	8c e6       	ldi	r24, 0x6C	; 108
    3e5c:	90 e0       	ldi	r25, 0x00	; 0
    3e5e:	0e 94 8a 1e 	call	0x3d14	; 0x3d14 <print_LCD>
    3e62:	09 c0       	rjmp	.+18     	; 0x3e76 <network_out+0x40>
		case 2:	print_LCD("SN:");	break;
    3e64:	80 e7       	ldi	r24, 0x70	; 112
    3e66:	90 e0       	ldi	r25, 0x00	; 0
    3e68:	0e 94 8a 1e 	call	0x3d14	; 0x3d14 <print_LCD>
    3e6c:	04 c0       	rjmp	.+8      	; 0x3e76 <network_out+0x40>
		case 3:	print_LCD("GW:");	break;
    3e6e:	84 e7       	ldi	r24, 0x74	; 116
    3e70:	90 e0       	ldi	r25, 0x00	; 0
    3e72:	0e 94 8a 1e 	call	0x3d14	; 0x3d14 <print_LCD>
		default: break;
	}
	if(((unsigned char*)&ipaddr)[3] == 0)	{print_LCD("0.0.0.0");}
    3e76:	8e 01       	movw	r16, r28
    3e78:	0f 5f       	subi	r16, 0xFF	; 255
    3e7a:	1f 4f       	sbci	r17, 0xFF	; 255
    3e7c:	f8 01       	movw	r30, r16
    3e7e:	83 81       	ldd	r24, Z+3	; 0x03
    3e80:	88 23       	and	r24, r24
    3e82:	29 f4       	brne	.+10     	; 0x3e8e <network_out+0x58>
    3e84:	88 e7       	ldi	r24, 0x78	; 120
    3e86:	90 e0       	ldi	r25, 0x00	; 0
    3e88:	0e 94 8a 1e 	call	0x3d14	; 0x3d14 <print_LCD>
    3e8c:	16 c0       	rjmp	.+44     	; 0x3eba <network_out+0x84>
	else
	{
		lcd_show_number(((unsigned char*)&ipaddr)[3]);	putChar_LCD('.');
    3e8e:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <lcd_show_number>
    3e92:	8e e2       	ldi	r24, 0x2E	; 46
    3e94:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <putChar_LCD>
		lcd_show_number(((unsigned char*)&ipaddr)[2]);	putChar_LCD('.');
    3e98:	f8 01       	movw	r30, r16
    3e9a:	82 81       	ldd	r24, Z+2	; 0x02
    3e9c:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <lcd_show_number>
    3ea0:	8e e2       	ldi	r24, 0x2E	; 46
    3ea2:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <putChar_LCD>
		lcd_show_number(((unsigned char*)&ipaddr)[1]);	putChar_LCD('.');
    3ea6:	f8 01       	movw	r30, r16
    3ea8:	81 81       	ldd	r24, Z+1	; 0x01
    3eaa:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <lcd_show_number>
    3eae:	8e e2       	ldi	r24, 0x2E	; 46
    3eb0:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <putChar_LCD>
		lcd_show_number(((unsigned char*)&ipaddr)[0]);
    3eb4:	89 81       	ldd	r24, Y+1	; 0x01
    3eb6:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <lcd_show_number>
	}	
}
    3eba:	0f 90       	pop	r0
    3ebc:	0f 90       	pop	r0
    3ebe:	0f 90       	pop	r0
    3ec0:	0f 90       	pop	r0
    3ec2:	cf 91       	pop	r28
    3ec4:	df 91       	pop	r29
    3ec6:	1f 91       	pop	r17
    3ec8:	0f 91       	pop	r16
    3eca:	08 95       	ret

00003ecc <showip>:
//Xuat ip ra LCD
void showip(void)
{
	move_LCD(1,1);	network_out(IpMyConfig.ip,1);
    3ecc:	81 e0       	ldi	r24, 0x01	; 1
    3ece:	61 e0       	ldi	r22, 0x01	; 1
    3ed0:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <move_LCD>
    3ed4:	60 91 d9 05 	lds	r22, 0x05D9
    3ed8:	70 91 da 05 	lds	r23, 0x05DA
    3edc:	80 91 db 05 	lds	r24, 0x05DB
    3ee0:	90 91 dc 05 	lds	r25, 0x05DC
    3ee4:	41 e0       	ldi	r20, 0x01	; 1
    3ee6:	0e 94 1b 1f 	call	0x3e36	; 0x3e36 <network_out>
	move_LCD(2,1);	network_out(IpMyConfig.netmask,2);
    3eea:	82 e0       	ldi	r24, 0x02	; 2
    3eec:	61 e0       	ldi	r22, 0x01	; 1
    3eee:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <move_LCD>
    3ef2:	60 91 dd 05 	lds	r22, 0x05DD
    3ef6:	70 91 de 05 	lds	r23, 0x05DE
    3efa:	80 91 df 05 	lds	r24, 0x05DF
    3efe:	90 91 e0 05 	lds	r25, 0x05E0
    3f02:	42 e0       	ldi	r20, 0x02	; 2
    3f04:	0e 94 1b 1f 	call	0x3e36	; 0x3e36 <network_out>
}
    3f08:	08 95       	ret

00003f0a <netInit>:
//----------------------------------------------------------------------------
void netInit(unsigned long ipaddress, unsigned long netmask, unsigned long gatewayip)
{
    3f0a:	6f 92       	push	r6
    3f0c:	7f 92       	push	r7
    3f0e:	8f 92       	push	r8
    3f10:	9f 92       	push	r9
    3f12:	af 92       	push	r10
    3f14:	bf 92       	push	r11
    3f16:	cf 92       	push	r12
    3f18:	df 92       	push	r13
    3f1a:	ef 92       	push	r14
    3f1c:	ff 92       	push	r15
    3f1e:	0f 93       	push	r16
    3f20:	1f 93       	push	r17
    3f22:	5b 01       	movw	r10, r22
    3f24:	6c 01       	movw	r12, r24
    3f26:	39 01       	movw	r6, r18
    3f28:	4a 01       	movw	r8, r20
	// init network device driver
	#ifdef NETSTACK_DEBUG
	printf("Initializing Network Device\r\n");
	#endif
	ethInit();
    3f2a:	0e 94 e6 14 	call	0x29cc	; 0x29cc <ethInit>
	// init ARP
	#ifdef NETSTACK_DEBUG
	printf("Initializing ARP cache\r\n");
	#endif
	arpInit();
    3f2e:	0e 94 df 09 	call	0x13be	; 0x13be <arpInit>
	// init addressing
	#ifdef NETSTACK_DEBUG
	printf("Initializing Addressing\r\n");
	#endif
	ipSetConfig(ipaddress, netmask, gatewayip);
    3f32:	c6 01       	movw	r24, r12
    3f34:	b5 01       	movw	r22, r10
    3f36:	a4 01       	movw	r20, r8
    3f38:	93 01       	movw	r18, r6
    3f3a:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <ipSetConfig>
}
    3f3e:	1f 91       	pop	r17
    3f40:	0f 91       	pop	r16
    3f42:	ff 90       	pop	r15
    3f44:	ef 90       	pop	r14
    3f46:	df 90       	pop	r13
    3f48:	cf 90       	pop	r12
    3f4a:	bf 90       	pop	r11
    3f4c:	af 90       	pop	r10
    3f4e:	9f 90       	pop	r9
    3f50:	8f 90       	pop	r8
    3f52:	7f 90       	pop	r7
    3f54:	6f 90       	pop	r6
    3f56:	08 95       	ret

00003f58 <PrintIPConfig>:
//--------------------------------------------------------------------------------------
void	PrintIPConfig()
{
    3f58:	cf 93       	push	r28
    3f5a:	df 93       	push	r29
	printf("MAC Address: ");		ethPrintAddr(&IpMyConfig.ethaddr);		printf("\n\r");
    3f5c:	00 d0       	rcall	.+0      	; 0x3f5e <PrintIPConfig+0x6>
    3f5e:	81 e6       	ldi	r24, 0x61	; 97
    3f60:	93 e1       	ldi	r25, 0x13	; 19
    3f62:	ed b7       	in	r30, 0x3d	; 61
    3f64:	fe b7       	in	r31, 0x3e	; 62
    3f66:	92 83       	std	Z+2, r25	; 0x02
    3f68:	81 83       	std	Z+1, r24	; 0x01
    3f6a:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    3f6e:	0f 90       	pop	r0
    3f70:	0f 90       	pop	r0
    3f72:	c5 ee       	ldi	r28, 0xE5	; 229
    3f74:	d5 e0       	ldi	r29, 0x05	; 5
    3f76:	ce 01       	movw	r24, r28
    3f78:	0e 94 b9 1b 	call	0x3772	; 0x3772 <ethPrintAddr>
    3f7c:	00 d0       	rcall	.+0      	; 0x3f7e <PrintIPConfig+0x26>
    3f7e:	8e e5       	ldi	r24, 0x5E	; 94
    3f80:	93 e1       	ldi	r25, 0x13	; 19
    3f82:	ed b7       	in	r30, 0x3d	; 61
    3f84:	fe b7       	in	r31, 0x3e	; 62
    3f86:	92 83       	std	Z+2, r25	; 0x02
    3f88:	81 83       	std	Z+1, r24	; 0x01
    3f8a:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	printf("IP  Address: ");		ipPrintAddr(IpMyConfig.ip);				printf("\n\r");
    3f8e:	80 e5       	ldi	r24, 0x50	; 80
    3f90:	93 e1       	ldi	r25, 0x13	; 19
    3f92:	ed b7       	in	r30, 0x3d	; 61
    3f94:	fe b7       	in	r31, 0x3e	; 62
    3f96:	92 83       	std	Z+2, r25	; 0x02
    3f98:	81 83       	std	Z+1, r24	; 0x01
    3f9a:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    3f9e:	0f 90       	pop	r0
    3fa0:	0f 90       	pop	r0
    3fa2:	2c 97       	sbiw	r28, 0x0c	; 12
    3fa4:	68 81       	ld	r22, Y
    3fa6:	79 81       	ldd	r23, Y+1	; 0x01
    3fa8:	8a 81       	ldd	r24, Y+2	; 0x02
    3faa:	9b 81       	ldd	r25, Y+3	; 0x03
    3fac:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <ipPrintAddr>
    3fb0:	00 d0       	rcall	.+0      	; 0x3fb2 <PrintIPConfig+0x5a>
    3fb2:	8d e4       	ldi	r24, 0x4D	; 77
    3fb4:	93 e1       	ldi	r25, 0x13	; 19
    3fb6:	ed b7       	in	r30, 0x3d	; 61
    3fb8:	fe b7       	in	r31, 0x3e	; 62
    3fba:	92 83       	std	Z+2, r25	; 0x02
    3fbc:	81 83       	std	Z+1, r24	; 0x01
    3fbe:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	printf("Subnet Mask: ");		ipPrintAddr(IpMyConfig.netmask);		printf("\n\r");
    3fc2:	8f e3       	ldi	r24, 0x3F	; 63
    3fc4:	93 e1       	ldi	r25, 0x13	; 19
    3fc6:	ed b7       	in	r30, 0x3d	; 61
    3fc8:	fe b7       	in	r31, 0x3e	; 62
    3fca:	92 83       	std	Z+2, r25	; 0x02
    3fcc:	81 83       	std	Z+1, r24	; 0x01
    3fce:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    3fd2:	0f 90       	pop	r0
    3fd4:	0f 90       	pop	r0
    3fd6:	6c 81       	ldd	r22, Y+4	; 0x04
    3fd8:	7d 81       	ldd	r23, Y+5	; 0x05
    3fda:	8e 81       	ldd	r24, Y+6	; 0x06
    3fdc:	9f 81       	ldd	r25, Y+7	; 0x07
    3fde:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <ipPrintAddr>
    3fe2:	00 d0       	rcall	.+0      	; 0x3fe4 <PrintIPConfig+0x8c>
    3fe4:	8c e3       	ldi	r24, 0x3C	; 60
    3fe6:	93 e1       	ldi	r25, 0x13	; 19
    3fe8:	ed b7       	in	r30, 0x3d	; 61
    3fea:	fe b7       	in	r31, 0x3e	; 62
    3fec:	92 83       	std	Z+2, r25	; 0x02
    3fee:	81 83       	std	Z+1, r24	; 0x01
    3ff0:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	printf("Default Gateway: ");	ipPrintAddr(IpMyConfig.gateway);		printf("\n\r");
    3ff4:	8a e2       	ldi	r24, 0x2A	; 42
    3ff6:	93 e1       	ldi	r25, 0x13	; 19
    3ff8:	ed b7       	in	r30, 0x3d	; 61
    3ffa:	fe b7       	in	r31, 0x3e	; 62
    3ffc:	92 83       	std	Z+2, r25	; 0x02
    3ffe:	81 83       	std	Z+1, r24	; 0x01
    4000:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    4004:	0f 90       	pop	r0
    4006:	0f 90       	pop	r0
    4008:	68 85       	ldd	r22, Y+8	; 0x08
    400a:	79 85       	ldd	r23, Y+9	; 0x09
    400c:	8a 85       	ldd	r24, Y+10	; 0x0a
    400e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4010:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <ipPrintAddr>
    4014:	00 d0       	rcall	.+0      	; 0x4016 <PrintIPConfig+0xbe>
    4016:	87 e2       	ldi	r24, 0x27	; 39
    4018:	93 e1       	ldi	r25, 0x13	; 19
    401a:	ed b7       	in	r30, 0x3d	; 61
    401c:	fe b7       	in	r31, 0x3e	; 62
    401e:	92 83       	std	Z+2, r25	; 0x02
    4020:	81 83       	std	Z+1, r24	; 0x01
    4022:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
    4026:	0f 90       	pop	r0
    4028:	0f 90       	pop	r0
}
    402a:	df 91       	pop	r29
    402c:	cf 91       	pop	r28
    402e:	08 95       	ret

00004030 <SystemInit>:
//--------------------------------------------------------------------------------------
void	SystemInit()
{
	init_LCD();
    4030:	0e 94 4d 1e 	call	0x3c9a	; 0x3c9a <init_LCD>
	clr_LCD();
    4034:	0e 94 7d 1e 	call	0x3cfa	; 0x3cfa <clr_LCD>
	DDRC = 0xff;	//out
    4038:	8f ef       	ldi	r24, 0xFF	; 255
    403a:	84 bb       	out	0x14, r24	; 20
	PORTC = 0xff;
    403c:	85 bb       	out	0x15, r24	; 21
	timer1Init();
    403e:	0e 94 ad 29 	call	0x535a	; 0x535a <timer1Init>
	uartInit(UART_BAUDRATE);
    4042:	60 e8       	ldi	r22, 0x80	; 128
    4044:	75 e2       	ldi	r23, 0x25	; 37
    4046:	80 e0       	ldi	r24, 0x00	; 0
    4048:	90 e0       	ldi	r25, 0x00	; 0
    404a:	0e 94 0e 2a 	call	0x541c	; 0x541c <uartInit>
}
    404e:	08 95       	ret

00004050 <EthernetInit>:
//Cau hinh Ethernet
void EthernetInit()
{	
    4050:	ef 92       	push	r14
    4052:	ff 92       	push	r15
    4054:	0f 93       	push	r16
    4056:	1f 93       	push	r17
    4058:	cf 93       	push	r28
    405a:	df 93       	push	r29
	printf("\r\nNTTam AVR network testing with enc28j60.\r\n");
    405c:	00 d0       	rcall	.+0      	; 0x405e <EthernetInit+0xe>
    405e:	8a ef       	ldi	r24, 0xFA	; 250
    4060:	92 e1       	ldi	r25, 0x12	; 18
    4062:	ed b7       	in	r30, 0x3d	; 61
    4064:	fe b7       	in	r31, 0x3e	; 62
    4066:	92 83       	std	Z+2, r25	; 0x02
    4068:	81 83       	std	Z+1, r24	; 0x01
    406a:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	printf("Initializing Network Interface and Stack\r\n");
    406e:	8f ec       	ldi	r24, 0xCF	; 207
    4070:	92 e1       	ldi	r25, 0x12	; 18
    4072:	ed b7       	in	r30, 0x3d	; 61
    4074:	fe b7       	in	r31, 0x3e	; 62
    4076:	92 83       	std	Z+2, r25	; 0x02
    4078:	81 83       	std	Z+1, r24	; 0x01
    407a:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	printf("Ethernet chip init\r\n");
    407e:	8a eb       	ldi	r24, 0xBA	; 186
    4080:	92 e1       	ldi	r25, 0x12	; 18
    4082:	ed b7       	in	r30, 0x3d	; 61
    4084:	fe b7       	in	r31, 0x3e	; 62
    4086:	92 83       	std	Z+2, r25	; 0x02
    4088:	81 83       	std	Z+1, r24	; 0x01
    408a:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	IpMyConfig.ethaddr.addr[0] = ETHADDR0;
    408e:	80 e3       	ldi	r24, 0x30	; 48
    4090:	80 93 e5 05 	sts	0x05E5, r24
	IpMyConfig.ethaddr.addr[1] = ETHADDR1;
    4094:	86 e4       	ldi	r24, 0x46	; 70
    4096:	80 93 e6 05 	sts	0x05E6, r24
	IpMyConfig.ethaddr.addr[2] = ETHADDR2;
    409a:	80 93 e7 05 	sts	0x05E7, r24
	IpMyConfig.ethaddr.addr[3] = ETHADDR3;
    409e:	89 e4       	ldi	r24, 0x49	; 73
    40a0:	80 93 e8 05 	sts	0x05E8, r24
	IpMyConfig.ethaddr.addr[4] = ETHADDR4;
    40a4:	83 e4       	ldi	r24, 0x43	; 67
    40a6:	80 93 e9 05 	sts	0x05E9, r24
	IpMyConfig.ethaddr.addr[5] = ETHADDR5;
    40aa:	85 e4       	ldi	r24, 0x45	; 69
    40ac:	80 93 ea 05 	sts	0x05EA, r24
	IpMyConfig.ip = IPADDRESS;
    40b0:	c9 ed       	ldi	r28, 0xD9	; 217
    40b2:	d5 e0       	ldi	r29, 0x05	; 5
    40b4:	18 82       	st	Y, r1
    40b6:	19 82       	std	Y+1, r1	; 0x01
    40b8:	1a 82       	std	Y+2, r1	; 0x02
    40ba:	1b 82       	std	Y+3, r1	; 0x03
	IpMyConfig.netmask = NETMASK;
    40bc:	1c 82       	std	Y+4, r1	; 0x04
    40be:	1d 82       	std	Y+5, r1	; 0x05
    40c0:	1e 82       	std	Y+6, r1	; 0x06
    40c2:	1f 82       	std	Y+7, r1	; 0x07
	IpMyConfig.gateway = GATEWAY;
    40c4:	18 86       	std	Y+8, r1	; 0x08
    40c6:	19 86       	std	Y+9, r1	; 0x09
    40c8:	1a 86       	std	Y+10, r1	; 0x0a
    40ca:	1b 86       	std	Y+11, r1	; 0x0b
	netInit(IpMyConfig.ip, IpMyConfig.netmask, IpMyConfig.gateway);
    40cc:	0f 90       	pop	r0
    40ce:	0f 90       	pop	r0
    40d0:	60 e0       	ldi	r22, 0x00	; 0
    40d2:	70 e0       	ldi	r23, 0x00	; 0
    40d4:	cb 01       	movw	r24, r22
    40d6:	20 e0       	ldi	r18, 0x00	; 0
    40d8:	30 e0       	ldi	r19, 0x00	; 0
    40da:	a9 01       	movw	r20, r18
    40dc:	ee 24       	eor	r14, r14
    40de:	ff 24       	eor	r15, r15
    40e0:	87 01       	movw	r16, r14
    40e2:	0e 94 85 1f 	call	0x3f0a	; 0x3f0a <netInit>
	PrintIPConfig();
    40e6:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <PrintIPConfig>
	printf("Getting IP Address....\r\n");
    40ea:	00 d0       	rcall	.+0      	; 0x40ec <EthernetInit+0x9c>
    40ec:	81 ea       	ldi	r24, 0xA1	; 161
    40ee:	92 e1       	ldi	r25, 0x12	; 18
    40f0:	ed b7       	in	r30, 0x3d	; 61
    40f2:	fe b7       	in	r31, 0x3e	; 62
    40f4:	92 83       	std	Z+2, r25	; 0x02
    40f6:	81 83       	std	Z+1, r24	; 0x01
    40f8:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <printfP>
	if(IpMyConfig.ip == 0x00000000){
    40fc:	0f 90       	pop	r0
    40fe:	0f 90       	pop	r0
    4100:	88 81       	ld	r24, Y
    4102:	99 81       	ldd	r25, Y+1	; 0x01
    4104:	aa 81       	ldd	r26, Y+2	; 0x02
    4106:	bb 81       	ldd	r27, Y+3	; 0x03
    4108:	00 97       	sbiw	r24, 0x00	; 0
    410a:	a1 05       	cpc	r26, r1
    410c:	b1 05       	cpc	r27, r1
    410e:	11 f4       	brne	.+4      	; 0x4114 <EthernetInit+0xc4>
		dhcpInit();
    4110:	0e 94 b3 0c 	call	0x1966	; 0x1966 <dhcpInit>
	}
	TCPCreateSession(80,httpDataIn);
    4114:	80 e5       	ldi	r24, 0x50	; 80
    4116:	90 e0       	ldi	r25, 0x00	; 0
    4118:	66 ee       	ldi	r22, 0xE6	; 230
    411a:	78 e1       	ldi	r23, 0x18	; 24
    411c:	0e 94 e7 20 	call	0x41ce	; 0x41ce <TCPCreateSession>
	//httpInit();
}
    4120:	df 91       	pop	r29
    4122:	cf 91       	pop	r28
    4124:	1f 91       	pop	r17
    4126:	0f 91       	pop	r16
    4128:	ff 90       	pop	r15
    412a:	ef 90       	pop	r14
    412c:	08 95       	ret

0000412e <Demo>:
void Demo (void)
{
	ON1
    412e:	af 98       	cbi	0x15, 7	; 21
	ON3
    4130:	ad 98       	cbi	0x15, 5	; 21
}
    4132:	08 95       	ret

00004134 <main>:
//--------------------------------------------------------------------------------------
int	main()
{
	SystemInit();
    4134:	0e 94 18 20 	call	0x4030	; 0x4030 <SystemInit>
	EthernetInit();
    4138:	0e 94 28 20 	call	0x4050	; 0x4050 <EthernetInit>
	Demo();
    413c:	0e 94 97 20 	call	0x412e	; 0x412e <Demo>
	while(1)
	{
		//if(IpMyConfig.ip == 0x00000000)	dhcpInit();
		ethService();
    4140:	0e 94 78 15 	call	0x2af0	; 0x2af0 <ethService>
		dhcpService();
    4144:	0e 94 20 13 	call	0x2640	; 0x2640 <dhcpService>
    4148:	fb cf       	rjmp	.-10     	; 0x4140 <main+0xc>

0000414a <TCPInitSequenceNumber>:
//Ham khoi tao so tuan tu cho mot phien TCP
// Hien tai su dung gia tri 1234 (may tinh thuong dung gia tri thoi gian hien tai)
unsigned long TCPInitSequenceNumber()
{
	return(1234);
}
    414a:	62 ed       	ldi	r22, 0xD2	; 210
    414c:	74 e0       	ldi	r23, 0x04	; 4
    414e:	80 e0       	ldi	r24, 0x00	; 0
    4150:	90 e0       	ldi	r25, 0x00	; 0
    4152:	08 95       	ret

00004154 <TCPCloseSession>:

//--------------------------------------------------------------------------------------
//Ham dong mot phien TCP
void TCPCloseSession(unsigned char socketnum)
{
	tcpSessionTable[socketnum].sesState = TCP_STATE_CLOSED;
    4154:	90 e0       	ldi	r25, 0x00	; 0
    4156:	2f e1       	ldi	r18, 0x1F	; 31
    4158:	30 e0       	ldi	r19, 0x00	; 0
    415a:	82 9f       	mul	r24, r18
    415c:	f0 01       	movw	r30, r0
    415e:	83 9f       	mul	r24, r19
    4160:	f0 0d       	add	r31, r0
    4162:	92 9f       	mul	r25, r18
    4164:	f0 0d       	add	r31, r0
    4166:	11 24       	eor	r1, r1
    4168:	e5 51       	subi	r30, 0x15	; 21
    416a:	fa 4f       	sbci	r31, 0xFA	; 250
    416c:	10 8a       	std	Z+16, r1	; 0x10
	#ifdef TCP_DEBUG
	printf("Close TCP session %d\r\n",socketnum);
	#endif
}
    416e:	08 95       	ret

00004170 <TCPInit>:

//--------------------------------------------------------------------------------------
//Khoi dong cac gia tri trong bang TCP session
void TCPInit()
{
    4170:	1f 93       	push	r17
	unsigned char i = 0;
	for(i=0; i<TCP_MAX_SESSION; i++){
    4172:	10 e0       	ldi	r17, 0x00	; 0
		TCPCloseSession(i);
    4174:	81 2f       	mov	r24, r17
    4176:	0e 94 aa 20 	call	0x4154	; 0x4154 <TCPCloseSession>
//--------------------------------------------------------------------------------------
//Khoi dong cac gia tri trong bang TCP session
void TCPInit()
{
	unsigned char i = 0;
	for(i=0; i<TCP_MAX_SESSION; i++){
    417a:	1f 5f       	subi	r17, 0xFF	; 255
    417c:	18 30       	cpi	r17, 0x08	; 8
    417e:	d1 f7       	brne	.-12     	; 0x4174 <TCPInit+0x4>
		TCPCloseSession(i);
	}
}
    4180:	1f 91       	pop	r17
    4182:	08 95       	ret

00004184 <TCPGetFreeSession>:

//--------------------------------------------------------------------------------------
//Tim mot session TCP dang roi
unsigned char TCPGetFreeSession(){
    4184:	1f 93       	push	r17
	unsigned char i;
	for(i=0; i<TCP_MAX_SESSION; i++){
		if (tcpSessionTable[i].sesState == TCP_STATE_CLOSED)
    4186:	90 91 fb 05 	lds	r25, 0x05FB
    418a:	99 23       	and	r25, r25
    418c:	e1 f0       	breq	.+56     	; 0x41c6 <TCPGetFreeSession+0x42>
    418e:	aa e1       	ldi	r26, 0x1A	; 26
    4190:	b6 e0       	ldi	r27, 0x06	; 6
    4192:	fd 01       	movw	r30, r26

//--------------------------------------------------------------------------------------
//Tim mot session TCP dang roi
unsigned char TCPGetFreeSession(){
	unsigned char i;
	for(i=0; i<TCP_MAX_SESSION; i++){
    4194:	11 e0       	ldi	r17, 0x01	; 1
		if (tcpSessionTable[i].sesState == TCP_STATE_CLOSED)
    4196:	80 81       	ld	r24, Z
    4198:	88 23       	and	r24, r24
    419a:	b1 f0       	breq	.+44     	; 0x41c8 <TCPGetFreeSession+0x44>

//--------------------------------------------------------------------------------------
//Tim mot session TCP dang roi
unsigned char TCPGetFreeSession(){
	unsigned char i;
	for(i=0; i<TCP_MAX_SESSION; i++){
    419c:	1f 5f       	subi	r17, 0xFF	; 255
    419e:	7f 96       	adiw	r30, 0x1f	; 31
    41a0:	18 30       	cpi	r17, 0x08	; 8
    41a2:	c9 f7       	brne	.-14     	; 0x4196 <TCPGetFreeSession+0x12>
		if (tcpSessionTable[i].sesState == TCP_STATE_CLOSED)
			return i;
	}
	//no free closed socket fount! -> kick an TIMED_WAIT socket
	for(i=0; i<TCP_MAX_SESSION; i++){
		if (tcpSessionTable[i].sesState == TCP_STATE_TIMED_WAIT){
    41a4:	98 30       	cpi	r25, 0x08	; 8
    41a6:	29 f0       	breq	.+10     	; 0x41b2 <TCPGetFreeSession+0x2e>
	for(i=0; i<TCP_MAX_SESSION; i++){
		if (tcpSessionTable[i].sesState == TCP_STATE_CLOSED)
			return i;
	}
	//no free closed socket fount! -> kick an TIMED_WAIT socket
	for(i=0; i<TCP_MAX_SESSION; i++){
    41a8:	11 e0       	ldi	r17, 0x01	; 1
		if (tcpSessionTable[i].sesState == TCP_STATE_TIMED_WAIT){
    41aa:	8c 91       	ld	r24, X
    41ac:	88 30       	cpi	r24, 0x08	; 8
    41ae:	31 f4       	brne	.+12     	; 0x41bc <TCPGetFreeSession+0x38>
    41b0:	01 c0       	rjmp	.+2      	; 0x41b4 <TCPGetFreeSession+0x30>
    41b2:	10 e0       	ldi	r17, 0x00	; 0
			TCPCloseSession(i);
    41b4:	81 2f       	mov	r24, r17
    41b6:	0e 94 aa 20 	call	0x4154	; 0x4154 <TCPCloseSession>
			return i;
    41ba:	06 c0       	rjmp	.+12     	; 0x41c8 <TCPGetFreeSession+0x44>
	for(i=0; i<TCP_MAX_SESSION; i++){
		if (tcpSessionTable[i].sesState == TCP_STATE_CLOSED)
			return i;
	}
	//no free closed socket fount! -> kick an TIMED_WAIT socket
	for(i=0; i<TCP_MAX_SESSION; i++){
    41bc:	1f 5f       	subi	r17, 0xFF	; 255
    41be:	5f 96       	adiw	r26, 0x1f	; 31
    41c0:	18 30       	cpi	r17, 0x08	; 8
    41c2:	99 f7       	brne	.-26     	; 0x41aa <TCPGetFreeSession+0x26>
    41c4:	01 c0       	rjmp	.+2      	; 0x41c8 <TCPGetFreeSession+0x44>

//--------------------------------------------------------------------------------------
//Tim mot session TCP dang roi
unsigned char TCPGetFreeSession(){
	unsigned char i;
	for(i=0; i<TCP_MAX_SESSION; i++){
    41c6:	10 e0       	ldi	r17, 0x00	; 0
			return i;
		}
	}
	//no more free sockets ... return invalid val	
	return(TCP_MAX_SESSION);
}
    41c8:	81 2f       	mov	r24, r17
    41ca:	1f 91       	pop	r17
    41cc:	08 95       	ret

000041ce <TCPCreateSession>:

//--------------------------------------------------------------------------------------
//Ham khoi tao mot session TCP o che do server de cho ket noi
void	TCPCreateSession(unsigned int  sourcePort, prog_void* appService)
{
    41ce:	0f 93       	push	r16
    41d0:	1f 93       	push	r17
    41d2:	cf 93       	push	r28
    41d4:	df 93       	push	r29
    41d6:	ec 01       	movw	r28, r24
    41d8:	8b 01       	movw	r16, r22
	unsigned char i;
	i = TCPGetFreeSession();
    41da:	0e 94 c2 20 	call	0x4184	; 0x4184 <TCPGetFreeSession>
	if(i >= TCP_MAX_SESSION)
    41de:	88 30       	cpi	r24, 0x08	; 8
    41e0:	08 f0       	brcs	.+2      	; 0x41e4 <TCPCreateSession+0x16>
		i = 0;	//force session 0
    41e2:	80 e0       	ldi	r24, 0x00	; 0
	tcpSessionTable[i].srcPort = sourcePort;
    41e4:	90 e0       	ldi	r25, 0x00	; 0
    41e6:	2f e1       	ldi	r18, 0x1F	; 31
    41e8:	30 e0       	ldi	r19, 0x00	; 0
    41ea:	82 9f       	mul	r24, r18
    41ec:	f0 01       	movw	r30, r0
    41ee:	83 9f       	mul	r24, r19
    41f0:	f0 0d       	add	r31, r0
    41f2:	92 9f       	mul	r25, r18
    41f4:	f0 0d       	add	r31, r0
    41f6:	11 24       	eor	r1, r1
    41f8:	e5 51       	subi	r30, 0x15	; 21
    41fa:	fa 4f       	sbci	r31, 0xFA	; 250
    41fc:	d3 83       	std	Z+3, r29	; 0x03
    41fe:	c2 83       	std	Z+2, r28	; 0x02
	tcpSessionTable[i].sesState = TCP_STATE_LISTEN;		//Current state of TCP session
    4200:	82 e0       	ldi	r24, 0x02	; 2
    4202:	80 8b       	std	Z+16, r24	; 0x10
	tcpSessionTable[i].srcWin = 8192;//NETSTACK_BUFFERSIZE - ETH_HEADER_LEN - IP_HEADER_LEN - TCP_HEADER_LEN - 16;
    4204:	80 e0       	ldi	r24, 0x00	; 0
    4206:	90 e2       	ldi	r25, 0x20	; 32
    4208:	92 8b       	std	Z+18, r25	; 0x12
    420a:	81 8b       	std	Z+17, r24	; 0x11
	tcpSessionTable[i].desWin = tcpSessionTable[i].srcWin;
    420c:	94 8b       	std	Z+20, r25	; 0x14
    420e:	83 8b       	std	Z+19, r24	; 0x13
	tcpSessionTable[i].timeOut = TCP_TIMEOUT;		//Session time out
    4210:	8c e3       	ldi	r24, 0x3C	; 60
    4212:	82 8f       	std	Z+26, r24	; 0x1a
	tcpSessionTable[i].appDataIn = appService;
    4214:	14 8f       	std	Z+28, r17	; 0x1c
    4216:	03 8f       	std	Z+27, r16	; 0x1b
	#ifdef TCP_DEBUG
	printf("TCP session created: %d\r\n", i);
	#endif

}
    4218:	df 91       	pop	r29
    421a:	cf 91       	pop	r28
    421c:	1f 91       	pop	r17
    421e:	0f 91       	pop	r16
    4220:	08 95       	ret

00004222 <TCPCheckTimeOut>:

//--------------------------------------------------------------------------------------
//Duoc goi moi giay de kiem tra Time out cho cac phien TCP,
// giai phong cac phine TCP bi treo
void TCPCheckTimeOut(){
    4222:	1f 93       	push	r17
    4224:	cf 93       	push	r28
    4226:	df 93       	push	r29
	unsigned char i;
	for(i=0; i<TCP_MAX_SESSION; i++){
    4228:	cb ef       	ldi	r28, 0xFB	; 251
    422a:	d5 e0       	ldi	r29, 0x05	; 5
    422c:	10 e0       	ldi	r17, 0x00	; 0
		//decrement ttl:
		if ((tcpSessionTable[i].sesState != TCP_STATE_CLOSED) && (tcpSessionTable[i].sesState != TCP_STATE_LISTEN)){
    422e:	88 81       	ld	r24, Y
    4230:	88 23       	and	r24, r24
    4232:	61 f0       	breq	.+24     	; 0x424c <TCPCheckTimeOut+0x2a>
    4234:	82 30       	cpi	r24, 0x02	; 2
    4236:	51 f0       	breq	.+20     	; 0x424c <TCPCheckTimeOut+0x2a>
			if(tcpSessionTable[i].timeOut)
    4238:	8a 85       	ldd	r24, Y+10	; 0x0a
    423a:	88 23       	and	r24, r24
    423c:	21 f0       	breq	.+8      	; 0x4246 <TCPCheckTimeOut+0x24>
				tcpSessionTable[i].timeOut--;
    423e:	81 50       	subi	r24, 0x01	; 1
    4240:	8a 87       	std	Y+10, r24	; 0x0a
			
			//if socket TTL count is zero, close this socket!
			if (tcpSessionTable[i].timeOut == 0){
    4242:	88 23       	and	r24, r24
    4244:	19 f4       	brne	.+6      	; 0x424c <TCPCheckTimeOut+0x2a>
				TCPCloseSession(i);
    4246:	81 2f       	mov	r24, r17
    4248:	0e 94 aa 20 	call	0x4154	; 0x4154 <TCPCloseSession>
//--------------------------------------------------------------------------------------
//Duoc goi moi giay de kiem tra Time out cho cac phien TCP,
// giai phong cac phine TCP bi treo
void TCPCheckTimeOut(){
	unsigned char i;
	for(i=0; i<TCP_MAX_SESSION; i++){
    424c:	1f 5f       	subi	r17, 0xFF	; 255
    424e:	6f 96       	adiw	r28, 0x1f	; 31
    4250:	18 30       	cpi	r17, 0x08	; 8
    4252:	69 f7       	brne	.-38     	; 0x422e <TCPCheckTimeOut+0xc>
			if (tcpSessionTable[i].timeOut == 0){
				TCPCloseSession(i);
			}
		}
	}
}
    4254:	df 91       	pop	r29
    4256:	cf 91       	pop	r28
    4258:	1f 91       	pop	r17
    425a:	08 95       	ret

0000425c <checksum>:

//--------------------------------------------------------------------------------------
//Tinh checksum cho goi TCP
unsigned int checksum(unsigned char *buffer, unsigned int len, unsigned long csum32)
{
    425c:	ef 92       	push	r14
    425e:	ff 92       	push	r15
    4260:	0f 93       	push	r16
    4262:	1f 93       	push	r17
    4264:	cf 93       	push	r28
    4266:	df 93       	push	r29
    4268:	7c 01       	movw	r14, r24
    426a:	8b 01       	movw	r16, r22
	unsigned int  res16 = 0x0000;
	unsigned char data_hi;
	unsigned char data_lo;
	while(len > 1){
    426c:	62 30       	cpi	r22, 0x02	; 2
    426e:	71 05       	cpc	r23, r1
    4270:	f0 f0       	brcs	.+60     	; 0x42ae <checksum+0x52>
    4272:	ec 01       	movw	r28, r24
		data_hi = *buffer++;
    4274:	98 81       	ld	r25, Y
		data_lo = *buffer++;
    4276:	89 81       	ldd	r24, Y+1	; 0x01
	}
}

//--------------------------------------------------------------------------------------
//Tinh checksum cho goi TCP
unsigned int checksum(unsigned char *buffer, unsigned int len, unsigned long csum32)
    4278:	22 96       	adiw	r28, 0x02	; 2
	unsigned char data_hi;
	unsigned char data_lo;
	while(len > 1){
		data_hi = *buffer++;
		data_lo = *buffer++;
		res16 = (((unsigned int)data_hi << 8) + data_lo);
    427a:	f9 2f       	mov	r31, r25
    427c:	e0 e0       	ldi	r30, 0x00	; 0
    427e:	df 01       	movw	r26, r30
    4280:	a8 0f       	add	r26, r24
    4282:	b1 1d       	adc	r27, r1
		csum32 = csum32 + res16;
    4284:	cd 01       	movw	r24, r26
    4286:	a0 e0       	ldi	r26, 0x00	; 0
    4288:	b0 e0       	ldi	r27, 0x00	; 0
    428a:	28 0f       	add	r18, r24
    428c:	39 1f       	adc	r19, r25
    428e:	4a 1f       	adc	r20, r26
    4290:	5b 1f       	adc	r21, r27
		len -=2;
    4292:	62 50       	subi	r22, 0x02	; 2
    4294:	70 40       	sbci	r23, 0x00	; 0
unsigned int checksum(unsigned char *buffer, unsigned int len, unsigned long csum32)
{
	unsigned int  res16 = 0x0000;
	unsigned char data_hi;
	unsigned char data_lo;
	while(len > 1){
    4296:	62 30       	cpi	r22, 0x02	; 2
    4298:	71 05       	cpc	r23, r1
    429a:	60 f7       	brcc	.-40     	; 0x4274 <checksum+0x18>
	}
}

//--------------------------------------------------------------------------------------
//Tinh checksum cho goi TCP
unsigned int checksum(unsigned char *buffer, unsigned int len, unsigned long csum32)
    429c:	02 50       	subi	r16, 0x02	; 2
    429e:	10 40       	sbci	r17, 0x00	; 0
    42a0:	c8 01       	movw	r24, r16
    42a2:	8e 7f       	andi	r24, 0xFE	; 254
    42a4:	02 96       	adiw	r24, 0x02	; 2
    42a6:	e8 0e       	add	r14, r24
    42a8:	f9 1e       	adc	r15, r25
    42aa:	01 70       	andi	r16, 0x01	; 1
    42ac:	10 70       	andi	r17, 0x00	; 0
		data_lo = *buffer++;
		res16 = (((unsigned int)data_hi << 8) + data_lo);
		csum32 = csum32 + res16;
		len -=2;
	}
	if(len > 0){
    42ae:	01 15       	cp	r16, r1
    42b0:	11 05       	cpc	r17, r1
    42b2:	49 f0       	breq	.+18     	; 0x42c6 <checksum+0x6a>
		data_hi = *buffer;
		res16   = (unsigned int)data_hi<<8;
    42b4:	f7 01       	movw	r30, r14
    42b6:	90 81       	ld	r25, Z
    42b8:	80 e0       	ldi	r24, 0x00	; 0
		csum32 = csum32 + res16;
    42ba:	a0 e0       	ldi	r26, 0x00	; 0
    42bc:	b0 e0       	ldi	r27, 0x00	; 0
    42be:	28 0f       	add	r18, r24
    42c0:	39 1f       	adc	r19, r25
    42c2:	4a 1f       	adc	r20, r26
    42c4:	5b 1f       	adc	r21, r27
	}
	while(csum32>>16)
    42c6:	ca 01       	movw	r24, r20
    42c8:	aa 27       	eor	r26, r26
    42ca:	bb 27       	eor	r27, r27
    42cc:	00 97       	sbiw	r24, 0x00	; 0
    42ce:	a1 05       	cpc	r26, r1
    42d0:	b1 05       	cpc	r27, r1
    42d2:	69 f0       	breq	.+26     	; 0x42ee <checksum+0x92>
		csum32 = (csum32 & 0xFFFF)+ (csum32 >> 16);
    42d4:	40 70       	andi	r20, 0x00	; 0
    42d6:	50 70       	andi	r21, 0x00	; 0
    42d8:	28 0f       	add	r18, r24
    42da:	39 1f       	adc	r19, r25
    42dc:	4a 1f       	adc	r20, r26
    42de:	5b 1f       	adc	r21, r27
	if(len > 0){
		data_hi = *buffer;
		res16   = (unsigned int)data_hi<<8;
		csum32 = csum32 + res16;
	}
	while(csum32>>16)
    42e0:	ca 01       	movw	r24, r20
    42e2:	aa 27       	eor	r26, r26
    42e4:	bb 27       	eor	r27, r27
    42e6:	00 97       	sbiw	r24, 0x00	; 0
    42e8:	a1 05       	cpc	r26, r1
    42ea:	b1 05       	cpc	r27, r1
    42ec:	99 f7       	brne	.-26     	; 0x42d4 <checksum+0x78>
		csum32 = (csum32 & 0xFFFF)+ (csum32 >> 16);
	//csum32 = ((csum32 & 0x0000FFFF)+ ((csum32 & 0xFFFF0000) >> 16));	
	res16  =~(csum32 & 0x0000FFFF);
    42ee:	20 95       	com	r18
    42f0:	30 95       	com	r19
	return (res16);
}
    42f2:	82 2f       	mov	r24, r18
    42f4:	93 2f       	mov	r25, r19
    42f6:	df 91       	pop	r29
    42f8:	cf 91       	pop	r28
    42fa:	1f 91       	pop	r17
    42fc:	0f 91       	pop	r16
    42fe:	ff 90       	pop	r15
    4300:	ef 90       	pop	r14
    4302:	08 95       	ret

00004304 <TCPPackedSend>:
//--------------------------------------------------------------------------------------
//Gui di mot goi TCP
void TCPPackedSend(struct tcpSession *pSession, unsigned char Flags, unsigned int len, unsigned char *dataBuffer)
{
    4304:	2f 92       	push	r2
    4306:	3f 92       	push	r3
    4308:	4f 92       	push	r4
    430a:	5f 92       	push	r5
    430c:	6f 92       	push	r6
    430e:	7f 92       	push	r7
    4310:	8f 92       	push	r8
    4312:	9f 92       	push	r9
    4314:	af 92       	push	r10
    4316:	bf 92       	push	r11
    4318:	cf 92       	push	r12
    431a:	df 92       	push	r13
    431c:	ef 92       	push	r14
    431e:	ff 92       	push	r15
    4320:	0f 93       	push	r16
    4322:	1f 93       	push	r17
    4324:	df 93       	push	r29
    4326:	cf 93       	push	r28
    4328:	00 d0       	rcall	.+0      	; 0x432a <TCPPackedSend+0x26>
    432a:	00 d0       	rcall	.+0      	; 0x432c <TCPPackedSend+0x28>
    432c:	cd b7       	in	r28, 0x3d	; 61
    432e:	de b7       	in	r29, 0x3e	; 62
    4330:	5c 01       	movw	r10, r24
    4332:	26 2e       	mov	r2, r22
    4334:	6a 01       	movw	r12, r20
    4336:	f9 01       	movw	r30, r18
	unsigned long checksum32;
	//Make pointer to TCP header
	struct ntTCPHeader* tcpHeader;
	struct ntIPHeader* ipHeader;
	//Neu dang syn thi them option ve MSS
	if(Flags & TCP_SYN_FLAG){
    4338:	70 e0       	ldi	r23, 0x00	; 0
    433a:	66 24       	eor	r6, r6
    433c:	77 24       	eor	r7, r7
    433e:	68 94       	set
    4340:	61 f8       	bld	r6, 1
    4342:	66 22       	and	r6, r22
    4344:	77 22       	and	r7, r23
    4346:	61 ff       	sbrs	r22, 1
    4348:	0d c0       	rjmp	.+26     	; 0x4364 <TCPPackedSend+0x60>
		//Option data
		dataBuffer[0] = 0x02;
    434a:	82 e0       	ldi	r24, 0x02	; 2
    434c:	80 83       	st	Z, r24
		dataBuffer[1] = 0x04;
    434e:	84 e0       	ldi	r24, 0x04	; 4
    4350:	81 83       	std	Z+1, r24	; 0x01
		dataBuffer[2] = (MAX_SEGMENT_SIZE >> 8) & 0xff;
    4352:	83 e0       	ldi	r24, 0x03	; 3
    4354:	82 83       	std	Z+2, r24	; 0x02
		dataBuffer[3] = MAX_SEGMENT_SIZE & 0xff;
    4356:	98 ee       	ldi	r25, 0xE8	; 232
    4358:	93 83       	std	Z+3, r25	; 0x03
		dataBuffer[4] = 0x01;
    435a:	91 e0       	ldi	r25, 0x01	; 1
    435c:	94 83       	std	Z+4, r25	; 0x04
		dataBuffer[5] = 0x03;
    435e:	85 83       	std	Z+5, r24	; 0x05
		dataBuffer[6] = 0x03;
    4360:	86 83       	std	Z+6, r24	; 0x06
		dataBuffer[7] = 0x00;
    4362:	17 82       	std	Z+7, r1	; 0x07
		//Move data pointer to make room for TCP header
	}
	dataBuffer -= TCP_HEADER_LEN;
    4364:	cf 01       	movw	r24, r30
    4366:	44 97       	sbiw	r24, 0x14	; 20
    4368:	9c 83       	std	Y+4, r25	; 0x04
    436a:	8b 83       	std	Y+3, r24	; 0x03
	tcpHeader = (struct ntTCPHeader*)dataBuffer;
	//Fill UDP header
	tcpHeader->srcPort = HTONS(pSession->srcPort);
    436c:	d5 01       	movw	r26, r10
    436e:	12 96       	adiw	r26, 0x02	; 2
    4370:	8d 91       	ld	r24, X+
    4372:	9c 91       	ld	r25, X
    4374:	13 97       	sbiw	r26, 0x03	; 3
    4376:	98 27       	eor	r25, r24
    4378:	89 27       	eor	r24, r25
    437a:	98 27       	eor	r25, r24
    437c:	eb 81       	ldd	r30, Y+3	; 0x03
    437e:	fc 81       	ldd	r31, Y+4	; 0x04
    4380:	91 83       	std	Z+1, r25	; 0x01
    4382:	80 83       	st	Z, r24
	tcpHeader->desPort = HTONS(pSession->desPort);
    4384:	8d 91       	ld	r24, X+
    4386:	9c 91       	ld	r25, X
    4388:	11 97       	sbiw	r26, 0x01	; 1
    438a:	98 27       	eor	r25, r24
    438c:	89 27       	eor	r24, r25
    438e:	98 27       	eor	r25, r24
    4390:	93 83       	std	Z+3, r25	; 0x03
    4392:	82 83       	std	Z+2, r24	; 0x02
	tcpHeader->seqNumber = HTONL(pSession->seqNumber);
    4394:	18 96       	adiw	r26, 0x08	; 8
    4396:	8d 91       	ld	r24, X+
    4398:	9d 91       	ld	r25, X+
    439a:	0d 90       	ld	r0, X+
    439c:	bc 91       	ld	r27, X
    439e:	a0 2d       	mov	r26, r0
    43a0:	eb 2e       	mov	r14, r27
    43a2:	ff 24       	eor	r15, r15
    43a4:	00 27       	eor	r16, r16
    43a6:	11 27       	eor	r17, r17
    43a8:	58 2f       	mov	r21, r24
    43aa:	44 27       	eor	r20, r20
    43ac:	33 27       	eor	r19, r19
    43ae:	22 27       	eor	r18, r18
    43b0:	e2 2a       	or	r14, r18
    43b2:	f3 2a       	or	r15, r19
    43b4:	04 2b       	or	r16, r20
    43b6:	15 2b       	or	r17, r21
    43b8:	9c 01       	movw	r18, r24
    43ba:	ad 01       	movw	r20, r26
    43bc:	20 70       	andi	r18, 0x00	; 0
    43be:	30 70       	andi	r19, 0x00	; 0
    43c0:	50 70       	andi	r21, 0x00	; 0
    43c2:	23 2f       	mov	r18, r19
    43c4:	34 2f       	mov	r19, r20
    43c6:	45 2f       	mov	r20, r21
    43c8:	55 27       	eor	r21, r21
    43ca:	2e 29       	or	r18, r14
    43cc:	3f 29       	or	r19, r15
    43ce:	40 2b       	or	r20, r16
    43d0:	51 2b       	or	r21, r17
    43d2:	80 70       	andi	r24, 0x00	; 0
    43d4:	a0 70       	andi	r26, 0x00	; 0
    43d6:	b0 70       	andi	r27, 0x00	; 0
    43d8:	ee 24       	eor	r14, r14
    43da:	f8 2e       	mov	r15, r24
    43dc:	09 2f       	mov	r16, r25
    43de:	1a 2f       	mov	r17, r26
    43e0:	2e 29       	or	r18, r14
    43e2:	3f 29       	or	r19, r15
    43e4:	40 2b       	or	r20, r16
    43e6:	51 2b       	or	r21, r17
    43e8:	24 83       	std	Z+4, r18	; 0x04
    43ea:	35 83       	std	Z+5, r19	; 0x05
    43ec:	46 83       	std	Z+6, r20	; 0x06
    43ee:	57 83       	std	Z+7, r21	; 0x07
	pSession->seqNumber = pSession->seqNumber + len;
    43f0:	96 01       	movw	r18, r12
    43f2:	40 e0       	ldi	r20, 0x00	; 0
    43f4:	50 e0       	ldi	r21, 0x00	; 0
    43f6:	f5 01       	movw	r30, r10
    43f8:	80 85       	ldd	r24, Z+8	; 0x08
    43fa:	91 85       	ldd	r25, Z+9	; 0x09
    43fc:	a2 85       	ldd	r26, Z+10	; 0x0a
    43fe:	b3 85       	ldd	r27, Z+11	; 0x0b
    4400:	82 0f       	add	r24, r18
    4402:	93 1f       	adc	r25, r19
    4404:	a4 1f       	adc	r26, r20
    4406:	b5 1f       	adc	r27, r21
    4408:	80 87       	std	Z+8, r24	; 0x08
    440a:	91 87       	std	Z+9, r25	; 0x09
    440c:	a2 87       	std	Z+10, r26	; 0x0a
    440e:	b3 87       	std	Z+11, r27	; 0x0b
	if(Flags & (TCP_FIN_FLAG|TCP_SYN_FLAG))
    4410:	63 70       	andi	r22, 0x03	; 3
    4412:	70 70       	andi	r23, 0x00	; 0
    4414:	61 15       	cp	r22, r1
    4416:	71 05       	cpc	r23, r1
    4418:	39 f0       	breq	.+14     	; 0x4428 <TCPPackedSend+0x124>
		(pSession->seqNumber)++;
    441a:	01 96       	adiw	r24, 0x01	; 1
    441c:	a1 1d       	adc	r26, r1
    441e:	b1 1d       	adc	r27, r1
    4420:	80 87       	std	Z+8, r24	; 0x08
    4422:	91 87       	std	Z+9, r25	; 0x09
    4424:	a2 87       	std	Z+10, r26	; 0x0a
    4426:	b3 87       	std	Z+11, r27	; 0x0b
	tcpHeader->ackNumber = HTONL(pSession->ackNumber);
    4428:	f5 01       	movw	r30, r10
    442a:	84 85       	ldd	r24, Z+12	; 0x0c
    442c:	95 85       	ldd	r25, Z+13	; 0x0d
    442e:	a6 85       	ldd	r26, Z+14	; 0x0e
    4430:	b7 85       	ldd	r27, Z+15	; 0x0f
    4432:	eb 2e       	mov	r14, r27
    4434:	ff 24       	eor	r15, r15
    4436:	00 27       	eor	r16, r16
    4438:	11 27       	eor	r17, r17
    443a:	58 2f       	mov	r21, r24
    443c:	44 27       	eor	r20, r20
    443e:	33 27       	eor	r19, r19
    4440:	22 27       	eor	r18, r18
    4442:	e2 2a       	or	r14, r18
    4444:	f3 2a       	or	r15, r19
    4446:	04 2b       	or	r16, r20
    4448:	15 2b       	or	r17, r21
    444a:	9c 01       	movw	r18, r24
    444c:	ad 01       	movw	r20, r26
    444e:	20 70       	andi	r18, 0x00	; 0
    4450:	30 70       	andi	r19, 0x00	; 0
    4452:	50 70       	andi	r21, 0x00	; 0
    4454:	23 2f       	mov	r18, r19
    4456:	34 2f       	mov	r19, r20
    4458:	45 2f       	mov	r20, r21
    445a:	55 27       	eor	r21, r21
    445c:	2e 29       	or	r18, r14
    445e:	3f 29       	or	r19, r15
    4460:	40 2b       	or	r20, r16
    4462:	51 2b       	or	r21, r17
    4464:	80 70       	andi	r24, 0x00	; 0
    4466:	a0 70       	andi	r26, 0x00	; 0
    4468:	b0 70       	andi	r27, 0x00	; 0
    446a:	ee 24       	eor	r14, r14
    446c:	f8 2e       	mov	r15, r24
    446e:	09 2f       	mov	r16, r25
    4470:	1a 2f       	mov	r17, r26
    4472:	2e 29       	or	r18, r14
    4474:	3f 29       	or	r19, r15
    4476:	40 2b       	or	r20, r16
    4478:	51 2b       	or	r21, r17
    447a:	ab 81       	ldd	r26, Y+3	; 0x03
    447c:	bc 81       	ldd	r27, Y+4	; 0x04
    447e:	18 96       	adiw	r26, 0x08	; 8
    4480:	2d 93       	st	X+, r18
    4482:	3d 93       	st	X+, r19
    4484:	4d 93       	st	X+, r20
    4486:	5c 93       	st	X, r21
    4488:	1b 97       	sbiw	r26, 0x0b	; 11
	if(Flags & TCP_SYN_FLAG){
    448a:	61 14       	cp	r6, r1
    448c:	71 04       	cpc	r7, r1
    448e:	49 f0       	breq	.+18     	; 0x44a2 <TCPPackedSend+0x19e>
		tcpHeader->Offset = (0x07<<4);
    4490:	80 e7       	ldi	r24, 0x70	; 112
    4492:	1c 96       	adiw	r26, 0x0c	; 12
    4494:	8c 93       	st	X, r24
    4496:	1c 97       	sbiw	r26, 0x0c	; 12
		len += (TCP_HEADER_LEN + 8);
    4498:	f6 01       	movw	r30, r12
    449a:	7c 96       	adiw	r30, 0x1c	; 28
    449c:	fa 83       	std	Y+2, r31	; 0x02
    449e:	e9 83       	std	Y+1, r30	; 0x01
    44a0:	09 c0       	rjmp	.+18     	; 0x44b4 <TCPPackedSend+0x1b0>
	}else{
		tcpHeader->Offset = (0x05<<4);
    44a2:	80 e5       	ldi	r24, 0x50	; 80
    44a4:	ab 81       	ldd	r26, Y+3	; 0x03
    44a6:	bc 81       	ldd	r27, Y+4	; 0x04
    44a8:	1c 96       	adiw	r26, 0x0c	; 12
    44aa:	8c 93       	st	X, r24
		len += TCP_HEADER_LEN;
    44ac:	f6 01       	movw	r30, r12
    44ae:	74 96       	adiw	r30, 0x14	; 20
    44b0:	fa 83       	std	Y+2, r31	; 0x02
    44b2:	e9 83       	std	Y+1, r30	; 0x01
	}
	tcpHeader->Flags = Flags;
    44b4:	ab 81       	ldd	r26, Y+3	; 0x03
    44b6:	bc 81       	ldd	r27, Y+4	; 0x04
    44b8:	1d 96       	adiw	r26, 0x0d	; 13
    44ba:	2c 92       	st	X, r2
    44bc:	1d 97       	sbiw	r26, 0x0d	; 13
	tcpHeader->Window = HTONS(pSession->srcWin);//((NETSTACK_BUFFERSIZE-20-14));
    44be:	f5 01       	movw	r30, r10
    44c0:	81 89       	ldd	r24, Z+17	; 0x11
    44c2:	92 89       	ldd	r25, Z+18	; 0x12
    44c4:	98 27       	eor	r25, r24
    44c6:	89 27       	eor	r24, r25
    44c8:	98 27       	eor	r25, r24
    44ca:	1f 96       	adiw	r26, 0x0f	; 15
    44cc:	9c 93       	st	X, r25
    44ce:	8e 93       	st	-X, r24
    44d0:	1e 97       	sbiw	r26, 0x0e	; 14
	tcpHeader->Checksum = 0;
    44d2:	51 96       	adiw	r26, 0x11	; 17
    44d4:	1c 92       	st	X, r1
    44d6:	1e 92       	st	-X, r1
    44d8:	50 97       	sbiw	r26, 0x10	; 16
	tcpHeader->UrgentPtr = 0x0000;
    44da:	53 96       	adiw	r26, 0x13	; 19
    44dc:	1c 92       	st	X, r1
    44de:	1e 92       	st	-X, r1
    44e0:	52 97       	sbiw	r26, 0x12	; 18
	//Generate checksum
	ipHeader = (struct ntIPHeader*)(dataBuffer-IP_HEADER_LEN);
    44e2:	8d 01       	movw	r16, r26
    44e4:	04 51       	subi	r16, 0x14	; 20
    44e6:	10 40       	sbci	r17, 0x00	; 0
	ipHeader->srcIPAddr = HTONL(ipGetConfig()->ip);
    44e8:	0e 94 b6 1b 	call	0x376c	; 0x376c <ipGetConfig>
    44ec:	dc 01       	movw	r26, r24
    44ee:	2d 90       	ld	r2, X+
    44f0:	3d 90       	ld	r3, X+
    44f2:	4d 90       	ld	r4, X+
    44f4:	5c 90       	ld	r5, X
    44f6:	52 2c       	mov	r5, r2
    44f8:	44 24       	eor	r4, r4
    44fa:	33 24       	eor	r3, r3
    44fc:	22 24       	eor	r2, r2
    44fe:	0e 94 b6 1b 	call	0x376c	; 0x376c <ipGetConfig>
    4502:	fc 01       	movw	r30, r24
    4504:	80 81       	ld	r24, Z
    4506:	91 81       	ldd	r25, Z+1	; 0x01
    4508:	a2 81       	ldd	r26, Z+2	; 0x02
    450a:	b3 81       	ldd	r27, Z+3	; 0x03
    450c:	80 70       	andi	r24, 0x00	; 0
    450e:	90 70       	andi	r25, 0x00	; 0
    4510:	b0 70       	andi	r27, 0x00	; 0
    4512:	69 2e       	mov	r6, r25
    4514:	7a 2e       	mov	r7, r26
    4516:	8b 2e       	mov	r8, r27
    4518:	99 24       	eor	r9, r9
    451a:	0e 94 b6 1b 	call	0x376c	; 0x376c <ipGetConfig>
    451e:	fc 01       	movw	r30, r24
    4520:	80 81       	ld	r24, Z
    4522:	91 81       	ldd	r25, Z+1	; 0x01
    4524:	a2 81       	ldd	r26, Z+2	; 0x02
    4526:	b3 81       	ldd	r27, Z+3	; 0x03
    4528:	80 70       	andi	r24, 0x00	; 0
    452a:	a0 70       	andi	r26, 0x00	; 0
    452c:	b0 70       	andi	r27, 0x00	; 0
    452e:	cc 24       	eor	r12, r12
    4530:	d8 2e       	mov	r13, r24
    4532:	e9 2e       	mov	r14, r25
    4534:	fa 2e       	mov	r15, r26
    4536:	0e 94 b6 1b 	call	0x376c	; 0x376c <ipGetConfig>
    453a:	dc 01       	movw	r26, r24
    453c:	13 96       	adiw	r26, 0x03	; 3
    453e:	8c 91       	ld	r24, X
    4540:	90 e0       	ldi	r25, 0x00	; 0
    4542:	a0 e0       	ldi	r26, 0x00	; 0
    4544:	b0 e0       	ldi	r27, 0x00	; 0
    4546:	82 29       	or	r24, r2
    4548:	93 29       	or	r25, r3
    454a:	a4 29       	or	r26, r4
    454c:	b5 29       	or	r27, r5
    454e:	86 29       	or	r24, r6
    4550:	97 29       	or	r25, r7
    4552:	a8 29       	or	r26, r8
    4554:	b9 29       	or	r27, r9
    4556:	8c 29       	or	r24, r12
    4558:	9d 29       	or	r25, r13
    455a:	ae 29       	or	r26, r14
    455c:	bf 29       	or	r27, r15
    455e:	f8 01       	movw	r30, r16
    4560:	84 87       	std	Z+12, r24	; 0x0c
    4562:	95 87       	std	Z+13, r25	; 0x0d
    4564:	a6 87       	std	Z+14, r26	; 0x0e
    4566:	b7 87       	std	Z+15, r27	; 0x0f
	ipHeader->desIPAddr = HTONL(pSession->desIP);
    4568:	f5 01       	movw	r30, r10
    456a:	84 81       	ldd	r24, Z+4	; 0x04
    456c:	95 81       	ldd	r25, Z+5	; 0x05
    456e:	a6 81       	ldd	r26, Z+6	; 0x06
    4570:	b7 81       	ldd	r27, Z+7	; 0x07
    4572:	cb 2e       	mov	r12, r27
    4574:	dd 24       	eor	r13, r13
    4576:	ee 24       	eor	r14, r14
    4578:	ff 24       	eor	r15, r15
    457a:	58 2f       	mov	r21, r24
    457c:	44 27       	eor	r20, r20
    457e:	33 27       	eor	r19, r19
    4580:	22 27       	eor	r18, r18
    4582:	c2 2a       	or	r12, r18
    4584:	d3 2a       	or	r13, r19
    4586:	e4 2a       	or	r14, r20
    4588:	f5 2a       	or	r15, r21
    458a:	9c 01       	movw	r18, r24
    458c:	ad 01       	movw	r20, r26
    458e:	20 70       	andi	r18, 0x00	; 0
    4590:	30 70       	andi	r19, 0x00	; 0
    4592:	50 70       	andi	r21, 0x00	; 0
    4594:	23 2f       	mov	r18, r19
    4596:	34 2f       	mov	r19, r20
    4598:	45 2f       	mov	r20, r21
    459a:	55 27       	eor	r21, r21
    459c:	2c 29       	or	r18, r12
    459e:	3d 29       	or	r19, r13
    45a0:	4e 29       	or	r20, r14
    45a2:	5f 29       	or	r21, r15
    45a4:	80 70       	andi	r24, 0x00	; 0
    45a6:	a0 70       	andi	r26, 0x00	; 0
    45a8:	b0 70       	andi	r27, 0x00	; 0
    45aa:	cc 24       	eor	r12, r12
    45ac:	d8 2e       	mov	r13, r24
    45ae:	e9 2e       	mov	r14, r25
    45b0:	fa 2e       	mov	r15, r26
    45b2:	2c 29       	or	r18, r12
    45b4:	3d 29       	or	r19, r13
    45b6:	4e 29       	or	r20, r14
    45b8:	5f 29       	or	r21, r15
    45ba:	d8 01       	movw	r26, r16
    45bc:	50 96       	adiw	r26, 0x10	; 16
    45be:	2d 93       	st	X+, r18
    45c0:	3d 93       	st	X+, r19
    45c2:	4d 93       	st	X+, r20
    45c4:	5c 93       	st	X, r21
    45c6:	53 97       	sbiw	r26, 0x13	; 19
	ipHeader->Checksum = HTONS(len);
    45c8:	89 81       	ldd	r24, Y+1	; 0x01
    45ca:	9a 81       	ldd	r25, Y+2	; 0x02
    45cc:	98 27       	eor	r25, r24
    45ce:	89 27       	eor	r24, r25
    45d0:	98 27       	eor	r25, r24
    45d2:	1b 96       	adiw	r26, 0x0b	; 11
    45d4:	9c 93       	st	X, r25
    45d6:	8e 93       	st	-X, r24
    45d8:	1a 97       	sbiw	r26, 0x0a	; 10
	ipHeader->TTL = 0x00;
    45da:	18 96       	adiw	r26, 0x08	; 8
    45dc:	1c 92       	st	X, r1
    45de:	18 97       	sbiw	r26, 0x08	; 8
	ipHeader->Protocol = IP_PROTO_TCP;
    45e0:	86 e0       	ldi	r24, 0x06	; 6
    45e2:	19 96       	adiw	r26, 0x09	; 9
    45e4:	8c 93       	st	X, r24
	checksum32 = 0;
	tmp = len + 12;
    45e6:	69 81       	ldd	r22, Y+1	; 0x01
    45e8:	7a 81       	ldd	r23, Y+2	; 0x02
    45ea:	64 5f       	subi	r22, 0xF4	; 244
    45ec:	7f 4f       	sbci	r23, 0xFF	; 255
	tmp = checksum (((unsigned char *)ipHeader+8), tmp, checksum32);
    45ee:	8b 81       	ldd	r24, Y+3	; 0x03
    45f0:	9c 81       	ldd	r25, Y+4	; 0x04
    45f2:	0c 97       	sbiw	r24, 0x0c	; 12
    45f4:	20 e0       	ldi	r18, 0x00	; 0
    45f6:	30 e0       	ldi	r19, 0x00	; 0
    45f8:	a9 01       	movw	r20, r18
    45fa:	0e 94 2e 21 	call	0x425c	; 0x425c <checksum>
	tcpHeader->Checksum = HTONS(tmp);
    45fe:	98 27       	eor	r25, r24
    4600:	89 27       	eor	r24, r25
    4602:	98 27       	eor	r25, r24
    4604:	eb 81       	ldd	r30, Y+3	; 0x03
    4606:	fc 81       	ldd	r31, Y+4	; 0x04
    4608:	91 8b       	std	Z+17, r25	; 0x11
    460a:	80 8b       	std	Z+16, r24	; 0x10
	ipSend(pSession->desIP, IP_PROTO_TCP, len, (unsigned char *)tcpHeader);	
    460c:	d5 01       	movw	r26, r10
    460e:	14 96       	adiw	r26, 0x04	; 4
    4610:	6d 91       	ld	r22, X+
    4612:	7d 91       	ld	r23, X+
    4614:	8d 91       	ld	r24, X+
    4616:	9c 91       	ld	r25, X
    4618:	17 97       	sbiw	r26, 0x07	; 7
    461a:	46 e0       	ldi	r20, 0x06	; 6
    461c:	29 81       	ldd	r18, Y+1	; 0x01
    461e:	3a 81       	ldd	r19, Y+2	; 0x02
    4620:	8f 01       	movw	r16, r30
    4622:	0e 94 8c 1c 	call	0x3918	; 0x3918 <ipSend>
}
    4626:	0f 90       	pop	r0
    4628:	0f 90       	pop	r0
    462a:	0f 90       	pop	r0
    462c:	0f 90       	pop	r0
    462e:	cf 91       	pop	r28
    4630:	df 91       	pop	r29
    4632:	1f 91       	pop	r17
    4634:	0f 91       	pop	r16
    4636:	ff 90       	pop	r15
    4638:	ef 90       	pop	r14
    463a:	df 90       	pop	r13
    463c:	cf 90       	pop	r12
    463e:	bf 90       	pop	r11
    4640:	af 90       	pop	r10
    4642:	9f 90       	pop	r9
    4644:	8f 90       	pop	r8
    4646:	7f 90       	pop	r7
    4648:	6f 90       	pop	r6
    464a:	5f 90       	pop	r5
    464c:	4f 90       	pop	r4
    464e:	3f 90       	pop	r3
    4650:	2f 90       	pop	r2
    4652:	08 95       	ret

00004654 <TCPProcess>:
void TCPProcess(unsigned char *buffer, unsigned int len)
//Ham xu ly cho giao thuc TCP
// Duoc thuc thi khi nhan duoc mot goi TCP (goi boi netstackIPProcess)
// buffer: co tro den dau goi IP (bat dau IP Header)
// len   : chieu dai buffer
{
    4654:	2f 92       	push	r2
    4656:	3f 92       	push	r3
    4658:	4f 92       	push	r4
    465a:	5f 92       	push	r5
    465c:	6f 92       	push	r6
    465e:	7f 92       	push	r7
    4660:	8f 92       	push	r8
    4662:	9f 92       	push	r9
    4664:	af 92       	push	r10
    4666:	bf 92       	push	r11
    4668:	cf 92       	push	r12
    466a:	df 92       	push	r13
    466c:	ef 92       	push	r14
    466e:	ff 92       	push	r15
    4670:	0f 93       	push	r16
    4672:	1f 93       	push	r17
    4674:	cf 93       	push	r28
    4676:	df 93       	push	r29
    4678:	7c 01       	movw	r14, r24
	unsigned long tmp;
	struct ntIPHeader* ipHeader;
	struct ntTCPHeader* tcpHeader;
	unsigned char *tcpData;
	//Khoi tao cac co tro den Header IP va TCP
	ipHeader = (struct ntIPHeader*)(buffer);
    467a:	6c 01       	movw	r12, r24
	ipHeaderLen = ((ipHeader->verHdrLen) & 0x0F) << 2;
    467c:	dc 01       	movw	r26, r24
    467e:	0c 91       	ld	r16, X
    4680:	0f 70       	andi	r16, 0x0F	; 15
    4682:	00 0f       	add	r16, r16
    4684:	00 0f       	add	r16, r16
	//
	tcpHeader = (struct ntTCPHeader*)(buffer+ipHeaderLen);
    4686:	a0 2e       	mov	r10, r16
    4688:	bb 24       	eor	r11, r11
    468a:	ec 01       	movw	r28, r24
    468c:	ca 0d       	add	r28, r10
    468e:	db 1d       	adc	r29, r11
	tcpHeaderLen = ((tcpHeader->Offset) & 0xF0) >> 2;
    4690:	5c 84       	ldd	r5, Y+12	; 0x0c
	//
	tcpData = (buffer+ipHeaderLen+tcpHeaderLen);
	dataLen = HTONS(ipHeader->Len) - (ipHeaderLen + tcpHeaderLen);
    4692:	fc 01       	movw	r30, r24
    4694:	22 80       	ldd	r2, Z+2	; 0x02
    4696:	33 80       	ldd	r3, Z+3	; 0x03
    4698:	eb ee       	ldi	r30, 0xEB	; 235
    469a:	f5 e0       	ldi	r31, 0x05	; 5
	//Tim kiem mot phien TCP co san cho goi nay
	for(i = 0; i < TCP_MAX_SESSION; i++){	//Check session table
    469c:	10 e0       	ldi	r17, 0x00	; 0
		if(tcpSessionTable[i].sesState != TCP_STATE_CLOSED){		//If not closed session
    469e:	80 89       	ldd	r24, Z+16	; 0x10
    46a0:	88 23       	and	r24, r24
    46a2:	09 f4       	brne	.+2      	; 0x46a6 <TCPProcess+0x52>
    46a4:	4b c0       	rjmp	.+150    	; 0x473c <TCPProcess+0xe8>
			if(tcpSessionTable[i].srcPort == HTONS((tcpHeader->desPort))){	//If matched local port
    46a6:	8a 81       	ldd	r24, Y+2	; 0x02
    46a8:	9b 81       	ldd	r25, Y+3	; 0x03
    46aa:	98 27       	eor	r25, r24
    46ac:	89 27       	eor	r24, r25
    46ae:	98 27       	eor	r25, r24
    46b0:	42 81       	ldd	r20, Z+2	; 0x02
    46b2:	53 81       	ldd	r21, Z+3	; 0x03
    46b4:	48 17       	cp	r20, r24
    46b6:	59 07       	cpc	r21, r25
    46b8:	09 f0       	breq	.+2      	; 0x46bc <TCPProcess+0x68>
    46ba:	40 c0       	rjmp	.+128    	; 0x473c <TCPProcess+0xe8>
				if(tcpSessionTable[i].desPort == HTONS((tcpHeader->srcPort))&&(tcpSessionTable[i].desIP == HTONL((ipHeader->srcIPAddr)))){
    46bc:	88 81       	ld	r24, Y
    46be:	99 81       	ldd	r25, Y+1	; 0x01
    46c0:	98 27       	eor	r25, r24
    46c2:	89 27       	eor	r24, r25
    46c4:	98 27       	eor	r25, r24
    46c6:	40 81       	ld	r20, Z
    46c8:	51 81       	ldd	r21, Z+1	; 0x01
    46ca:	48 17       	cp	r20, r24
    46cc:	59 07       	cpc	r21, r25
    46ce:	b1 f5       	brne	.+108    	; 0x473c <TCPProcess+0xe8>
    46d0:	d6 01       	movw	r26, r12
    46d2:	1c 96       	adiw	r26, 0x0c	; 12
    46d4:	4d 91       	ld	r20, X+
    46d6:	5d 91       	ld	r21, X+
    46d8:	6d 91       	ld	r22, X+
    46da:	7c 91       	ld	r23, X
    46dc:	1f 97       	sbiw	r26, 0x0f	; 15
    46de:	67 2e       	mov	r6, r23
    46e0:	77 24       	eor	r7, r7
    46e2:	88 24       	eor	r8, r8
    46e4:	99 24       	eor	r9, r9
    46e6:	b4 2f       	mov	r27, r20
    46e8:	aa 27       	eor	r26, r26
    46ea:	99 27       	eor	r25, r25
    46ec:	88 27       	eor	r24, r24
    46ee:	68 2a       	or	r6, r24
    46f0:	79 2a       	or	r7, r25
    46f2:	8a 2a       	or	r8, r26
    46f4:	9b 2a       	or	r9, r27
    46f6:	db 01       	movw	r26, r22
    46f8:	ca 01       	movw	r24, r20
    46fa:	80 70       	andi	r24, 0x00	; 0
    46fc:	90 70       	andi	r25, 0x00	; 0
    46fe:	b0 70       	andi	r27, 0x00	; 0
    4700:	89 2f       	mov	r24, r25
    4702:	9a 2f       	mov	r25, r26
    4704:	ab 2f       	mov	r26, r27
    4706:	bb 27       	eor	r27, r27
    4708:	68 2a       	or	r6, r24
    470a:	79 2a       	or	r7, r25
    470c:	8a 2a       	or	r8, r26
    470e:	9b 2a       	or	r9, r27
    4710:	40 70       	andi	r20, 0x00	; 0
    4712:	60 70       	andi	r22, 0x00	; 0
    4714:	70 70       	andi	r23, 0x00	; 0
    4716:	b6 2f       	mov	r27, r22
    4718:	a5 2f       	mov	r26, r21
    471a:	94 2f       	mov	r25, r20
    471c:	88 27       	eor	r24, r24
    471e:	b4 01       	movw	r22, r8
    4720:	a3 01       	movw	r20, r6
    4722:	48 2b       	or	r20, r24
    4724:	59 2b       	or	r21, r25
    4726:	6a 2b       	or	r22, r26
    4728:	7b 2b       	or	r23, r27
    472a:	64 80       	ldd	r6, Z+4	; 0x04
    472c:	75 80       	ldd	r7, Z+5	; 0x05
    472e:	86 80       	ldd	r8, Z+6	; 0x06
    4730:	97 80       	ldd	r9, Z+7	; 0x07
    4732:	64 16       	cp	r6, r20
    4734:	75 06       	cpc	r7, r21
    4736:	86 06       	cpc	r8, r22
    4738:	97 06       	cpc	r9, r23
    473a:	31 f0       	breq	.+12     	; 0x4748 <TCPProcess+0xf4>
	tcpHeaderLen = ((tcpHeader->Offset) & 0xF0) >> 2;
	//
	tcpData = (buffer+ipHeaderLen+tcpHeaderLen);
	dataLen = HTONS(ipHeader->Len) - (ipHeaderLen + tcpHeaderLen);
	//Tim kiem mot phien TCP co san cho goi nay
	for(i = 0; i < TCP_MAX_SESSION; i++){	//Check session table
    473c:	1f 5f       	subi	r17, 0xFF	; 255
    473e:	7f 96       	adiw	r30, 0x1f	; 31
    4740:	18 30       	cpi	r17, 0x08	; 8
    4742:	09 f0       	breq	.+2      	; 0x4746 <TCPProcess+0xf2>
    4744:	ac cf       	rjmp	.-168    	; 0x469e <TCPProcess+0x4a>
    4746:	03 c0       	rjmp	.+6      	; 0x474e <TCPProcess+0xfa>
					break;	//Thoat khoi vong lap for, luc nay gia tri cua i chinh la chi so cua phien TCP tuong ung
				}
			}
		}
	}
	if(i == TCP_MAX_SESSION){	//Neu khong co 1 phien TCP dang ton tai cho goi nay
    4748:	18 30       	cpi	r17, 0x08	; 8
    474a:	09 f0       	breq	.+2      	; 0x474e <TCPProcess+0xfa>
    474c:	69 c0       	rjmp	.+210    	; 0x4820 <TCPProcess+0x1cc>
    474e:	ed ee       	ldi	r30, 0xED	; 237
    4750:	f5 e0       	ldi	r31, 0x05	; 5
	tcpHeaderLen = ((tcpHeader->Offset) & 0xF0) >> 2;
	//
	tcpData = (buffer+ipHeaderLen+tcpHeaderLen);
	dataLen = HTONS(ipHeader->Len) - (ipHeaderLen + tcpHeaderLen);
	//Tim kiem mot phien TCP co san cho goi nay
	for(i = 0; i < TCP_MAX_SESSION; i++){	//Check session table
    4752:	80 e0       	ldi	r24, 0x00	; 0
    4754:	90 e0       	ldi	r25, 0x00	; 0
					break;	//Thoat khoi vong lap for, luc nay gia tri cua i chinh la chi so cua phien TCP tuong ung
				}
			}
		}
	}
	if(i == TCP_MAX_SESSION){	//Neu khong co 1 phien TCP dang ton tai cho goi nay
    4756:	18 2f       	mov	r17, r24
    4758:	9c 01       	movw	r18, r24
		//Tim 1 phien dang o trang thai LISTEN (doi ket noi) cho local port nay
		for(i=0; i < TCP_MAX_SESSION; i++){
			if(tcpSessionTable[i].sesState == TCP_STATE_LISTEN){
    475a:	46 85       	ldd	r20, Z+14	; 0x0e
    475c:	42 30       	cpi	r20, 0x02	; 2
    475e:	09 f0       	breq	.+2      	; 0x4762 <TCPProcess+0x10e>
    4760:	55 c0       	rjmp	.+170    	; 0x480c <TCPProcess+0x1b8>
				if(tcpSessionTable[i].srcPort == HTONS((tcpHeader->desPort))){	//If matched local port
    4762:	4a 81       	ldd	r20, Y+2	; 0x02
    4764:	5b 81       	ldd	r21, Y+3	; 0x03
    4766:	74 2f       	mov	r23, r20
    4768:	65 2f       	mov	r22, r21
    476a:	40 81       	ld	r20, Z
    476c:	51 81       	ldd	r21, Z+1	; 0x01
    476e:	46 17       	cp	r20, r22
    4770:	57 07       	cpc	r21, r23
    4772:	09 f0       	breq	.+2      	; 0x4776 <TCPProcess+0x122>
    4774:	4b c0       	rjmp	.+150    	; 0x480c <TCPProcess+0x1b8>
					//Cap nhat remote port va remote IP
					tcpSessionTable[i].desPort = HTONS((tcpHeader->srcPort));
    4776:	4f e1       	ldi	r20, 0x1F	; 31
    4778:	50 e0       	ldi	r21, 0x00	; 0
    477a:	24 9f       	mul	r18, r20
    477c:	c0 01       	movw	r24, r0
    477e:	25 9f       	mul	r18, r21
    4780:	90 0d       	add	r25, r0
    4782:	34 9f       	mul	r19, r20
    4784:	90 0d       	add	r25, r0
    4786:	11 24       	eor	r1, r1
    4788:	fc 01       	movw	r30, r24
    478a:	e5 51       	subi	r30, 0x15	; 21
    478c:	fa 4f       	sbci	r31, 0xFA	; 250
    478e:	88 81       	ld	r24, Y
    4790:	99 81       	ldd	r25, Y+1	; 0x01
    4792:	98 27       	eor	r25, r24
    4794:	89 27       	eor	r24, r25
    4796:	98 27       	eor	r25, r24
    4798:	91 83       	std	Z+1, r25	; 0x01
    479a:	80 83       	st	Z, r24
					tcpSessionTable[i].desIP = HTONL((ipHeader->srcIPAddr));
    479c:	d7 01       	movw	r26, r14
    479e:	1c 96       	adiw	r26, 0x0c	; 12
    47a0:	2d 91       	ld	r18, X+
    47a2:	3d 91       	ld	r19, X+
    47a4:	4d 91       	ld	r20, X+
    47a6:	5c 91       	ld	r21, X
    47a8:	1f 97       	sbiw	r26, 0x0f	; 15
    47aa:	65 2e       	mov	r6, r21
    47ac:	77 24       	eor	r7, r7
    47ae:	88 24       	eor	r8, r8
    47b0:	99 24       	eor	r9, r9
    47b2:	b2 2f       	mov	r27, r18
    47b4:	aa 27       	eor	r26, r26
    47b6:	99 27       	eor	r25, r25
    47b8:	88 27       	eor	r24, r24
    47ba:	68 2a       	or	r6, r24
    47bc:	79 2a       	or	r7, r25
    47be:	8a 2a       	or	r8, r26
    47c0:	9b 2a       	or	r9, r27
    47c2:	da 01       	movw	r26, r20
    47c4:	c9 01       	movw	r24, r18
    47c6:	80 70       	andi	r24, 0x00	; 0
    47c8:	90 70       	andi	r25, 0x00	; 0
    47ca:	b0 70       	andi	r27, 0x00	; 0
    47cc:	89 2f       	mov	r24, r25
    47ce:	9a 2f       	mov	r25, r26
    47d0:	ab 2f       	mov	r26, r27
    47d2:	bb 27       	eor	r27, r27
    47d4:	68 2a       	or	r6, r24
    47d6:	79 2a       	or	r7, r25
    47d8:	8a 2a       	or	r8, r26
    47da:	9b 2a       	or	r9, r27
    47dc:	da 01       	movw	r26, r20
    47de:	c9 01       	movw	r24, r18
    47e0:	80 70       	andi	r24, 0x00	; 0
    47e2:	a0 70       	andi	r26, 0x00	; 0
    47e4:	b0 70       	andi	r27, 0x00	; 0
    47e6:	ba 2f       	mov	r27, r26
    47e8:	a9 2f       	mov	r26, r25
    47ea:	98 2f       	mov	r25, r24
    47ec:	88 27       	eor	r24, r24
    47ee:	86 29       	or	r24, r6
    47f0:	97 29       	or	r25, r7
    47f2:	a8 29       	or	r26, r8
    47f4:	b9 29       	or	r27, r9
    47f6:	84 83       	std	Z+4, r24	; 0x04
    47f8:	95 83       	std	Z+5, r25	; 0x05
    47fa:	a6 83       	std	Z+6, r26	; 0x06
    47fc:	b7 83       	std	Z+7, r27	; 0x07
					//Dong thoi tao ra 1 session moi de cho ket noi khac den local port nay
					TCPCreateSession(tcpSessionTable[i].srcPort,tcpSessionTable[i].appDataIn);
    47fe:	63 8d       	ldd	r22, Z+27	; 0x1b
    4800:	74 8d       	ldd	r23, Z+28	; 0x1c
    4802:	82 81       	ldd	r24, Z+2	; 0x02
    4804:	93 81       	ldd	r25, Z+3	; 0x03
    4806:	0e 94 e7 20 	call	0x41ce	; 0x41ce <TCPCreateSession>
					break;
    480a:	07 c0       	rjmp	.+14     	; 0x481a <TCPProcess+0x1c6>
    480c:	1f 5f       	subi	r17, 0xFF	; 255
    480e:	01 96       	adiw	r24, 0x01	; 1
    4810:	7f 96       	adiw	r30, 0x1f	; 31
			}
		}
	}
	if(i == TCP_MAX_SESSION){	//Neu khong co 1 phien TCP dang ton tai cho goi nay
		//Tim 1 phien dang o trang thai LISTEN (doi ket noi) cho local port nay
		for(i=0; i < TCP_MAX_SESSION; i++){
    4812:	88 30       	cpi	r24, 0x08	; 8
    4814:	91 05       	cpc	r25, r1
    4816:	09 f0       	breq	.+2      	; 0x481a <TCPProcess+0x1c6>
    4818:	9e cf       	rjmp	.-196    	; 0x4756 <TCPProcess+0x102>
					break;
				}
			}
		}
	}
	if(i == TCP_MAX_SESSION){
    481a:	18 30       	cpi	r17, 0x08	; 8
    481c:	09 f4       	brne	.+2      	; 0x4820 <TCPProcess+0x1cc>
    481e:	8a c5       	rjmp	.+2836   	; 0x5334 <TCPProcess+0xce0>
	}
	#ifdef TCP_DEBUG
	printf("TCP session found: %d\r\n",i);
	#endif
	//Bat dau xu ly giao thuc
	tcpSessionTable[i].timeOut = TCP_TIMEOUT;	//Reset lai gia tri Time out
    4820:	c1 2e       	mov	r12, r17
    4822:	dd 24       	eor	r13, r13
    4824:	2f e1       	ldi	r18, 0x1F	; 31
    4826:	30 e0       	ldi	r19, 0x00	; 0
    4828:	c2 9e       	mul	r12, r18
    482a:	c0 01       	movw	r24, r0
    482c:	c3 9e       	mul	r12, r19
    482e:	90 0d       	add	r25, r0
    4830:	d2 9e       	mul	r13, r18
    4832:	90 0d       	add	r25, r0
    4834:	11 24       	eor	r1, r1
    4836:	85 51       	subi	r24, 0x15	; 21
    4838:	9a 4f       	sbci	r25, 0xFA	; 250
    483a:	2c e3       	ldi	r18, 0x3C	; 60
    483c:	fc 01       	movw	r30, r24
    483e:	22 8f       	std	Z+26, r18	; 0x1a
	//Truong hop nhan duoc yeu cau reset lai ket noi
	if ((tcpHeader->Flags) & TCP_RST_FLAG){
    4840:	5d 85       	ldd	r21, Y+13	; 0x0d
    4842:	52 ff       	sbrs	r21, 2
    4844:	04 c0       	rjmp	.+8      	; 0x484e <TCPProcess+0x1fa>
		//Chap nhan dong ket noi
		TCPCloseSession(i);
    4846:	81 2f       	mov	r24, r17
    4848:	0e 94 aa 20 	call	0x4154	; 0x4154 <TCPCloseSession>
		return;
    484c:	73 c5       	rjmp	.+2790   	; 0x5334 <TCPProcess+0xce0>
	//Khoi tao cac co tro den Header IP va TCP
	ipHeader = (struct ntIPHeader*)(buffer);
	ipHeaderLen = ((ipHeader->verHdrLen) & 0x0F) << 2;
	//
	tcpHeader = (struct ntTCPHeader*)(buffer+ipHeaderLen);
	tcpHeaderLen = ((tcpHeader->Offset) & 0xF0) >> 2;
    484e:	85 2d       	mov	r24, r5
    4850:	86 95       	lsr	r24
    4852:	86 95       	lsr	r24
    4854:	8c 73       	andi	r24, 0x3C	; 60
	//
	tcpData = (buffer+ipHeaderLen+tcpHeaderLen);
    4856:	90 e0       	ldi	r25, 0x00	; 0
    4858:	a8 0e       	add	r10, r24
    485a:	b9 1e       	adc	r11, r25
    485c:	ae 0c       	add	r10, r14
    485e:	bf 1c       	adc	r11, r15
	dataLen = HTONS(ipHeader->Len) - (ipHeaderLen + tcpHeaderLen);
    4860:	72 2d       	mov	r23, r2
    4862:	63 2d       	mov	r22, r3
    4864:	80 0f       	add	r24, r16
    4866:	91 1d       	adc	r25, r1
    4868:	68 1b       	sub	r22, r24
    486a:	79 0b       	sbc	r23, r25
		//Chap nhan dong ket noi
		TCPCloseSession(i);
		return;
	}
	//Kiem tra trang thai hien tai cua phien TCP
	switch (tcpSessionTable[i].sesState){
    486c:	2f e1       	ldi	r18, 0x1F	; 31
    486e:	30 e0       	ldi	r19, 0x00	; 0
    4870:	c2 9e       	mul	r12, r18
    4872:	c0 01       	movw	r24, r0
    4874:	c3 9e       	mul	r12, r19
    4876:	90 0d       	add	r25, r0
    4878:	d2 9e       	mul	r13, r18
    487a:	90 0d       	add	r25, r0
    487c:	11 24       	eor	r1, r1
    487e:	85 51       	subi	r24, 0x15	; 21
    4880:	9a 4f       	sbci	r25, 0xFA	; 250
    4882:	dc 01       	movw	r26, r24
    4884:	50 96       	adiw	r26, 0x10	; 16
    4886:	8c 91       	ld	r24, X
    4888:	50 97       	sbiw	r26, 0x10	; 16
    488a:	86 30       	cpi	r24, 0x06	; 6
    488c:	09 f4       	brne	.+2      	; 0x4890 <TCPProcess+0x23c>
    488e:	85 c4       	rjmp	.+2314   	; 0x519a <TCPProcess+0xb46>
    4890:	87 30       	cpi	r24, 0x07	; 7
    4892:	80 f4       	brcc	.+32     	; 0x48b4 <TCPProcess+0x260>
    4894:	83 30       	cpi	r24, 0x03	; 3
    4896:	09 f4       	brne	.+2      	; 0x489a <TCPProcess+0x246>
    4898:	ad c0       	rjmp	.+346    	; 0x49f4 <TCPProcess+0x3a0>
    489a:	84 30       	cpi	r24, 0x04	; 4
    489c:	20 f4       	brcc	.+8      	; 0x48a6 <TCPProcess+0x252>
    489e:	82 30       	cpi	r24, 0x02	; 2
    48a0:	09 f0       	breq	.+2      	; 0x48a4 <TCPProcess+0x250>
    48a2:	2a c5       	rjmp	.+2644   	; 0x52f8 <TCPProcess+0xca4>
    48a4:	14 c0       	rjmp	.+40     	; 0x48ce <TCPProcess+0x27a>
    48a6:	84 30       	cpi	r24, 0x04	; 4
    48a8:	09 f4       	brne	.+2      	; 0x48ac <TCPProcess+0x258>
    48aa:	f6 c0       	rjmp	.+492    	; 0x4a98 <TCPProcess+0x444>
    48ac:	85 30       	cpi	r24, 0x05	; 5
    48ae:	09 f0       	breq	.+2      	; 0x48b2 <TCPProcess+0x25e>
    48b0:	23 c5       	rjmp	.+2630   	; 0x52f8 <TCPProcess+0xca4>
    48b2:	a1 c3       	rjmp	.+1858   	; 0x4ff6 <TCPProcess+0x9a2>
    48b4:	88 30       	cpi	r24, 0x08	; 8
    48b6:	09 f4       	brne	.+2      	; 0x48ba <TCPProcess+0x266>
    48b8:	22 c5       	rjmp	.+2628   	; 0x52fe <TCPProcess+0xcaa>
    48ba:	88 30       	cpi	r24, 0x08	; 8
    48bc:	08 f4       	brcc	.+2      	; 0x48c0 <TCPProcess+0x26c>
    48be:	0e c5       	rjmp	.+2588   	; 0x52dc <TCPProcess+0xc88>
    48c0:	89 30       	cpi	r24, 0x09	; 9
    48c2:	09 f4       	brne	.+2      	; 0x48c6 <TCPProcess+0x272>
    48c4:	fa c2       	rjmp	.+1524   	; 0x4eba <TCPProcess+0x866>
    48c6:	8a 30       	cpi	r24, 0x0A	; 10
    48c8:	09 f0       	breq	.+2      	; 0x48cc <TCPProcess+0x278>
    48ca:	16 c5       	rjmp	.+2604   	; 0x52f8 <TCPProcess+0xca4>
    48cc:	9d c2       	rjmp	.+1338   	; 0x4e08 <TCPProcess+0x7b4>
		//Neu la trang thai doi ket noi: TCP_STATE_LISTEN
		case(TCP_STATE_LISTEN):
			//Chi xu ly neu co SYN duoc set (yeu cau thiet lap ket noi)
			if ((tcpHeader->Flags) == TCP_SYN_FLAG){
    48ce:	52 30       	cpi	r21, 0x02	; 2
    48d0:	09 f0       	breq	.+2      	; 0x48d4 <TCPProcess+0x280>
    48d2:	15 c5       	rjmp	.+2602   	; 0x52fe <TCPProcess+0xcaa>
				//Chuyen sang trang thai ke tiep la TCP_STATE_SYN_RECEIVED
				tcpSessionTable[i].sesState = TCP_STATE_SYN_RECEIVED;
    48d4:	0f 2e       	mov	r0, r31
    48d6:	ff e1       	ldi	r31, 0x1F	; 31
    48d8:	2f 2e       	mov	r2, r31
    48da:	33 24       	eor	r3, r3
    48dc:	f0 2d       	mov	r31, r0
    48de:	c2 9c       	mul	r12, r2
    48e0:	c0 01       	movw	r24, r0
    48e2:	c3 9c       	mul	r12, r3
    48e4:	90 0d       	add	r25, r0
    48e6:	d2 9c       	mul	r13, r2
    48e8:	90 0d       	add	r25, r0
    48ea:	11 24       	eor	r1, r1
    48ec:	0f 2e       	mov	r0, r31
    48ee:	fb ee       	ldi	r31, 0xEB	; 235
    48f0:	ef 2e       	mov	r14, r31
    48f2:	f5 e0       	ldi	r31, 0x05	; 5
    48f4:	ff 2e       	mov	r15, r31
    48f6:	f0 2d       	mov	r31, r0
    48f8:	e8 0e       	add	r14, r24
    48fa:	f9 1e       	adc	r15, r25
    48fc:	83 e0       	ldi	r24, 0x03	; 3
    48fe:	f7 01       	movw	r30, r14
    4900:	80 8b       	std	Z+16, r24	; 0x10
				//Khoi tao gia tri sequence
				tcpSessionTable[i].seqNumber = HTONL(TCPInitSequenceNumber());
    4902:	0e 94 a5 20 	call	0x414a	; 0x414a <TCPInitSequenceNumber>
    4906:	9b 01       	movw	r18, r22
    4908:	ac 01       	movw	r20, r24
    490a:	69 2e       	mov	r6, r25
    490c:	77 24       	eor	r7, r7
    490e:	88 24       	eor	r8, r8
    4910:	99 24       	eor	r9, r9
    4912:	b6 2f       	mov	r27, r22
    4914:	aa 27       	eor	r26, r26
    4916:	99 27       	eor	r25, r25
    4918:	88 27       	eor	r24, r24
    491a:	68 2a       	or	r6, r24
    491c:	79 2a       	or	r7, r25
    491e:	8a 2a       	or	r8, r26
    4920:	9b 2a       	or	r9, r27
    4922:	da 01       	movw	r26, r20
    4924:	c9 01       	movw	r24, r18
    4926:	80 70       	andi	r24, 0x00	; 0
    4928:	90 70       	andi	r25, 0x00	; 0
    492a:	b0 70       	andi	r27, 0x00	; 0
    492c:	89 2f       	mov	r24, r25
    492e:	9a 2f       	mov	r25, r26
    4930:	ab 2f       	mov	r26, r27
    4932:	bb 27       	eor	r27, r27
    4934:	68 2a       	or	r6, r24
    4936:	79 2a       	or	r7, r25
    4938:	8a 2a       	or	r8, r26
    493a:	9b 2a       	or	r9, r27
    493c:	da 01       	movw	r26, r20
    493e:	c9 01       	movw	r24, r18
    4940:	80 70       	andi	r24, 0x00	; 0
    4942:	a0 70       	andi	r26, 0x00	; 0
    4944:	b0 70       	andi	r27, 0x00	; 0
    4946:	ba 2f       	mov	r27, r26
    4948:	a9 2f       	mov	r26, r25
    494a:	98 2f       	mov	r25, r24
    494c:	88 27       	eor	r24, r24
    494e:	86 29       	or	r24, r6
    4950:	97 29       	or	r25, r7
    4952:	a8 29       	or	r26, r8
    4954:	b9 29       	or	r27, r9
    4956:	f7 01       	movw	r30, r14
    4958:	80 87       	std	Z+8, r24	; 0x08
    495a:	91 87       	std	Z+9, r25	; 0x09
    495c:	a2 87       	std	Z+10, r26	; 0x0a
    495e:	b3 87       	std	Z+11, r27	; 0x0b
				//Ack chinh la so tuan tu nhan duoc cong 1
				tcpSessionTable[i].ackNumber = HTONL((tcpHeader->seqNumber))+1;
    4960:	2c 81       	ldd	r18, Y+4	; 0x04
    4962:	3d 81       	ldd	r19, Y+5	; 0x05
    4964:	4e 81       	ldd	r20, Y+6	; 0x06
    4966:	5f 81       	ldd	r21, Y+7	; 0x07
    4968:	65 2e       	mov	r6, r21
    496a:	77 24       	eor	r7, r7
    496c:	88 24       	eor	r8, r8
    496e:	99 24       	eor	r9, r9
    4970:	b2 2f       	mov	r27, r18
    4972:	aa 27       	eor	r26, r26
    4974:	99 27       	eor	r25, r25
    4976:	88 27       	eor	r24, r24
    4978:	68 2a       	or	r6, r24
    497a:	79 2a       	or	r7, r25
    497c:	8a 2a       	or	r8, r26
    497e:	9b 2a       	or	r9, r27
    4980:	da 01       	movw	r26, r20
    4982:	c9 01       	movw	r24, r18
    4984:	80 70       	andi	r24, 0x00	; 0
    4986:	90 70       	andi	r25, 0x00	; 0
    4988:	b0 70       	andi	r27, 0x00	; 0
    498a:	89 2f       	mov	r24, r25
    498c:	9a 2f       	mov	r25, r26
    498e:	ab 2f       	mov	r26, r27
    4990:	bb 27       	eor	r27, r27
    4992:	68 2a       	or	r6, r24
    4994:	79 2a       	or	r7, r25
    4996:	8a 2a       	or	r8, r26
    4998:	9b 2a       	or	r9, r27
    499a:	da 01       	movw	r26, r20
    499c:	c9 01       	movw	r24, r18
    499e:	80 70       	andi	r24, 0x00	; 0
    49a0:	a0 70       	andi	r26, 0x00	; 0
    49a2:	b0 70       	andi	r27, 0x00	; 0
    49a4:	ba 2f       	mov	r27, r26
    49a6:	a9 2f       	mov	r26, r25
    49a8:	98 2f       	mov	r25, r24
    49aa:	88 27       	eor	r24, r24
    49ac:	86 29       	or	r24, r6
    49ae:	97 29       	or	r25, r7
    49b0:	a8 29       	or	r26, r8
    49b2:	b9 29       	or	r27, r9
    49b4:	01 96       	adiw	r24, 0x01	; 1
    49b6:	a1 1d       	adc	r26, r1
    49b8:	b1 1d       	adc	r27, r1
    49ba:	84 87       	std	Z+12, r24	; 0x0c
    49bc:	95 87       	std	Z+13, r25	; 0x0d
    49be:	a6 87       	std	Z+14, r26	; 0x0e
    49c0:	b7 87       	std	Z+15, r27	; 0x0f
				tcpSessionTable[i].desWin = HTONS((tcpHeader->Window));
    49c2:	8e 85       	ldd	r24, Y+14	; 0x0e
    49c4:	9f 85       	ldd	r25, Y+15	; 0x0f
    49c6:	98 27       	eor	r25, r24
    49c8:	89 27       	eor	r24, r25
    49ca:	98 27       	eor	r25, r24
    49cc:	94 8b       	std	Z+20, r25	; 0x14
    49ce:	83 8b       	std	Z+19, r24	; 0x13
				//Goi tra xac nhan va co SYN (SYN & ACK)
				TCPPackedSend(&tcpSessionTable[i],(TCP_SYN_FLAG|TCP_ACK_FLAG),0,tcpData);
    49d0:	21 2f       	mov	r18, r17
    49d2:	30 e0       	ldi	r19, 0x00	; 0
    49d4:	22 9d       	mul	r18, r2
    49d6:	c0 01       	movw	r24, r0
    49d8:	23 9d       	mul	r18, r3
    49da:	90 0d       	add	r25, r0
    49dc:	32 9d       	mul	r19, r2
    49de:	90 0d       	add	r25, r0
    49e0:	11 24       	eor	r1, r1
    49e2:	85 51       	subi	r24, 0x15	; 21
    49e4:	9a 4f       	sbci	r25, 0xFA	; 250
    49e6:	62 e1       	ldi	r22, 0x12	; 18
    49e8:	40 e0       	ldi	r20, 0x00	; 0
    49ea:	50 e0       	ldi	r21, 0x00	; 0
    49ec:	95 01       	movw	r18, r10
    49ee:	0e 94 82 21 	call	0x4304	; 0x4304 <TCPPackedSend>
    49f2:	85 c4       	rjmp	.+2314   	; 0x52fe <TCPProcess+0xcaa>
			}
			break;
		//Neu la trang thai TCP_STATE_SYN_RECEIVED
		case(TCP_STATE_SYN_RECEIVED):
			//Neu co co ACK (cho ban tin SYN & ACK truoc do)
			if ((tcpHeader->Flags) == TCP_ACK_FLAG){
    49f4:	50 31       	cpi	r21, 0x10	; 16
    49f6:	09 f0       	breq	.+2      	; 0x49fa <TCPProcess+0x3a6>
    49f8:	82 c4       	rjmp	.+2308   	; 0x52fe <TCPProcess+0xcaa>
				//Kiem tra ack trong goi tin den, neu dung thi thiet lap ket noi hoan tat
				if((tcpSessionTable[i].seqNumber) == HTONL((tcpHeader->ackNumber))){
    49fa:	88 85       	ldd	r24, Y+8	; 0x08
    49fc:	99 85       	ldd	r25, Y+9	; 0x09
    49fe:	aa 85       	ldd	r26, Y+10	; 0x0a
    4a00:	bb 85       	ldd	r27, Y+11	; 0x0b
    4a02:	2f e1       	ldi	r18, 0x1F	; 31
    4a04:	30 e0       	ldi	r19, 0x00	; 0
    4a06:	c2 9e       	mul	r12, r18
    4a08:	f0 01       	movw	r30, r0
    4a0a:	c3 9e       	mul	r12, r19
    4a0c:	f0 0d       	add	r31, r0
    4a0e:	d2 9e       	mul	r13, r18
    4a10:	f0 0d       	add	r31, r0
    4a12:	11 24       	eor	r1, r1
    4a14:	e5 51       	subi	r30, 0x15	; 21
    4a16:	fa 4f       	sbci	r31, 0xFA	; 250
    4a18:	eb 2e       	mov	r14, r27
    4a1a:	ff 24       	eor	r15, r15
    4a1c:	00 27       	eor	r16, r16
    4a1e:	11 27       	eor	r17, r17
    4a20:	58 2f       	mov	r21, r24
    4a22:	44 27       	eor	r20, r20
    4a24:	33 27       	eor	r19, r19
    4a26:	22 27       	eor	r18, r18
    4a28:	e2 2a       	or	r14, r18
    4a2a:	f3 2a       	or	r15, r19
    4a2c:	04 2b       	or	r16, r20
    4a2e:	15 2b       	or	r17, r21
    4a30:	9c 01       	movw	r18, r24
    4a32:	ad 01       	movw	r20, r26
    4a34:	20 70       	andi	r18, 0x00	; 0
    4a36:	30 70       	andi	r19, 0x00	; 0
    4a38:	50 70       	andi	r21, 0x00	; 0
    4a3a:	23 2f       	mov	r18, r19
    4a3c:	34 2f       	mov	r19, r20
    4a3e:	45 2f       	mov	r20, r21
    4a40:	55 27       	eor	r21, r21
    4a42:	2e 29       	or	r18, r14
    4a44:	3f 29       	or	r19, r15
    4a46:	40 2b       	or	r20, r16
    4a48:	51 2b       	or	r21, r17
    4a4a:	80 70       	andi	r24, 0x00	; 0
    4a4c:	a0 70       	andi	r26, 0x00	; 0
    4a4e:	b0 70       	andi	r27, 0x00	; 0
    4a50:	ba 2f       	mov	r27, r26
    4a52:	a9 2f       	mov	r26, r25
    4a54:	98 2f       	mov	r25, r24
    4a56:	88 27       	eor	r24, r24
    4a58:	28 2b       	or	r18, r24
    4a5a:	39 2b       	or	r19, r25
    4a5c:	4a 2b       	or	r20, r26
    4a5e:	5b 2b       	or	r21, r27
    4a60:	80 85       	ldd	r24, Z+8	; 0x08
    4a62:	91 85       	ldd	r25, Z+9	; 0x09
    4a64:	a2 85       	ldd	r26, Z+10	; 0x0a
    4a66:	b3 85       	ldd	r27, Z+11	; 0x0b
    4a68:	82 17       	cp	r24, r18
    4a6a:	93 07       	cpc	r25, r19
    4a6c:	a4 07       	cpc	r26, r20
    4a6e:	b5 07       	cpc	r27, r21
    4a70:	09 f0       	breq	.+2      	; 0x4a74 <TCPProcess+0x420>
    4a72:	60 c4       	rjmp	.+2240   	; 0x5334 <TCPProcess+0xce0>
					tcpSessionTable[i].sesState = TCP_STATE_ESTABLISHED;
    4a74:	f6 01       	movw	r30, r12
    4a76:	ee 0f       	add	r30, r30
    4a78:	ff 1f       	adc	r31, r31
    4a7a:	e2 95       	swap	r30
    4a7c:	f2 95       	swap	r31
    4a7e:	f0 7f       	andi	r31, 0xF0	; 240
    4a80:	fe 27       	eor	r31, r30
    4a82:	e0 7f       	andi	r30, 0xF0	; 240
    4a84:	fe 27       	eor	r31, r30
    4a86:	ec 19       	sub	r30, r12
    4a88:	fd 09       	sbc	r31, r13
    4a8a:	e5 51       	subi	r30, 0x15	; 21
    4a8c:	fa 4f       	sbci	r31, 0xFA	; 250
    4a8e:	84 e0       	ldi	r24, 0x04	; 4
    4a90:	80 8b       	std	Z+16, r24	; 0x10
					//Goi tiep theo gui di se co co ACK
					tcpSessionTable[i].nextAck = 1;
    4a92:	81 e0       	ldi	r24, 0x01	; 1
    4a94:	81 8f       	std	Z+25, r24	; 0x19
    4a96:	33 c4       	rjmp	.+2150   	; 0x52fe <TCPProcess+0xcaa>
			}
			break;
		//Truong hop ket noi da duoc thiet lap
		case(TCP_STATE_ESTABLISHED):
			//Neu nhan duoc yeu cau ket thuc ket noi tu client
			if ((tcpHeader->Flags) & TCP_FIN_FLAG){
    4a98:	50 ff       	sbrs	r21, 0
    4a9a:	63 c0       	rjmp	.+198    	; 0x4b62 <TCPProcess+0x50e>
				//Chuyen sang trang thai ke tiep la trang thai cho ACK cuoi
				//Dung ra o day phai chuyen sang trang thai TCP_STATE_CLOSE_WAIT nhung khong can thiet
				//  vi o day ta co the dong ket noi ngay ma khong can cho gui xong du lieu
				tcpSessionTable[i].sesState = TCP_STATE_LAST_ACK;
    4a9c:	0f 2e       	mov	r0, r31
    4a9e:	ff e1       	ldi	r31, 0x1F	; 31
    4aa0:	ef 2e       	mov	r14, r31
    4aa2:	ff 24       	eor	r15, r15
    4aa4:	f0 2d       	mov	r31, r0
    4aa6:	ce 9c       	mul	r12, r14
    4aa8:	f0 01       	movw	r30, r0
    4aaa:	cf 9c       	mul	r12, r15
    4aac:	f0 0d       	add	r31, r0
    4aae:	de 9c       	mul	r13, r14
    4ab0:	f0 0d       	add	r31, r0
    4ab2:	11 24       	eor	r1, r1
    4ab4:	e5 51       	subi	r30, 0x15	; 21
    4ab6:	fa 4f       	sbci	r31, 0xFA	; 250
    4ab8:	8a e0       	ldi	r24, 0x0A	; 10
    4aba:	80 8b       	std	Z+16, r24	; 0x10
				//Cap nhat ack
				tcpSessionTable[i].ackNumber = HTONL((tcpHeader->seqNumber)) + dataLen;
    4abc:	2c 81       	ldd	r18, Y+4	; 0x04
    4abe:	3d 81       	ldd	r19, Y+5	; 0x05
    4ac0:	4e 81       	ldd	r20, Y+6	; 0x06
    4ac2:	5f 81       	ldd	r21, Y+7	; 0x07
    4ac4:	65 2e       	mov	r6, r21
    4ac6:	77 24       	eor	r7, r7
    4ac8:	88 24       	eor	r8, r8
    4aca:	99 24       	eor	r9, r9
    4acc:	b2 2f       	mov	r27, r18
    4ace:	aa 27       	eor	r26, r26
    4ad0:	99 27       	eor	r25, r25
    4ad2:	88 27       	eor	r24, r24
    4ad4:	68 2a       	or	r6, r24
    4ad6:	79 2a       	or	r7, r25
    4ad8:	8a 2a       	or	r8, r26
    4ada:	9b 2a       	or	r9, r27
    4adc:	da 01       	movw	r26, r20
    4ade:	c9 01       	movw	r24, r18
    4ae0:	80 70       	andi	r24, 0x00	; 0
    4ae2:	90 70       	andi	r25, 0x00	; 0
    4ae4:	b0 70       	andi	r27, 0x00	; 0
    4ae6:	89 2f       	mov	r24, r25
    4ae8:	9a 2f       	mov	r25, r26
    4aea:	ab 2f       	mov	r26, r27
    4aec:	bb 27       	eor	r27, r27
    4aee:	68 2a       	or	r6, r24
    4af0:	79 2a       	or	r7, r25
    4af2:	8a 2a       	or	r8, r26
    4af4:	9b 2a       	or	r9, r27
    4af6:	20 70       	andi	r18, 0x00	; 0
    4af8:	40 70       	andi	r20, 0x00	; 0
    4afa:	50 70       	andi	r21, 0x00	; 0
    4afc:	b4 2f       	mov	r27, r20
    4afe:	a3 2f       	mov	r26, r19
    4b00:	92 2f       	mov	r25, r18
    4b02:	88 27       	eor	r24, r24
    4b04:	86 29       	or	r24, r6
    4b06:	97 29       	or	r25, r7
    4b08:	a8 29       	or	r26, r8
    4b0a:	b9 29       	or	r27, r9
    4b0c:	01 96       	adiw	r24, 0x01	; 1
    4b0e:	a1 1d       	adc	r26, r1
    4b10:	b1 1d       	adc	r27, r1
    4b12:	9b 01       	movw	r18, r22
    4b14:	40 e0       	ldi	r20, 0x00	; 0
    4b16:	50 e0       	ldi	r21, 0x00	; 0
				tcpSessionTable[i].ackNumber++;	//Tang 1 cho co FIN
    4b18:	82 0f       	add	r24, r18
    4b1a:	93 1f       	adc	r25, r19
    4b1c:	a4 1f       	adc	r26, r20
    4b1e:	b5 1f       	adc	r27, r21
    4b20:	84 87       	std	Z+12, r24	; 0x0c
    4b22:	95 87       	std	Z+13, r25	; 0x0d
    4b24:	a6 87       	std	Z+14, r26	; 0x0e
    4b26:	b7 87       	std	Z+15, r27	; 0x0f
				//Gui xac nhan ACK cho yeu cau dong ket noi dong thoi thong bao san sang dong ket noi
				TCPPackedSend(&tcpSessionTable[i],TCP_ACK_FLAG,0,tcpData);
    4b28:	81 2f       	mov	r24, r17
    4b2a:	90 e0       	ldi	r25, 0x00	; 0
    4b2c:	8e 9d       	mul	r24, r14
    4b2e:	e0 01       	movw	r28, r0
    4b30:	8f 9d       	mul	r24, r15
    4b32:	d0 0d       	add	r29, r0
    4b34:	9e 9d       	mul	r25, r14
    4b36:	d0 0d       	add	r29, r0
    4b38:	11 24       	eor	r1, r1
    4b3a:	c5 51       	subi	r28, 0x15	; 21
    4b3c:	da 4f       	sbci	r29, 0xFA	; 250
    4b3e:	ce 01       	movw	r24, r28
    4b40:	60 e1       	ldi	r22, 0x10	; 16
    4b42:	40 e0       	ldi	r20, 0x00	; 0
    4b44:	50 e0       	ldi	r21, 0x00	; 0
    4b46:	95 01       	movw	r18, r10
    4b48:	0e 94 82 21 	call	0x4304	; 0x4304 <TCPPackedSend>
				TCPPackedSend(&tcpSessionTable[i],(TCP_FIN_FLAG|TCP_ACK_FLAG),0,tcpData);
    4b4c:	ce 01       	movw	r24, r28
    4b4e:	61 e1       	ldi	r22, 0x11	; 17
    4b50:	40 e0       	ldi	r20, 0x00	; 0
    4b52:	50 e0       	ldi	r21, 0x00	; 0
    4b54:	95 01       	movw	r18, r10
    4b56:	0e 94 82 21 	call	0x4304	; 0x4304 <TCPPackedSend>
				//Dang le truyen o trang thai CLOSE_WAIT nhung ta thuc hien o day luon
				TCPCloseSession(i);
    4b5a:	81 2f       	mov	r24, r17
    4b5c:	0e 94 aa 20 	call	0x4154	; 0x4154 <TCPCloseSession>
    4b60:	ce c3       	rjmp	.+1948   	; 0x52fe <TCPProcess+0xcaa>
			//Neu khong (dang truyen du lieu)
			}else{
				//Kiem tra ACK tu remote host
				if((tcpHeader->Flags) & TCP_ACK_FLAG){	//Neu co co ACK thi kiem tra gia tri ACK
    4b62:	54 ff       	sbrs	r21, 4
    4b64:	7e c0       	rjmp	.+252    	; 0x4c62 <TCPProcess+0x60e>
					tcpSessionTable[i].lastRxAck = HTONL((tcpHeader->ackNumber));
    4b66:	68 84       	ldd	r6, Y+8	; 0x08
    4b68:	79 84       	ldd	r7, Y+9	; 0x09
    4b6a:	8a 84       	ldd	r8, Y+10	; 0x0a
    4b6c:	9b 84       	ldd	r9, Y+11	; 0x0b
    4b6e:	2f e1       	ldi	r18, 0x1F	; 31
    4b70:	30 e0       	ldi	r19, 0x00	; 0
    4b72:	c2 9e       	mul	r12, r18
    4b74:	c0 01       	movw	r24, r0
    4b76:	c3 9e       	mul	r12, r19
    4b78:	90 0d       	add	r25, r0
    4b7a:	d2 9e       	mul	r13, r18
    4b7c:	90 0d       	add	r25, r0
    4b7e:	11 24       	eor	r1, r1
    4b80:	fc 01       	movw	r30, r24
    4b82:	e5 51       	subi	r30, 0x15	; 21
    4b84:	fa 4f       	sbci	r31, 0xFA	; 250
    4b86:	29 2d       	mov	r18, r9
    4b88:	33 27       	eor	r19, r19
    4b8a:	44 27       	eor	r20, r20
    4b8c:	55 27       	eor	r21, r21
    4b8e:	b6 2d       	mov	r27, r6
    4b90:	aa 27       	eor	r26, r26
    4b92:	99 27       	eor	r25, r25
    4b94:	88 27       	eor	r24, r24
    4b96:	28 2b       	or	r18, r24
    4b98:	39 2b       	or	r19, r25
    4b9a:	4a 2b       	or	r20, r26
    4b9c:	5b 2b       	or	r21, r27
    4b9e:	d4 01       	movw	r26, r8
    4ba0:	c3 01       	movw	r24, r6
    4ba2:	80 70       	andi	r24, 0x00	; 0
    4ba4:	90 70       	andi	r25, 0x00	; 0
    4ba6:	b0 70       	andi	r27, 0x00	; 0
    4ba8:	89 2f       	mov	r24, r25
    4baa:	9a 2f       	mov	r25, r26
    4bac:	ab 2f       	mov	r26, r27
    4bae:	bb 27       	eor	r27, r27
    4bb0:	28 2b       	or	r18, r24
    4bb2:	39 2b       	or	r19, r25
    4bb4:	4a 2b       	or	r20, r26
    4bb6:	5b 2b       	or	r21, r27
    4bb8:	d4 01       	movw	r26, r8
    4bba:	c3 01       	movw	r24, r6
    4bbc:	80 70       	andi	r24, 0x00	; 0
    4bbe:	a0 70       	andi	r26, 0x00	; 0
    4bc0:	b0 70       	andi	r27, 0x00	; 0
    4bc2:	ba 2f       	mov	r27, r26
    4bc4:	a9 2f       	mov	r26, r25
    4bc6:	98 2f       	mov	r25, r24
    4bc8:	88 27       	eor	r24, r24
    4bca:	82 2b       	or	r24, r18
    4bcc:	93 2b       	or	r25, r19
    4bce:	a4 2b       	or	r26, r20
    4bd0:	b5 2b       	or	r27, r21
    4bd2:	85 8b       	std	Z+21, r24	; 0x15
    4bd4:	96 8b       	std	Z+22, r25	; 0x16
    4bd6:	a7 8b       	std	Z+23, r26	; 0x17
    4bd8:	b0 8f       	std	Z+24, r27	; 0x18
					if ((tcpSessionTable[i].seqNumber) == HTONL((tcpHeader->ackNumber))){	//Dung ACK
    4bda:	28 85       	ldd	r18, Y+8	; 0x08
    4bdc:	39 85       	ldd	r19, Y+9	; 0x09
    4bde:	4a 85       	ldd	r20, Y+10	; 0x0a
    4be0:	5b 85       	ldd	r21, Y+11	; 0x0b
    4be2:	65 2e       	mov	r6, r21
    4be4:	77 24       	eor	r7, r7
    4be6:	88 24       	eor	r8, r8
    4be8:	99 24       	eor	r9, r9
    4bea:	b2 2f       	mov	r27, r18
    4bec:	aa 27       	eor	r26, r26
    4bee:	99 27       	eor	r25, r25
    4bf0:	88 27       	eor	r24, r24
    4bf2:	68 2a       	or	r6, r24
    4bf4:	79 2a       	or	r7, r25
    4bf6:	8a 2a       	or	r8, r26
    4bf8:	9b 2a       	or	r9, r27
    4bfa:	da 01       	movw	r26, r20
    4bfc:	c9 01       	movw	r24, r18
    4bfe:	80 70       	andi	r24, 0x00	; 0
    4c00:	90 70       	andi	r25, 0x00	; 0
    4c02:	b0 70       	andi	r27, 0x00	; 0
    4c04:	89 2f       	mov	r24, r25
    4c06:	9a 2f       	mov	r25, r26
    4c08:	ab 2f       	mov	r26, r27
    4c0a:	bb 27       	eor	r27, r27
    4c0c:	68 2a       	or	r6, r24
    4c0e:	79 2a       	or	r7, r25
    4c10:	8a 2a       	or	r8, r26
    4c12:	9b 2a       	or	r9, r27
    4c14:	da 01       	movw	r26, r20
    4c16:	c9 01       	movw	r24, r18
    4c18:	80 70       	andi	r24, 0x00	; 0
    4c1a:	a0 70       	andi	r26, 0x00	; 0
    4c1c:	b0 70       	andi	r27, 0x00	; 0
    4c1e:	ba 2f       	mov	r27, r26
    4c20:	a9 2f       	mov	r26, r25
    4c22:	98 2f       	mov	r25, r24
    4c24:	88 27       	eor	r24, r24
    4c26:	a4 01       	movw	r20, r8
    4c28:	93 01       	movw	r18, r6
    4c2a:	28 2b       	or	r18, r24
    4c2c:	39 2b       	or	r19, r25
    4c2e:	4a 2b       	or	r20, r26
    4c30:	5b 2b       	or	r21, r27
    4c32:	80 85       	ldd	r24, Z+8	; 0x08
    4c34:	91 85       	ldd	r25, Z+9	; 0x09
    4c36:	a2 85       	ldd	r26, Z+10	; 0x0a
    4c38:	b3 85       	ldd	r27, Z+11	; 0x0b
    4c3a:	82 17       	cp	r24, r18
    4c3c:	93 07       	cpc	r25, r19
    4c3e:	a4 07       	cpc	r26, r20
    4c40:	b5 07       	cpc	r27, r21
    4c42:	79 f0       	breq	.+30     	; 0x4c62 <TCPProcess+0x60e>
					}else{	//Phia ben kia khong nhan duoc du thong tin
						//Sua loi o day
						//Process error correction here
						//Not finish yet, temporary just ignore it and continue with next data
						//Chua thuc hien
						tcpSessionTable[i].seqNumber = HTONL((tcpHeader->ackNumber));
    4c44:	8f e1       	ldi	r24, 0x1F	; 31
    4c46:	90 e0       	ldi	r25, 0x00	; 0
    4c48:	c8 9e       	mul	r12, r24
    4c4a:	f0 01       	movw	r30, r0
    4c4c:	c9 9e       	mul	r12, r25
    4c4e:	f0 0d       	add	r31, r0
    4c50:	d8 9e       	mul	r13, r24
    4c52:	f0 0d       	add	r31, r0
    4c54:	11 24       	eor	r1, r1
    4c56:	e5 51       	subi	r30, 0x15	; 21
    4c58:	fa 4f       	sbci	r31, 0xFA	; 250
    4c5a:	20 87       	std	Z+8, r18	; 0x08
    4c5c:	31 87       	std	Z+9, r19	; 0x09
    4c5e:	42 87       	std	Z+10, r20	; 0x0a
    4c60:	53 87       	std	Z+11, r21	; 0x0b
						#endif
					}
				}
				//--Ket thuc kiem tra ACK
				//Kiem tra sequence number
				tmp = HTONL((tcpHeader->seqNumber));
    4c62:	2c 81       	ldd	r18, Y+4	; 0x04
    4c64:	3d 81       	ldd	r19, Y+5	; 0x05
    4c66:	4e 81       	ldd	r20, Y+6	; 0x06
    4c68:	5f 81       	ldd	r21, Y+7	; 0x07
    4c6a:	65 2e       	mov	r6, r21
    4c6c:	77 24       	eor	r7, r7
    4c6e:	88 24       	eor	r8, r8
    4c70:	99 24       	eor	r9, r9
    4c72:	b2 2f       	mov	r27, r18
    4c74:	aa 27       	eor	r26, r26
    4c76:	99 27       	eor	r25, r25
    4c78:	88 27       	eor	r24, r24
    4c7a:	68 2a       	or	r6, r24
    4c7c:	79 2a       	or	r7, r25
    4c7e:	8a 2a       	or	r8, r26
    4c80:	9b 2a       	or	r9, r27
    4c82:	da 01       	movw	r26, r20
    4c84:	c9 01       	movw	r24, r18
    4c86:	80 70       	andi	r24, 0x00	; 0
    4c88:	90 70       	andi	r25, 0x00	; 0
    4c8a:	b0 70       	andi	r27, 0x00	; 0
    4c8c:	89 2f       	mov	r24, r25
    4c8e:	9a 2f       	mov	r25, r26
    4c90:	ab 2f       	mov	r26, r27
    4c92:	bb 27       	eor	r27, r27
    4c94:	86 29       	or	r24, r6
    4c96:	97 29       	or	r25, r7
    4c98:	a8 29       	or	r26, r8
    4c9a:	b9 29       	or	r27, r9
    4c9c:	20 70       	andi	r18, 0x00	; 0
    4c9e:	40 70       	andi	r20, 0x00	; 0
    4ca0:	50 70       	andi	r21, 0x00	; 0
    4ca2:	66 24       	eor	r6, r6
    4ca4:	72 2e       	mov	r7, r18
    4ca6:	83 2e       	mov	r8, r19
    4ca8:	94 2e       	mov	r9, r20
    4caa:	68 2a       	or	r6, r24
    4cac:	79 2a       	or	r7, r25
    4cae:	8a 2a       	or	r8, r26
    4cb0:	9b 2a       	or	r9, r27
				//Neu khong dung goi dang cho nhan
				if (tmp != tcpSessionTable[i].ackNumber){
    4cb2:	2f e1       	ldi	r18, 0x1F	; 31
    4cb4:	30 e0       	ldi	r19, 0x00	; 0
    4cb6:	c2 9e       	mul	r12, r18
    4cb8:	c0 01       	movw	r24, r0
    4cba:	c3 9e       	mul	r12, r19
    4cbc:	90 0d       	add	r25, r0
    4cbe:	d2 9e       	mul	r13, r18
    4cc0:	90 0d       	add	r25, r0
    4cc2:	11 24       	eor	r1, r1
    4cc4:	85 51       	subi	r24, 0x15	; 21
    4cc6:	9a 4f       	sbci	r25, 0xFA	; 250
    4cc8:	dc 01       	movw	r26, r24
    4cca:	1c 96       	adiw	r26, 0x0c	; 12
    4ccc:	2d 91       	ld	r18, X+
    4cce:	3d 91       	ld	r19, X+
    4cd0:	4d 91       	ld	r20, X+
    4cd2:	5c 91       	ld	r21, X
    4cd4:	1f 97       	sbiw	r26, 0x0f	; 15
    4cd6:	26 15       	cp	r18, r6
    4cd8:	37 05       	cpc	r19, r7
    4cda:	48 05       	cpc	r20, r8
    4cdc:	59 05       	cpc	r21, r9
    4cde:	09 f4       	brne	.+2      	; 0x4ce2 <TCPProcess+0x68e>
    4ce0:	4a c0       	rjmp	.+148    	; 0x4d76 <TCPProcess+0x722>
					//there was an error, check what to do next:
					#ifdef TCP_DEBUG
					printf("Incorrect seq, got:%d,expexted:%d\r\n",tmp,tcpSessionTable[i].ackNumber);
					#endif
					if (tmp < tcpSessionTable[i].ackNumber){
    4ce2:	62 16       	cp	r6, r18
    4ce4:	73 06       	cpc	r7, r19
    4ce6:	84 06       	cpc	r8, r20
    4ce8:	95 06       	cpc	r9, r21
    4cea:	68 f5       	brcc	.+90     	; 0x4d46 <TCPProcess+0x6f2>
						//Neu dang doi du lieu bat dau tu byte thu n nhung ta nhan duoc doan du lieu bat dau tu (n-k)
						//Tinh phan du lieu thua (k = n - (n-k))
						tmp = (tcpSessionTable[i].ackNumber - tmp);
    4cec:	da 01       	movw	r26, r20
    4cee:	c9 01       	movw	r24, r18
    4cf0:	86 19       	sub	r24, r6
    4cf2:	97 09       	sbc	r25, r7
    4cf4:	a8 09       	sbc	r26, r8
    4cf6:	b9 09       	sbc	r27, r9
    4cf8:	3c 01       	movw	r6, r24
    4cfa:	4d 01       	movw	r8, r26
						//Neu doan du lieu thua it hon du lieu nhan duoc
						if(tmp < dataLen){
    4cfc:	cb 01       	movw	r24, r22
    4cfe:	a0 e0       	ldi	r26, 0x00	; 0
    4d00:	b0 e0       	ldi	r27, 0x00	; 0
    4d02:	68 16       	cp	r6, r24
    4d04:	79 06       	cpc	r7, r25
    4d06:	8a 06       	cpc	r8, r26
    4d08:	9b 06       	cpc	r9, r27
    4d0a:	28 f4       	brcc	.+10     	; 0x4d16 <TCPProcess+0x6c2>
							//Bo di phan du lieu thua, nhan phan con lai
							tcpData += tmp;
    4d0c:	a6 0c       	add	r10, r6
    4d0e:	b7 1c       	adc	r11, r7
							dataLen = dataLen - tmp;
    4d10:	66 19       	sub	r22, r6
    4d12:	77 09       	sbc	r23, r7
    4d14:	30 c0       	rjmp	.+96     	; 0x4d76 <TCPProcess+0x722>
						}else{	//Neu tat ca du lieu nhan duoc deu thua
							//Gui lai ACK, bo goi vua nhan duoc
							dataLen = 0;
							TCPPackedSend(&tcpSessionTable[i],(TCP_ACK_FLAG),0,tcpData);
    4d16:	81 2f       	mov	r24, r17
    4d18:	90 e0       	ldi	r25, 0x00	; 0
    4d1a:	9c 01       	movw	r18, r24
    4d1c:	22 0f       	add	r18, r18
    4d1e:	33 1f       	adc	r19, r19
    4d20:	22 95       	swap	r18
    4d22:	32 95       	swap	r19
    4d24:	30 7f       	andi	r19, 0xF0	; 240
    4d26:	32 27       	eor	r19, r18
    4d28:	20 7f       	andi	r18, 0xF0	; 240
    4d2a:	32 27       	eor	r19, r18
    4d2c:	d9 01       	movw	r26, r18
    4d2e:	a8 1b       	sub	r26, r24
    4d30:	b9 0b       	sbc	r27, r25
    4d32:	cd 01       	movw	r24, r26
    4d34:	85 51       	subi	r24, 0x15	; 21
    4d36:	9a 4f       	sbci	r25, 0xFA	; 250
    4d38:	60 e1       	ldi	r22, 0x10	; 16
    4d3a:	40 e0       	ldi	r20, 0x00	; 0
    4d3c:	50 e0       	ldi	r21, 0x00	; 0
    4d3e:	95 01       	movw	r18, r10
    4d40:	0e 94 82 21 	call	0x4304	; 0x4304 <TCPPackedSend>
							return;
    4d44:	f7 c2       	rjmp	.+1518   	; 0x5334 <TCPProcess+0xce0>
						}
					//Neu seq > ack (tuc la co 1 doan du lieu bi mat)
					}else{ //tmp > tcp....
						//Yeu cau gui lai
						TCPPackedSend(&tcpSessionTable[i],(TCP_ACK_FLAG),0,tcpData);
    4d46:	81 2f       	mov	r24, r17
    4d48:	90 e0       	ldi	r25, 0x00	; 0
    4d4a:	9c 01       	movw	r18, r24
    4d4c:	22 0f       	add	r18, r18
    4d4e:	33 1f       	adc	r19, r19
    4d50:	22 95       	swap	r18
    4d52:	32 95       	swap	r19
    4d54:	30 7f       	andi	r19, 0xF0	; 240
    4d56:	32 27       	eor	r19, r18
    4d58:	20 7f       	andi	r18, 0xF0	; 240
    4d5a:	32 27       	eor	r19, r18
    4d5c:	f9 01       	movw	r30, r18
    4d5e:	e8 1b       	sub	r30, r24
    4d60:	f9 0b       	sbc	r31, r25
    4d62:	cf 01       	movw	r24, r30
    4d64:	85 51       	subi	r24, 0x15	; 21
    4d66:	9a 4f       	sbci	r25, 0xFA	; 250
    4d68:	60 e1       	ldi	r22, 0x10	; 16
    4d6a:	40 e0       	ldi	r20, 0x00	; 0
    4d6c:	50 e0       	ldi	r21, 0x00	; 0
    4d6e:	95 01       	movw	r18, r10
    4d70:	0e 94 82 21 	call	0x4304	; 0x4304 <TCPPackedSend>
						return;
    4d74:	df c2       	rjmp	.+1470   	; 0x5334 <TCPProcess+0xce0>
				}
				//Neu thuc thi den day nghia la sequence number == ack number (chinh xac)
				//--Ket thuc kiem tra so tuan tu
				//Kiem tra chieu dai buffer de chac chan la chieu dai du lieu nhan duoc khong qua buffer
				//
				if (tcpData > (buffer + ETHERNET_BUFFER_SIZE))
    4d76:	c7 01       	movw	r24, r14
    4d78:	82 5e       	subi	r24, 0xE2	; 226
    4d7a:	9b 4f       	sbci	r25, 0xFB	; 251
    4d7c:	ec 01       	movw	r28, r24
    4d7e:	a8 16       	cp	r10, r24
    4d80:	b9 06       	cpc	r11, r25
    4d82:	08 f4       	brcc	.+2      	; 0x4d86 <TCPProcess+0x732>
    4d84:	e5 01       	movw	r28, r10
					tcpData = (buffer + ETHERNET_BUFFER_SIZE);
				if ((tcpData + dataLen) > buffer + ETHERNET_BUFFER_SIZE){
    4d86:	fe 01       	movw	r30, r28
    4d88:	e6 0f       	add	r30, r22
    4d8a:	f7 1f       	adc	r31, r23
    4d8c:	8e 17       	cp	r24, r30
    4d8e:	9f 07       	cpc	r25, r31
    4d90:	18 f4       	brcc	.+6      	; 0x4d98 <TCPProcess+0x744>
					dataLen = (buffer + ETHERNET_BUFFER_SIZE) - tcpData;				
    4d92:	bc 01       	movw	r22, r24
    4d94:	6c 1b       	sub	r22, r28
    4d96:	7d 0b       	sbc	r23, r29
				}
				//
				//Cap nhat ack cho lan nhan ke tiep
				tcpSessionTable[i].ackNumber = tcpSessionTable[i].ackNumber + dataLen;
    4d98:	8f e1       	ldi	r24, 0x1F	; 31
    4d9a:	90 e0       	ldi	r25, 0x00	; 0
    4d9c:	c8 9e       	mul	r12, r24
    4d9e:	f0 01       	movw	r30, r0
    4da0:	c9 9e       	mul	r12, r25
    4da2:	f0 0d       	add	r31, r0
    4da4:	d8 9e       	mul	r13, r24
    4da6:	f0 0d       	add	r31, r0
    4da8:	11 24       	eor	r1, r1
    4daa:	e5 51       	subi	r30, 0x15	; 21
    4dac:	fa 4f       	sbci	r31, 0xFA	; 250
    4dae:	cb 01       	movw	r24, r22
    4db0:	a0 e0       	ldi	r26, 0x00	; 0
    4db2:	b0 e0       	ldi	r27, 0x00	; 0
    4db4:	82 0f       	add	r24, r18
    4db6:	93 1f       	adc	r25, r19
    4db8:	a4 1f       	adc	r26, r20
    4dba:	b5 1f       	adc	r27, r21
    4dbc:	84 87       	std	Z+12, r24	; 0x0c
    4dbe:	95 87       	std	Z+13, r25	; 0x0d
    4dc0:	a6 87       	std	Z+14, r26	; 0x0e
    4dc2:	b7 87       	std	Z+15, r27	; 0x0f
				#ifdef TCP_DEBUG
				printf("Data length (%d), buffer size(%d)\n\r",dataLen,(buffer + ETHERNET_BUFFER_SIZE - tcpData));
				printf("Ack Number (%d)\n\r",tcpSessionTable[i].ackNumber);
				#endif
				//Goi tiep theo gui di se co co ACK
				tcpSessionTable[i].nextAck = 1;
    4dc4:	81 e0       	ldi	r24, 0x01	; 1
    4dc6:	81 8f       	std	Z+25, r24	; 0x19
				//Goi ham xu ly lop ung dung
				if(dataLen != 0){
    4dc8:	61 15       	cp	r22, r1
    4dca:	71 05       	cpc	r23, r1
    4dcc:	09 f4       	brne	.+2      	; 0x4dd0 <TCPProcess+0x77c>
    4dce:	97 c2       	rjmp	.+1326   	; 0x52fe <TCPProcess+0xcaa>
					(tcpSessionTable[i].appDataIn)(tcpData, dataLen,&tcpSessionTable[i]);
    4dd0:	8f e1       	ldi	r24, 0x1F	; 31
    4dd2:	90 e0       	ldi	r25, 0x00	; 0
    4dd4:	c8 9e       	mul	r12, r24
    4dd6:	f0 01       	movw	r30, r0
    4dd8:	c9 9e       	mul	r12, r25
    4dda:	f0 0d       	add	r31, r0
    4ddc:	d8 9e       	mul	r13, r24
    4dde:	f0 0d       	add	r31, r0
    4de0:	11 24       	eor	r1, r1
    4de2:	e5 51       	subi	r30, 0x15	; 21
    4de4:	fa 4f       	sbci	r31, 0xFA	; 250
    4de6:	21 2f       	mov	r18, r17
    4de8:	30 e0       	ldi	r19, 0x00	; 0
    4dea:	28 9f       	mul	r18, r24
    4dec:	a0 01       	movw	r20, r0
    4dee:	29 9f       	mul	r18, r25
    4df0:	50 0d       	add	r21, r0
    4df2:	38 9f       	mul	r19, r24
    4df4:	50 0d       	add	r21, r0
    4df6:	11 24       	eor	r1, r1
    4df8:	45 51       	subi	r20, 0x15	; 21
    4dfa:	5a 4f       	sbci	r21, 0xFA	; 250
    4dfc:	03 8c       	ldd	r0, Z+27	; 0x1b
    4dfe:	f4 8d       	ldd	r31, Z+28	; 0x1c
    4e00:	e0 2d       	mov	r30, r0
    4e02:	ce 01       	movw	r24, r28
    4e04:	09 95       	icall
    4e06:	7b c2       	rjmp	.+1270   	; 0x52fe <TCPProcess+0xcaa>
			//--Ket thuc xu ly truong hop dang truyen du lieu
			break;
		//Neu la trang thai doi LAST_ACK (2 phia deu san sang dong ket noi, dang doi xac nhan ack cuoi cung)
		case(TCP_STATE_LAST_ACK):
			//socket is closed
			tmp = HTONL((tcpHeader->seqNumber));
    4e08:	8c 81       	ldd	r24, Y+4	; 0x04
    4e0a:	9d 81       	ldd	r25, Y+5	; 0x05
    4e0c:	ae 81       	ldd	r26, Y+6	; 0x06
    4e0e:	bf 81       	ldd	r27, Y+7	; 0x07
			//Kiem tra ACK, neu dung ACK
			if (tmp == tcpSessionTable[i].seqNumber + 1){
    4e10:	2f e1       	ldi	r18, 0x1F	; 31
    4e12:	30 e0       	ldi	r19, 0x00	; 0
    4e14:	c2 9e       	mul	r12, r18
    4e16:	f0 01       	movw	r30, r0
    4e18:	c3 9e       	mul	r12, r19
    4e1a:	f0 0d       	add	r31, r0
    4e1c:	d2 9e       	mul	r13, r18
    4e1e:	f0 0d       	add	r31, r0
    4e20:	11 24       	eor	r1, r1
    4e22:	e5 51       	subi	r30, 0x15	; 21
    4e24:	fa 4f       	sbci	r31, 0xFA	; 250
    4e26:	20 84       	ldd	r2, Z+8	; 0x08
    4e28:	31 84       	ldd	r3, Z+9	; 0x09
    4e2a:	42 84       	ldd	r4, Z+10	; 0x0a
    4e2c:	53 84       	ldd	r5, Z+11	; 0x0b
    4e2e:	08 94       	sec
    4e30:	21 1c       	adc	r2, r1
    4e32:	31 1c       	adc	r3, r1
    4e34:	41 1c       	adc	r4, r1
    4e36:	51 1c       	adc	r5, r1
			//--Ket thuc xu ly truong hop dang truyen du lieu
			break;
		//Neu la trang thai doi LAST_ACK (2 phia deu san sang dong ket noi, dang doi xac nhan ack cuoi cung)
		case(TCP_STATE_LAST_ACK):
			//socket is closed
			tmp = HTONL((tcpHeader->seqNumber));
    4e38:	6b 2e       	mov	r6, r27
    4e3a:	77 24       	eor	r7, r7
    4e3c:	88 24       	eor	r8, r8
    4e3e:	99 24       	eor	r9, r9
    4e40:	58 2f       	mov	r21, r24
    4e42:	44 27       	eor	r20, r20
    4e44:	33 27       	eor	r19, r19
    4e46:	22 27       	eor	r18, r18
    4e48:	62 2a       	or	r6, r18
    4e4a:	73 2a       	or	r7, r19
    4e4c:	84 2a       	or	r8, r20
    4e4e:	95 2a       	or	r9, r21
    4e50:	9c 01       	movw	r18, r24
    4e52:	ad 01       	movw	r20, r26
    4e54:	20 70       	andi	r18, 0x00	; 0
    4e56:	30 70       	andi	r19, 0x00	; 0
    4e58:	50 70       	andi	r21, 0x00	; 0
    4e5a:	23 2f       	mov	r18, r19
    4e5c:	34 2f       	mov	r19, r20
    4e5e:	45 2f       	mov	r20, r21
    4e60:	55 27       	eor	r21, r21
    4e62:	26 29       	or	r18, r6
    4e64:	37 29       	or	r19, r7
    4e66:	48 29       	or	r20, r8
    4e68:	59 29       	or	r21, r9
    4e6a:	80 70       	andi	r24, 0x00	; 0
    4e6c:	a0 70       	andi	r26, 0x00	; 0
    4e6e:	b0 70       	andi	r27, 0x00	; 0
    4e70:	ba 2f       	mov	r27, r26
    4e72:	a9 2f       	mov	r26, r25
    4e74:	98 2f       	mov	r25, r24
    4e76:	88 27       	eor	r24, r24
    4e78:	28 2b       	or	r18, r24
    4e7a:	39 2b       	or	r19, r25
    4e7c:	4a 2b       	or	r20, r26
    4e7e:	5b 2b       	or	r21, r27
			//Kiem tra ACK, neu dung ACK
			if (tmp == tcpSessionTable[i].seqNumber + 1){
    4e80:	22 16       	cp	r2, r18
    4e82:	33 06       	cpc	r3, r19
    4e84:	44 06       	cpc	r4, r20
    4e86:	55 06       	cpc	r5, r21
    4e88:	21 f4       	brne	.+8      	; 0x4e92 <TCPProcess+0x83e>
				TCPCloseSession(i);
    4e8a:	81 2f       	mov	r24, r17
    4e8c:	0e 94 aa 20 	call	0x4154	; 0x4154 <TCPCloseSession>
    4e90:	36 c2       	rjmp	.+1132   	; 0x52fe <TCPProcess+0xcaa>
			}else{
				//Gui lai co FIN & ACK
				TCPPackedSend(&tcpSessionTable[i], (TCP_FIN_FLAG|TCP_ACK_FLAG), 0, tcpData);
    4e92:	41 2f       	mov	r20, r17
    4e94:	50 e0       	ldi	r21, 0x00	; 0
    4e96:	2f e1       	ldi	r18, 0x1F	; 31
    4e98:	30 e0       	ldi	r19, 0x00	; 0
    4e9a:	42 9f       	mul	r20, r18
    4e9c:	c0 01       	movw	r24, r0
    4e9e:	43 9f       	mul	r20, r19
    4ea0:	90 0d       	add	r25, r0
    4ea2:	52 9f       	mul	r21, r18
    4ea4:	90 0d       	add	r25, r0
    4ea6:	11 24       	eor	r1, r1
    4ea8:	85 51       	subi	r24, 0x15	; 21
    4eaa:	9a 4f       	sbci	r25, 0xFA	; 250
    4eac:	61 e1       	ldi	r22, 0x11	; 17
    4eae:	40 e0       	ldi	r20, 0x00	; 0
    4eb0:	50 e0       	ldi	r21, 0x00	; 0
    4eb2:	95 01       	movw	r18, r10
    4eb4:	0e 94 82 21 	call	0x4304	; 0x4304 <TCPPackedSend>
    4eb8:	22 c2       	rjmp	.+1092   	; 0x52fe <TCPProcess+0xcaa>

		//Truong hop ngat ket noi thu dong, da nhan co FIN tu remote host va xac nhan
		case(TCP_STATE_CLOSE_WAIT):
			//Truong hop nay se khong xay ra vi o tren ta chuyen truc tiep
			//  sang LAST_ACK khi nhan duoc yeu cau dong ket noi
			tcpSessionTable[i].sesState = TCP_STATE_LAST_ACK;
    4eba:	8f e1       	ldi	r24, 0x1F	; 31
    4ebc:	90 e0       	ldi	r25, 0x00	; 0
    4ebe:	c8 9e       	mul	r12, r24
    4ec0:	f0 01       	movw	r30, r0
    4ec2:	c9 9e       	mul	r12, r25
    4ec4:	f0 0d       	add	r31, r0
    4ec6:	d8 9e       	mul	r13, r24
    4ec8:	f0 0d       	add	r31, r0
    4eca:	11 24       	eor	r1, r1
    4ecc:	e5 51       	subi	r30, 0x15	; 21
    4ece:	fa 4f       	sbci	r31, 0xFA	; 250
    4ed0:	8a e0       	ldi	r24, 0x0A	; 10
    4ed2:	80 8b       	std	Z+16, r24	; 0x10
			if(dataLen){
    4ed4:	61 15       	cp	r22, r1
    4ed6:	71 05       	cpc	r23, r1
    4ed8:	09 f4       	brne	.+2      	; 0x4edc <TCPProcess+0x888>
    4eda:	3f c0       	rjmp	.+126    	; 0x4f5a <TCPProcess+0x906>
				tcpSessionTable[i].ackNumber = HTONL((tcpHeader->seqNumber)) + dataLen;
    4edc:	8c 81       	ldd	r24, Y+4	; 0x04
    4ede:	9d 81       	ldd	r25, Y+5	; 0x05
    4ee0:	ae 81       	ldd	r26, Y+6	; 0x06
    4ee2:	bf 81       	ldd	r27, Y+7	; 0x07
    4ee4:	2f e1       	ldi	r18, 0x1F	; 31
    4ee6:	30 e0       	ldi	r19, 0x00	; 0
    4ee8:	c2 9e       	mul	r12, r18
    4eea:	f0 01       	movw	r30, r0
    4eec:	c3 9e       	mul	r12, r19
    4eee:	f0 0d       	add	r31, r0
    4ef0:	d2 9e       	mul	r13, r18
    4ef2:	f0 0d       	add	r31, r0
    4ef4:	11 24       	eor	r1, r1
    4ef6:	e5 51       	subi	r30, 0x15	; 21
    4ef8:	fa 4f       	sbci	r31, 0xFA	; 250
    4efa:	1b 01       	movw	r2, r22
    4efc:	44 24       	eor	r4, r4
    4efe:	55 24       	eor	r5, r5
    4f00:	6b 2e       	mov	r6, r27
    4f02:	77 24       	eor	r7, r7
    4f04:	88 24       	eor	r8, r8
    4f06:	99 24       	eor	r9, r9
    4f08:	58 2f       	mov	r21, r24
    4f0a:	44 27       	eor	r20, r20
    4f0c:	33 27       	eor	r19, r19
    4f0e:	22 27       	eor	r18, r18
    4f10:	62 2a       	or	r6, r18
    4f12:	73 2a       	or	r7, r19
    4f14:	84 2a       	or	r8, r20
    4f16:	95 2a       	or	r9, r21
    4f18:	9c 01       	movw	r18, r24
    4f1a:	ad 01       	movw	r20, r26
    4f1c:	20 70       	andi	r18, 0x00	; 0
    4f1e:	30 70       	andi	r19, 0x00	; 0
    4f20:	50 70       	andi	r21, 0x00	; 0
    4f22:	23 2f       	mov	r18, r19
    4f24:	34 2f       	mov	r19, r20
    4f26:	45 2f       	mov	r20, r21
    4f28:	55 27       	eor	r21, r21
    4f2a:	26 29       	or	r18, r6
    4f2c:	37 29       	or	r19, r7
    4f2e:	48 29       	or	r20, r8
    4f30:	59 29       	or	r21, r9
    4f32:	80 70       	andi	r24, 0x00	; 0
    4f34:	a0 70       	andi	r26, 0x00	; 0
    4f36:	b0 70       	andi	r27, 0x00	; 0
    4f38:	ba 2f       	mov	r27, r26
    4f3a:	a9 2f       	mov	r26, r25
    4f3c:	98 2f       	mov	r25, r24
    4f3e:	88 27       	eor	r24, r24
    4f40:	28 2b       	or	r18, r24
    4f42:	39 2b       	or	r19, r25
    4f44:	4a 2b       	or	r20, r26
    4f46:	5b 2b       	or	r21, r27
    4f48:	22 0d       	add	r18, r2
    4f4a:	33 1d       	adc	r19, r3
    4f4c:	44 1d       	adc	r20, r4
    4f4e:	55 1d       	adc	r21, r5
    4f50:	24 87       	std	Z+12, r18	; 0x0c
    4f52:	35 87       	std	Z+13, r19	; 0x0d
    4f54:	46 87       	std	Z+14, r20	; 0x0e
    4f56:	57 87       	std	Z+15, r21	; 0x0f
    4f58:	3a c0       	rjmp	.+116    	; 0x4fce <TCPProcess+0x97a>
			}else{	//Neu dataLen == 0 thi cung tang so tuan tu len 1
				tcpSessionTable[i].ackNumber = HTONL((tcpHeader->seqNumber))+1;
    4f5a:	8c 81       	ldd	r24, Y+4	; 0x04
    4f5c:	9d 81       	ldd	r25, Y+5	; 0x05
    4f5e:	ae 81       	ldd	r26, Y+6	; 0x06
    4f60:	bf 81       	ldd	r27, Y+7	; 0x07
    4f62:	2f e1       	ldi	r18, 0x1F	; 31
    4f64:	30 e0       	ldi	r19, 0x00	; 0
    4f66:	c2 9e       	mul	r12, r18
    4f68:	f0 01       	movw	r30, r0
    4f6a:	c3 9e       	mul	r12, r19
    4f6c:	f0 0d       	add	r31, r0
    4f6e:	d2 9e       	mul	r13, r18
    4f70:	f0 0d       	add	r31, r0
    4f72:	11 24       	eor	r1, r1
    4f74:	e5 51       	subi	r30, 0x15	; 21
    4f76:	fa 4f       	sbci	r31, 0xFA	; 250
    4f78:	6b 2e       	mov	r6, r27
    4f7a:	77 24       	eor	r7, r7
    4f7c:	88 24       	eor	r8, r8
    4f7e:	99 24       	eor	r9, r9
    4f80:	58 2f       	mov	r21, r24
    4f82:	44 27       	eor	r20, r20
    4f84:	33 27       	eor	r19, r19
    4f86:	22 27       	eor	r18, r18
    4f88:	62 2a       	or	r6, r18
    4f8a:	73 2a       	or	r7, r19
    4f8c:	84 2a       	or	r8, r20
    4f8e:	95 2a       	or	r9, r21
    4f90:	9c 01       	movw	r18, r24
    4f92:	ad 01       	movw	r20, r26
    4f94:	20 70       	andi	r18, 0x00	; 0
    4f96:	30 70       	andi	r19, 0x00	; 0
    4f98:	50 70       	andi	r21, 0x00	; 0
    4f9a:	23 2f       	mov	r18, r19
    4f9c:	34 2f       	mov	r19, r20
    4f9e:	45 2f       	mov	r20, r21
    4fa0:	55 27       	eor	r21, r21
    4fa2:	26 29       	or	r18, r6
    4fa4:	37 29       	or	r19, r7
    4fa6:	48 29       	or	r20, r8
    4fa8:	59 29       	or	r21, r9
    4faa:	80 70       	andi	r24, 0x00	; 0
    4fac:	a0 70       	andi	r26, 0x00	; 0
    4fae:	b0 70       	andi	r27, 0x00	; 0
    4fb0:	ba 2f       	mov	r27, r26
    4fb2:	a9 2f       	mov	r26, r25
    4fb4:	98 2f       	mov	r25, r24
    4fb6:	88 27       	eor	r24, r24
    4fb8:	82 2b       	or	r24, r18
    4fba:	93 2b       	or	r25, r19
    4fbc:	a4 2b       	or	r26, r20
    4fbe:	b5 2b       	or	r27, r21
    4fc0:	01 96       	adiw	r24, 0x01	; 1
    4fc2:	a1 1d       	adc	r26, r1
    4fc4:	b1 1d       	adc	r27, r1
    4fc6:	84 87       	std	Z+12, r24	; 0x0c
    4fc8:	95 87       	std	Z+13, r25	; 0x0d
    4fca:	a6 87       	std	Z+14, r26	; 0x0e
    4fcc:	b7 87       	std	Z+15, r27	; 0x0f
			}
			//tcpSessionTable[i].seqNumber = HTONL((tcpHeader->ackNumber));
			TCPPackedSend(&tcpSessionTable[i], (TCP_FIN_FLAG|TCP_ACK_FLAG), 0, tcpData);
    4fce:	41 2f       	mov	r20, r17
    4fd0:	50 e0       	ldi	r21, 0x00	; 0
    4fd2:	2f e1       	ldi	r18, 0x1F	; 31
    4fd4:	30 e0       	ldi	r19, 0x00	; 0
    4fd6:	42 9f       	mul	r20, r18
    4fd8:	c0 01       	movw	r24, r0
    4fda:	43 9f       	mul	r20, r19
    4fdc:	90 0d       	add	r25, r0
    4fde:	52 9f       	mul	r21, r18
    4fe0:	90 0d       	add	r25, r0
    4fe2:	11 24       	eor	r1, r1
    4fe4:	85 51       	subi	r24, 0x15	; 21
    4fe6:	9a 4f       	sbci	r25, 0xFA	; 250
    4fe8:	61 e1       	ldi	r22, 0x11	; 17
    4fea:	40 e0       	ldi	r20, 0x00	; 0
    4fec:	50 e0       	ldi	r21, 0x00	; 0
    4fee:	95 01       	movw	r18, r10
    4ff0:	0e 94 82 21 	call	0x4304	; 0x4304 <TCPPackedSend>
			break;
    4ff4:	84 c1       	rjmp	.+776    	; 0x52fe <TCPProcess+0xcaa>
		//Truong hop dang o trang thai FIN WAIT 1 (da truyen du lieu xong,
		//  san sang dong ket noi va da gui di co FIN va dang cho ACK)
		case(TCP_STATE_FIN_WAIT1):
			//if we receive FIN
			tcpSessionTable[i].ackNumber = HTONL((tcpHeader->seqNumber))+1;
    4ff6:	8c 81       	ldd	r24, Y+4	; 0x04
    4ff8:	9d 81       	ldd	r25, Y+5	; 0x05
    4ffa:	ae 81       	ldd	r26, Y+6	; 0x06
    4ffc:	bf 81       	ldd	r27, Y+7	; 0x07
    4ffe:	2f e1       	ldi	r18, 0x1F	; 31
    5000:	30 e0       	ldi	r19, 0x00	; 0
    5002:	c2 9e       	mul	r12, r18
    5004:	f0 01       	movw	r30, r0
    5006:	c3 9e       	mul	r12, r19
    5008:	f0 0d       	add	r31, r0
    500a:	d2 9e       	mul	r13, r18
    500c:	f0 0d       	add	r31, r0
    500e:	11 24       	eor	r1, r1
    5010:	e5 51       	subi	r30, 0x15	; 21
    5012:	fa 4f       	sbci	r31, 0xFA	; 250
    5014:	6b 2e       	mov	r6, r27
    5016:	77 24       	eor	r7, r7
    5018:	88 24       	eor	r8, r8
    501a:	99 24       	eor	r9, r9
    501c:	58 2f       	mov	r21, r24
    501e:	44 27       	eor	r20, r20
    5020:	33 27       	eor	r19, r19
    5022:	22 27       	eor	r18, r18
    5024:	62 2a       	or	r6, r18
    5026:	73 2a       	or	r7, r19
    5028:	84 2a       	or	r8, r20
    502a:	95 2a       	or	r9, r21
    502c:	9c 01       	movw	r18, r24
    502e:	ad 01       	movw	r20, r26
    5030:	20 70       	andi	r18, 0x00	; 0
    5032:	30 70       	andi	r19, 0x00	; 0
    5034:	50 70       	andi	r21, 0x00	; 0
    5036:	23 2f       	mov	r18, r19
    5038:	34 2f       	mov	r19, r20
    503a:	45 2f       	mov	r20, r21
    503c:	55 27       	eor	r21, r21
    503e:	26 29       	or	r18, r6
    5040:	37 29       	or	r19, r7
    5042:	48 29       	or	r20, r8
    5044:	59 29       	or	r21, r9
    5046:	80 70       	andi	r24, 0x00	; 0
    5048:	a0 70       	andi	r26, 0x00	; 0
    504a:	b0 70       	andi	r27, 0x00	; 0
    504c:	ba 2f       	mov	r27, r26
    504e:	a9 2f       	mov	r26, r25
    5050:	98 2f       	mov	r25, r24
    5052:	88 27       	eor	r24, r24
    5054:	28 2b       	or	r18, r24
    5056:	39 2b       	or	r19, r25
    5058:	4a 2b       	or	r20, r26
    505a:	5b 2b       	or	r21, r27
    505c:	2f 5f       	subi	r18, 0xFF	; 255
    505e:	3f 4f       	sbci	r19, 0xFF	; 255
    5060:	4f 4f       	sbci	r20, 0xFF	; 255
    5062:	5f 4f       	sbci	r21, 0xFF	; 255
    5064:	24 87       	std	Z+12, r18	; 0x0c
    5066:	35 87       	std	Z+13, r19	; 0x0d
    5068:	46 87       	std	Z+14, r20	; 0x0e
    506a:	57 87       	std	Z+15, r21	; 0x0f
			if (tcpHeader->Flags == TCP_FIN_FLAG){	//Neu chi nhan duoc co FIN
    506c:	8d 85       	ldd	r24, Y+13	; 0x0d
    506e:	81 30       	cpi	r24, 0x01	; 1
    5070:	f9 f4       	brne	.+62     	; 0x50b0 <TCPProcess+0xa5c>
				//Chuyen sang trang thai CLOSING va gui ACK
				tcpSessionTable[i].sesState = TCP_STATE_CLOSING;
    5072:	2f e1       	ldi	r18, 0x1F	; 31
    5074:	30 e0       	ldi	r19, 0x00	; 0
    5076:	c2 9e       	mul	r12, r18
    5078:	f0 01       	movw	r30, r0
    507a:	c3 9e       	mul	r12, r19
    507c:	f0 0d       	add	r31, r0
    507e:	d2 9e       	mul	r13, r18
    5080:	f0 0d       	add	r31, r0
    5082:	11 24       	eor	r1, r1
    5084:	e5 51       	subi	r30, 0x15	; 21
    5086:	fa 4f       	sbci	r31, 0xFA	; 250
    5088:	87 e0       	ldi	r24, 0x07	; 7
    508a:	80 8b       	std	Z+16, r24	; 0x10
				TCPPackedSend(&tcpSessionTable[i], (TCP_ACK_FLAG), 0, tcpData);
    508c:	41 2f       	mov	r20, r17
    508e:	50 e0       	ldi	r21, 0x00	; 0
    5090:	42 9f       	mul	r20, r18
    5092:	c0 01       	movw	r24, r0
    5094:	43 9f       	mul	r20, r19
    5096:	90 0d       	add	r25, r0
    5098:	52 9f       	mul	r21, r18
    509a:	90 0d       	add	r25, r0
    509c:	11 24       	eor	r1, r1
    509e:	85 51       	subi	r24, 0x15	; 21
    50a0:	9a 4f       	sbci	r25, 0xFA	; 250
    50a2:	60 e1       	ldi	r22, 0x10	; 16
    50a4:	40 e0       	ldi	r20, 0x00	; 0
    50a6:	50 e0       	ldi	r21, 0x00	; 0
    50a8:	95 01       	movw	r18, r10
    50aa:	0e 94 82 21 	call	0x4304	; 0x4304 <TCPPackedSend>
    50ae:	27 c1       	rjmp	.+590    	; 0x52fe <TCPProcess+0xcaa>
				//tcpSessionTable[i].seqNumber++;
				#ifdef TCP_DEBUG
				printf("Closing\n\r");
				#endif
			}else if(tcpHeader->Flags == (TCP_FIN_FLAG | TCP_ACK_FLAG)){	//Neu nhan dong thoi FIN va ACK
    50b0:	81 31       	cpi	r24, 0x11	; 17
    50b2:	09 f0       	breq	.+2      	; 0x50b6 <TCPProcess+0xa62>
    50b4:	61 c0       	rjmp	.+194    	; 0x5178 <TCPProcess+0xb24>
				//Chuyen sang trang thai TIME_WAIT va gui ACK
				//  nhung o day do chua co timer nen ta chuyen luon sang dong ket noi
				if (HTONL((tcpHeader->ackNumber)) == tcpSessionTable[i].seqNumber){
    50b6:	88 85       	ldd	r24, Y+8	; 0x08
    50b8:	99 85       	ldd	r25, Y+9	; 0x09
    50ba:	aa 85       	ldd	r26, Y+10	; 0x0a
    50bc:	bb 85       	ldd	r27, Y+11	; 0x0b
    50be:	6b 2e       	mov	r6, r27
    50c0:	77 24       	eor	r7, r7
    50c2:	88 24       	eor	r8, r8
    50c4:	99 24       	eor	r9, r9
    50c6:	58 2f       	mov	r21, r24
    50c8:	44 27       	eor	r20, r20
    50ca:	33 27       	eor	r19, r19
    50cc:	22 27       	eor	r18, r18
    50ce:	62 2a       	or	r6, r18
    50d0:	73 2a       	or	r7, r19
    50d2:	84 2a       	or	r8, r20
    50d4:	95 2a       	or	r9, r21
    50d6:	9c 01       	movw	r18, r24
    50d8:	ad 01       	movw	r20, r26
    50da:	20 70       	andi	r18, 0x00	; 0
    50dc:	30 70       	andi	r19, 0x00	; 0
    50de:	50 70       	andi	r21, 0x00	; 0
    50e0:	23 2f       	mov	r18, r19
    50e2:	34 2f       	mov	r19, r20
    50e4:	45 2f       	mov	r20, r21
    50e6:	55 27       	eor	r21, r21
    50e8:	26 29       	or	r18, r6
    50ea:	37 29       	or	r19, r7
    50ec:	48 29       	or	r20, r8
    50ee:	59 29       	or	r21, r9
    50f0:	80 70       	andi	r24, 0x00	; 0
    50f2:	a0 70       	andi	r26, 0x00	; 0
    50f4:	b0 70       	andi	r27, 0x00	; 0
    50f6:	ba 2f       	mov	r27, r26
    50f8:	a9 2f       	mov	r26, r25
    50fa:	98 2f       	mov	r25, r24
    50fc:	88 27       	eor	r24, r24
    50fe:	28 2b       	or	r18, r24
    5100:	39 2b       	or	r19, r25
    5102:	4a 2b       	or	r20, r26
    5104:	5b 2b       	or	r21, r27
    5106:	8f e1       	ldi	r24, 0x1F	; 31
    5108:	90 e0       	ldi	r25, 0x00	; 0
    510a:	c8 9e       	mul	r12, r24
    510c:	f0 01       	movw	r30, r0
    510e:	c9 9e       	mul	r12, r25
    5110:	f0 0d       	add	r31, r0
    5112:	d8 9e       	mul	r13, r24
    5114:	f0 0d       	add	r31, r0
    5116:	11 24       	eor	r1, r1
    5118:	e5 51       	subi	r30, 0x15	; 21
    511a:	fa 4f       	sbci	r31, 0xFA	; 250
    511c:	80 85       	ldd	r24, Z+8	; 0x08
    511e:	91 85       	ldd	r25, Z+9	; 0x09
    5120:	a2 85       	ldd	r26, Z+10	; 0x0a
    5122:	b3 85       	ldd	r27, Z+11	; 0x0b
    5124:	28 17       	cp	r18, r24
    5126:	39 07       	cpc	r19, r25
    5128:	4a 07       	cpc	r20, r26
    512a:	5b 07       	cpc	r21, r27
    512c:	21 f4       	brne	.+8      	; 0x5136 <TCPProcess+0xae2>
					//TCPPackedSend(&tcpSessionTable[i], (TCP_ACK_FLAG), 0, tcpData);
					TCPCloseSession(i);
    512e:	81 2f       	mov	r24, r17
    5130:	0e 94 aa 20 	call	0x4154	; 0x4154 <TCPCloseSession>
    5134:	0d c0       	rjmp	.+26     	; 0x5150 <TCPProcess+0xafc>
					#ifdef TCP_DEBUG
					printf("End\n\r");
					#endif
				}else{	//Neu khong dung ack cho thong bao FIN
					//Chuyen sang cho co ACK cuoi cung
					tcpSessionTable[i].sesState = TCP_STATE_LAST_ACK;
    5136:	8f e1       	ldi	r24, 0x1F	; 31
    5138:	90 e0       	ldi	r25, 0x00	; 0
    513a:	c8 9e       	mul	r12, r24
    513c:	f0 01       	movw	r30, r0
    513e:	c9 9e       	mul	r12, r25
    5140:	f0 0d       	add	r31, r0
    5142:	d8 9e       	mul	r13, r24
    5144:	f0 0d       	add	r31, r0
    5146:	11 24       	eor	r1, r1
    5148:	e5 51       	subi	r30, 0x15	; 21
    514a:	fa 4f       	sbci	r31, 0xFA	; 250
    514c:	8a e0       	ldi	r24, 0x0A	; 10
    514e:	80 8b       	std	Z+16, r24	; 0x10
					#ifdef TCP_DEBUG
					printf("Last ack\n\r");
					#endif
				}
				//Gui xac nhan cho co FIN
				TCPPackedSend(&tcpSessionTable[i], (TCP_ACK_FLAG), 0, tcpData);
    5150:	41 2f       	mov	r20, r17
    5152:	50 e0       	ldi	r21, 0x00	; 0
    5154:	2f e1       	ldi	r18, 0x1F	; 31
    5156:	30 e0       	ldi	r19, 0x00	; 0
    5158:	42 9f       	mul	r20, r18
    515a:	c0 01       	movw	r24, r0
    515c:	43 9f       	mul	r20, r19
    515e:	90 0d       	add	r25, r0
    5160:	52 9f       	mul	r21, r18
    5162:	90 0d       	add	r25, r0
    5164:	11 24       	eor	r1, r1
    5166:	85 51       	subi	r24, 0x15	; 21
    5168:	9a 4f       	sbci	r25, 0xFA	; 250
    516a:	60 e1       	ldi	r22, 0x10	; 16
    516c:	40 e0       	ldi	r20, 0x00	; 0
    516e:	50 e0       	ldi	r21, 0x00	; 0
    5170:	95 01       	movw	r18, r10
    5172:	0e 94 82 21 	call	0x4304	; 0x4304 <TCPPackedSend>
    5176:	c3 c0       	rjmp	.+390    	; 0x52fe <TCPProcess+0xcaa>
				//tcpSessionTable[i].seqNumber++;
			}else if(tcpHeader->Flags == TCP_ACK_FLAG){	//Neu chi nhan duoc ACK
    5178:	80 31       	cpi	r24, 0x10	; 16
    517a:	09 f0       	breq	.+2      	; 0x517e <TCPProcess+0xb2a>
    517c:	c0 c0       	rjmp	.+384    	; 0x52fe <TCPProcess+0xcaa>
				//Chuyen sang trang thai FIN WAIT2
				tcpSessionTable[i].sesState = TCP_STATE_FIN_WAIT2;
    517e:	8f e1       	ldi	r24, 0x1F	; 31
    5180:	90 e0       	ldi	r25, 0x00	; 0
    5182:	c8 9e       	mul	r12, r24
    5184:	f0 01       	movw	r30, r0
    5186:	c9 9e       	mul	r12, r25
    5188:	f0 0d       	add	r31, r0
    518a:	d8 9e       	mul	r13, r24
    518c:	f0 0d       	add	r31, r0
    518e:	11 24       	eor	r1, r1
    5190:	e5 51       	subi	r30, 0x15	; 21
    5192:	fa 4f       	sbci	r31, 0xFA	; 250
    5194:	86 e0       	ldi	r24, 0x06	; 6
    5196:	80 8b       	std	Z+16, r24	; 0x10
    5198:	cd c0       	rjmp	.+410    	; 0x5334 <TCPProcess+0xce0>
			break;
		//Neu dang o trang thai FIN WAIT 2 (san sang dong ket noi va gui co FIN,
		//  phia ben kia da xac nhan nhung van chua san sang dong ket noi
		case(TCP_STATE_FIN_WAIT2):
			//Neu nhan duoc co FIN
			if (tcpHeader->Flags & TCP_FIN_FLAG){
    519a:	50 ff       	sbrs	r21, 0
    519c:	b0 c0       	rjmp	.+352    	; 0x52fe <TCPProcess+0xcaa>
				if(dataLen){
    519e:	61 15       	cp	r22, r1
    51a0:	71 05       	cpc	r23, r1
    51a2:	09 f4       	brne	.+2      	; 0x51a6 <TCPProcess+0xb52>
    51a4:	3f c0       	rjmp	.+126    	; 0x5224 <TCPProcess+0xbd0>
					tcpSessionTable[i].ackNumber = HTONL((tcpHeader->seqNumber))+dataLen;
    51a6:	8c 81       	ldd	r24, Y+4	; 0x04
    51a8:	9d 81       	ldd	r25, Y+5	; 0x05
    51aa:	ae 81       	ldd	r26, Y+6	; 0x06
    51ac:	bf 81       	ldd	r27, Y+7	; 0x07
    51ae:	2f e1       	ldi	r18, 0x1F	; 31
    51b0:	30 e0       	ldi	r19, 0x00	; 0
    51b2:	c2 9e       	mul	r12, r18
    51b4:	f0 01       	movw	r30, r0
    51b6:	c3 9e       	mul	r12, r19
    51b8:	f0 0d       	add	r31, r0
    51ba:	d2 9e       	mul	r13, r18
    51bc:	f0 0d       	add	r31, r0
    51be:	11 24       	eor	r1, r1
    51c0:	e5 51       	subi	r30, 0x15	; 21
    51c2:	fa 4f       	sbci	r31, 0xFA	; 250
    51c4:	1b 01       	movw	r2, r22
    51c6:	44 24       	eor	r4, r4
    51c8:	55 24       	eor	r5, r5
    51ca:	6b 2e       	mov	r6, r27
    51cc:	77 24       	eor	r7, r7
    51ce:	88 24       	eor	r8, r8
    51d0:	99 24       	eor	r9, r9
    51d2:	58 2f       	mov	r21, r24
    51d4:	44 27       	eor	r20, r20
    51d6:	33 27       	eor	r19, r19
    51d8:	22 27       	eor	r18, r18
    51da:	62 2a       	or	r6, r18
    51dc:	73 2a       	or	r7, r19
    51de:	84 2a       	or	r8, r20
    51e0:	95 2a       	or	r9, r21
    51e2:	9c 01       	movw	r18, r24
    51e4:	ad 01       	movw	r20, r26
    51e6:	20 70       	andi	r18, 0x00	; 0
    51e8:	30 70       	andi	r19, 0x00	; 0
    51ea:	50 70       	andi	r21, 0x00	; 0
    51ec:	23 2f       	mov	r18, r19
    51ee:	34 2f       	mov	r19, r20
    51f0:	45 2f       	mov	r20, r21
    51f2:	55 27       	eor	r21, r21
    51f4:	26 29       	or	r18, r6
    51f6:	37 29       	or	r19, r7
    51f8:	48 29       	or	r20, r8
    51fa:	59 29       	or	r21, r9
    51fc:	80 70       	andi	r24, 0x00	; 0
    51fe:	a0 70       	andi	r26, 0x00	; 0
    5200:	b0 70       	andi	r27, 0x00	; 0
    5202:	ba 2f       	mov	r27, r26
    5204:	a9 2f       	mov	r26, r25
    5206:	98 2f       	mov	r25, r24
    5208:	88 27       	eor	r24, r24
    520a:	82 2b       	or	r24, r18
    520c:	93 2b       	or	r25, r19
    520e:	a4 2b       	or	r26, r20
    5210:	b5 2b       	or	r27, r21
    5212:	82 0d       	add	r24, r2
    5214:	93 1d       	adc	r25, r3
    5216:	a4 1d       	adc	r26, r4
    5218:	b5 1d       	adc	r27, r5
    521a:	84 87       	std	Z+12, r24	; 0x0c
    521c:	95 87       	std	Z+13, r25	; 0x0d
    521e:	a6 87       	std	Z+14, r26	; 0x0e
    5220:	b7 87       	std	Z+15, r27	; 0x0f
    5222:	3a c0       	rjmp	.+116    	; 0x5298 <TCPProcess+0xc44>
				}else{
					tcpSessionTable[i].ackNumber = HTONL((tcpHeader->seqNumber))+1;
    5224:	8c 81       	ldd	r24, Y+4	; 0x04
    5226:	9d 81       	ldd	r25, Y+5	; 0x05
    5228:	ae 81       	ldd	r26, Y+6	; 0x06
    522a:	bf 81       	ldd	r27, Y+7	; 0x07
    522c:	2f e1       	ldi	r18, 0x1F	; 31
    522e:	30 e0       	ldi	r19, 0x00	; 0
    5230:	c2 9e       	mul	r12, r18
    5232:	f0 01       	movw	r30, r0
    5234:	c3 9e       	mul	r12, r19
    5236:	f0 0d       	add	r31, r0
    5238:	d2 9e       	mul	r13, r18
    523a:	f0 0d       	add	r31, r0
    523c:	11 24       	eor	r1, r1
    523e:	e5 51       	subi	r30, 0x15	; 21
    5240:	fa 4f       	sbci	r31, 0xFA	; 250
    5242:	6b 2e       	mov	r6, r27
    5244:	77 24       	eor	r7, r7
    5246:	88 24       	eor	r8, r8
    5248:	99 24       	eor	r9, r9
    524a:	58 2f       	mov	r21, r24
    524c:	44 27       	eor	r20, r20
    524e:	33 27       	eor	r19, r19
    5250:	22 27       	eor	r18, r18
    5252:	62 2a       	or	r6, r18
    5254:	73 2a       	or	r7, r19
    5256:	84 2a       	or	r8, r20
    5258:	95 2a       	or	r9, r21
    525a:	9c 01       	movw	r18, r24
    525c:	ad 01       	movw	r20, r26
    525e:	20 70       	andi	r18, 0x00	; 0
    5260:	30 70       	andi	r19, 0x00	; 0
    5262:	50 70       	andi	r21, 0x00	; 0
    5264:	23 2f       	mov	r18, r19
    5266:	34 2f       	mov	r19, r20
    5268:	45 2f       	mov	r20, r21
    526a:	55 27       	eor	r21, r21
    526c:	26 29       	or	r18, r6
    526e:	37 29       	or	r19, r7
    5270:	48 29       	or	r20, r8
    5272:	59 29       	or	r21, r9
    5274:	80 70       	andi	r24, 0x00	; 0
    5276:	a0 70       	andi	r26, 0x00	; 0
    5278:	b0 70       	andi	r27, 0x00	; 0
    527a:	ba 2f       	mov	r27, r26
    527c:	a9 2f       	mov	r26, r25
    527e:	98 2f       	mov	r25, r24
    5280:	88 27       	eor	r24, r24
    5282:	82 2b       	or	r24, r18
    5284:	93 2b       	or	r25, r19
    5286:	a4 2b       	or	r26, r20
    5288:	b5 2b       	or	r27, r21
    528a:	01 96       	adiw	r24, 0x01	; 1
    528c:	a1 1d       	adc	r26, r1
    528e:	b1 1d       	adc	r27, r1
    5290:	84 87       	std	Z+12, r24	; 0x0c
    5292:	95 87       	std	Z+13, r25	; 0x0d
    5294:	a6 87       	std	Z+14, r26	; 0x0e
    5296:	b7 87       	std	Z+15, r27	; 0x0f
				}
				//FIN -> goto TIMED WAIT
				tcpSessionTable[i].sesState = TCP_STATE_TIMED_WAIT;
    5298:	2f e1       	ldi	r18, 0x1F	; 31
    529a:	30 e0       	ldi	r19, 0x00	; 0
    529c:	c2 9e       	mul	r12, r18
    529e:	f0 01       	movw	r30, r0
    52a0:	c3 9e       	mul	r12, r19
    52a2:	f0 0d       	add	r31, r0
    52a4:	d2 9e       	mul	r13, r18
    52a6:	f0 0d       	add	r31, r0
    52a8:	11 24       	eor	r1, r1
    52aa:	e5 51       	subi	r30, 0x15	; 21
    52ac:	fa 4f       	sbci	r31, 0xFA	; 250
    52ae:	88 e0       	ldi	r24, 0x08	; 8
    52b0:	80 8b       	std	Z+16, r24	; 0x10
				TCPPackedSend(&tcpSessionTable[i], (TCP_ACK_FLAG), 0, tcpData);
    52b2:	41 2f       	mov	r20, r17
    52b4:	50 e0       	ldi	r21, 0x00	; 0
    52b6:	42 9f       	mul	r20, r18
    52b8:	c0 01       	movw	r24, r0
    52ba:	43 9f       	mul	r20, r19
    52bc:	90 0d       	add	r25, r0
    52be:	52 9f       	mul	r21, r18
    52c0:	90 0d       	add	r25, r0
    52c2:	11 24       	eor	r1, r1
    52c4:	85 51       	subi	r24, 0x15	; 21
    52c6:	9a 4f       	sbci	r25, 0xFA	; 250
    52c8:	60 e1       	ldi	r22, 0x10	; 16
    52ca:	40 e0       	ldi	r20, 0x00	; 0
    52cc:	50 e0       	ldi	r21, 0x00	; 0
    52ce:	95 01       	movw	r18, r10
    52d0:	0e 94 82 21 	call	0x4304	; 0x4304 <TCPPackedSend>
				//Chua co timer thi dong ket noi o day luon
				TCPCloseSession(i);
    52d4:	81 2f       	mov	r24, r17
    52d6:	0e 94 aa 20 	call	0x4154	; 0x4154 <TCPCloseSession>
    52da:	11 c0       	rjmp	.+34     	; 0x52fe <TCPProcess+0xcaa>
			}
			break;
		case(TCP_STATE_TIMED_WAIT):
			break;
		case(TCP_STATE_CLOSING):
			tcpSessionTable[i].sesState = TCP_STATE_TIMED_WAIT;
    52dc:	8f e1       	ldi	r24, 0x1F	; 31
    52de:	90 e0       	ldi	r25, 0x00	; 0
    52e0:	c8 9e       	mul	r12, r24
    52e2:	f0 01       	movw	r30, r0
    52e4:	c9 9e       	mul	r12, r25
    52e6:	f0 0d       	add	r31, r0
    52e8:	d8 9e       	mul	r13, r24
    52ea:	f0 0d       	add	r31, r0
    52ec:	11 24       	eor	r1, r1
    52ee:	e5 51       	subi	r30, 0x15	; 21
    52f0:	fa 4f       	sbci	r31, 0xFA	; 250
    52f2:	88 e0       	ldi	r24, 0x08	; 8
    52f4:	80 8b       	std	Z+16, r24	; 0x10
    52f6:	11 c0       	rjmp	.+34     	; 0x531a <TCPProcess+0xcc6>
			break;
		default:
			TCPCloseSession(i);
    52f8:	81 2f       	mov	r24, r17
    52fa:	0e 94 aa 20 	call	0x4154	; 0x4154 <TCPCloseSession>
	}
	//we must set timed wait TTL here because timed wait is not packet triggered
	if (tcpSessionTable[i].sesState == TCP_STATE_TIMED_WAIT){
    52fe:	8f e1       	ldi	r24, 0x1F	; 31
    5300:	90 e0       	ldi	r25, 0x00	; 0
    5302:	c8 9e       	mul	r12, r24
    5304:	f0 01       	movw	r30, r0
    5306:	c9 9e       	mul	r12, r25
    5308:	f0 0d       	add	r31, r0
    530a:	d8 9e       	mul	r13, r24
    530c:	f0 0d       	add	r31, r0
    530e:	11 24       	eor	r1, r1
    5310:	e5 51       	subi	r30, 0x15	; 21
    5312:	fa 4f       	sbci	r31, 0xFA	; 250
    5314:	80 89       	ldd	r24, Z+16	; 0x10
    5316:	88 30       	cpi	r24, 0x08	; 8
    5318:	69 f4       	brne	.+26     	; 0x5334 <TCPProcess+0xce0>
		tcpSessionTable[i].timeOut = 5; //5 seconds timeout
    531a:	8f e1       	ldi	r24, 0x1F	; 31
    531c:	90 e0       	ldi	r25, 0x00	; 0
    531e:	c8 9e       	mul	r12, r24
    5320:	f0 01       	movw	r30, r0
    5322:	c9 9e       	mul	r12, r25
    5324:	f0 0d       	add	r31, r0
    5326:	d8 9e       	mul	r13, r24
    5328:	f0 0d       	add	r31, r0
    532a:	11 24       	eor	r1, r1
    532c:	e5 51       	subi	r30, 0x15	; 21
    532e:	fa 4f       	sbci	r31, 0xFA	; 250
    5330:	85 e0       	ldi	r24, 0x05	; 5
    5332:	82 8f       	std	Z+26, r24	; 0x1a
	}
	return;
}
    5334:	df 91       	pop	r29
    5336:	cf 91       	pop	r28
    5338:	1f 91       	pop	r17
    533a:	0f 91       	pop	r16
    533c:	ff 90       	pop	r15
    533e:	ef 90       	pop	r14
    5340:	df 90       	pop	r13
    5342:	cf 90       	pop	r12
    5344:	bf 90       	pop	r11
    5346:	af 90       	pop	r10
    5348:	9f 90       	pop	r9
    534a:	8f 90       	pop	r8
    534c:	7f 90       	pop	r7
    534e:	6f 90       	pop	r6
    5350:	5f 90       	pop	r5
    5352:	4f 90       	pop	r4
    5354:	3f 90       	pop	r3
    5356:	2f 90       	pop	r2
    5358:	08 95       	ret

0000535a <timer1Init>:
//----------------------------------------------------------------------------
void timer1Init(void)
{
	// initialize timer 1
	// set prescaler on timer 1
	TCCR1B = (TCCR1B & ~TIMER_PRESCALE_MASK) | TIMER1PRESCALE;	// set prescaler
    535a:	8e b5       	in	r24, 0x2e	; 46
    535c:	88 7f       	andi	r24, 0xF8	; 248
    535e:	85 60       	ori	r24, 0x05	; 5
    5360:	8e bd       	out	0x2e, r24	; 46
	TCNT1H = 0;						// reset TCNT1
    5362:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0;
    5364:	1c bc       	out	0x2c, r1	; 44
	TIMSK |= (1<<TOIE1);						// enable TCNT1 overflow
    5366:	89 b7       	in	r24, 0x39	; 57
    5368:	84 60       	ori	r24, 0x04	; 4
    536a:	89 bf       	out	0x39, r24	; 57
	TCNT1 = 0xFFFF - TIMER1_INTERVAL;
    536c:	8b e7       	ldi	r24, 0x7B	; 123
    536e:	91 ee       	ldi	r25, 0xE1	; 225
    5370:	9d bd       	out	0x2d, r25	; 45
    5372:	8c bd       	out	0x2c, r24	; 44
	sei();
    5374:	78 94       	sei
}
    5376:	08 95       	ret

00005378 <__vector_9>:
//! Interrupt handler for tcnt1 overflow interrupt
TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW1)
{
    5378:	1f 92       	push	r1
    537a:	0f 92       	push	r0
    537c:	0f b6       	in	r0, 0x3f	; 63
    537e:	0f 92       	push	r0
    5380:	11 24       	eor	r1, r1
    5382:	2f 93       	push	r18
    5384:	3f 93       	push	r19
    5386:	4f 93       	push	r20
    5388:	5f 93       	push	r21
    538a:	6f 93       	push	r22
    538c:	7f 93       	push	r23
    538e:	8f 93       	push	r24
    5390:	9f 93       	push	r25
    5392:	af 93       	push	r26
    5394:	bf 93       	push	r27
    5396:	ef 93       	push	r30
    5398:	ff 93       	push	r31
	//Tai nap gia tri timer 1
	TCNT1 = 0xFFFF - TIMER1_INTERVAL;
    539a:	8b e7       	ldi	r24, 0x7B	; 123
    539c:	91 ee       	ldi	r25, 0xE1	; 225
    539e:	9d bd       	out	0x2d, r25	; 45
    53a0:	8c bd       	out	0x2c, r24	; 44
	//Cap nhat watchdog timer
	if((time_watchdog++) > 120){
    53a2:	80 91 fd 00 	lds	r24, 0x00FD
    53a6:	90 91 fe 00 	lds	r25, 0x00FE
    53aa:	9c 01       	movw	r18, r24
    53ac:	2f 5f       	subi	r18, 0xFF	; 255
    53ae:	3f 4f       	sbci	r19, 0xFF	; 255
    53b0:	30 93 fe 00 	sts	0x00FE, r19
    53b4:	20 93 fd 00 	sts	0x00FD, r18
    53b8:	89 37       	cpi	r24, 0x79	; 121
    53ba:	91 05       	cpc	r25, r1
    53bc:	30 f0       	brcs	.+12     	; 0x53ca <__vector_9+0x52>
        time_watchdog = 0;
    53be:	10 92 fe 00 	sts	0x00FE, r1
    53c2:	10 92 fd 00 	sts	0x00FD, r1
        ethInit();
    53c6:	0e 94 e6 14 	call	0x29cc	; 0x29cc <ethInit>
	}
	Counter1s++;
    53ca:	80 91 81 00 	lds	r24, 0x0081
    53ce:	90 91 82 00 	lds	r25, 0x0082
    53d2:	01 96       	adiw	r24, 0x01	; 1
    53d4:	90 93 82 00 	sts	0x0082, r25
    53d8:	80 93 81 00 	sts	0x0081, r24
	arpTimer();
    53dc:	0e 94 a5 0c 	call	0x194a	; 0x194a <arpTimer>
	TCPCheckTimeOut();////
    53e0:	0e 94 11 21 	call	0x4222	; 0x4222 <TCPCheckTimeOut>
	dhcpTimer();///
    53e4:	0e 94 01 13 	call	0x2602	; 0x2602 <dhcpTimer>
	test_showip++;
    53e8:	80 91 e3 06 	lds	r24, 0x06E3
    53ec:	8f 5f       	subi	r24, 0xFF	; 255
    53ee:	80 93 e3 06 	sts	0x06E3, r24
	if(test_showip>=5) showip();
    53f2:	85 30       	cpi	r24, 0x05	; 5
    53f4:	10 f0       	brcs	.+4      	; 0x53fa <__vector_9+0x82>
    53f6:	0e 94 66 1f 	call	0x3ecc	; 0x3ecc <showip>
}
    53fa:	ff 91       	pop	r31
    53fc:	ef 91       	pop	r30
    53fe:	bf 91       	pop	r27
    5400:	af 91       	pop	r26
    5402:	9f 91       	pop	r25
    5404:	8f 91       	pop	r24
    5406:	7f 91       	pop	r23
    5408:	6f 91       	pop	r22
    540a:	5f 91       	pop	r21
    540c:	4f 91       	pop	r20
    540e:	3f 91       	pop	r19
    5410:	2f 91       	pop	r18
    5412:	0f 90       	pop	r0
    5414:	0f be       	out	0x3f, r0	; 63
    5416:	0f 90       	pop	r0
    5418:	1f 90       	pop	r1
    541a:	18 95       	reti

0000541c <uartInit>:
volatile unsigned char UartRxBufferStart;
volatile unsigned char UartRxBufferLen;
static char HexTable[] PROGMEM= "0123456789ABCDEF";
//----------------------------------------------------------------------------
void uartInit(unsigned long baudrate)
{
    541c:	9b 01       	movw	r18, r22
    541e:	ac 01       	movw	r20, r24
	unsigned int bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);//
    5420:	60 5c       	subi	r22, 0xC0	; 192
    5422:	7d 4b       	sbci	r23, 0xBD	; 189
    5424:	80 4f       	sbci	r24, 0xF0	; 240
    5426:	9f 4f       	sbci	r25, 0xFF	; 255
    5428:	66 0f       	add	r22, r22
    542a:	77 1f       	adc	r23, r23
    542c:	88 1f       	adc	r24, r24
    542e:	99 1f       	adc	r25, r25
    5430:	66 0f       	add	r22, r22
    5432:	77 1f       	adc	r23, r23
    5434:	88 1f       	adc	r24, r24
    5436:	99 1f       	adc	r25, r25
    5438:	66 0f       	add	r22, r22
    543a:	77 1f       	adc	r23, r23
    543c:	88 1f       	adc	r24, r24
    543e:	99 1f       	adc	r25, r25
    5440:	22 0f       	add	r18, r18
    5442:	33 1f       	adc	r19, r19
    5444:	44 1f       	adc	r20, r20
    5446:	55 1f       	adc	r21, r21
    5448:	22 0f       	add	r18, r18
    544a:	33 1f       	adc	r19, r19
    544c:	44 1f       	adc	r20, r20
    544e:	55 1f       	adc	r21, r21
    5450:	22 0f       	add	r18, r18
    5452:	33 1f       	adc	r19, r19
    5454:	44 1f       	adc	r20, r20
    5456:	55 1f       	adc	r21, r21
    5458:	22 0f       	add	r18, r18
    545a:	33 1f       	adc	r19, r19
    545c:	44 1f       	adc	r20, r20
    545e:	55 1f       	adc	r21, r21
    5460:	0e 94 a0 2c 	call	0x5940	; 0x5940 <__udivmodsi4>
    5464:	21 50       	subi	r18, 0x01	; 1
    5466:	30 40       	sbci	r19, 0x00	; 0
	UBRRL = bauddiv;
    5468:	29 b9       	out	0x09, r18	; 9
	#ifdef UBRRH
	UBRRH = ((bauddiv>>8) & 0x0F);
    546a:	83 2f       	mov	r24, r19
    546c:	8f 70       	andi	r24, 0x0F	; 15
    546e:	80 bd       	out	0x20, r24	; 32
	// UPM0    4	
	// USBS    3	Stop bit: 0:1 bit/1:2 bit
	// UCSZ1   2	Char size:000:5/001:6/010:7/011:8/111:9/others:reserverd
	// UCSZ0   1
	// UCPOL   0
	UCSRC = 0x80 | (1<<UCSZ1) | (1<<UCSZ0);
    5470:	86 e8       	ldi	r24, 0x86	; 134
    5472:	80 bd       	out	0x20, r24	; 32
	#endif
	UCR =((1 << TXEN) | (1 << RXEN) | (1<< RXCIE) | (1<< TXCIE));// 
    5474:	88 ed       	ldi	r24, 0xD8	; 216
    5476:	8a b9       	out	0x0a, r24	; 10
	UartTxBufferStart = 0;
    5478:	10 92 f5 06 	sts	0x06F5, r1
	UartTxBufferLen = 0;
    547c:	10 92 f6 06 	sts	0x06F6, r1
	UartRxBufferStart = 0;
    5480:	10 92 f4 06 	sts	0x06F4, r1
	UartRxBufferLen = 0;
    5484:	10 92 f7 06 	sts	0x06F7, r1
	sei();
    5488:	78 94       	sei
}
    548a:	08 95       	ret

0000548c <__vector_15>:
//--------------------------------------------------------------------------------------
SIGNAL(SIG_UART_TRANS)
{
    548c:	1f 92       	push	r1
    548e:	0f 92       	push	r0
    5490:	0f b6       	in	r0, 0x3f	; 63
    5492:	0f 92       	push	r0
    5494:	11 24       	eor	r1, r1
    5496:	8f 93       	push	r24
    5498:	9f 93       	push	r25
    549a:	ef 93       	push	r30
    549c:	ff 93       	push	r31
	if(UartTxBufferLen){
    549e:	80 91 f6 06 	lds	r24, 0x06F6
    54a2:	88 23       	and	r24, r24
    54a4:	b1 f0       	breq	.+44     	; 0x54d2 <__vector_15+0x46>
		--UartTxBufferLen;
    54a6:	80 91 f6 06 	lds	r24, 0x06F6
    54aa:	81 50       	subi	r24, 0x01	; 1
    54ac:	80 93 f6 06 	sts	0x06F6, r24
		UDR = UartTxBuffer[UartTxBufferStart++];
    54b0:	80 91 f5 06 	lds	r24, 0x06F5
    54b4:	ec ee       	ldi	r30, 0xEC	; 236
    54b6:	f6 e0       	ldi	r31, 0x06	; 6
    54b8:	e8 0f       	add	r30, r24
    54ba:	f1 1d       	adc	r31, r1
    54bc:	90 81       	ld	r25, Z
    54be:	9c b9       	out	0x0c, r25	; 12
    54c0:	8f 5f       	subi	r24, 0xFF	; 255
    54c2:	80 93 f5 06 	sts	0x06F5, r24
		if (UartTxBufferStart == UART_TX_BUFFER_SIZE)
    54c6:	80 91 f5 06 	lds	r24, 0x06F5
    54ca:	88 30       	cpi	r24, 0x08	; 8
    54cc:	11 f4       	brne	.+4      	; 0x54d2 <__vector_15+0x46>
   			UartTxBufferStart = 0;
    54ce:	10 92 f5 06 	sts	0x06F5, r1
	}
}
    54d2:	ff 91       	pop	r31
    54d4:	ef 91       	pop	r30
    54d6:	9f 91       	pop	r25
    54d8:	8f 91       	pop	r24
    54da:	0f 90       	pop	r0
    54dc:	0f be       	out	0x3f, r0	; 63
    54de:	0f 90       	pop	r0
    54e0:	1f 90       	pop	r1
    54e2:	18 95       	reti

000054e4 <__vector_13>:
//--------------------------------------------------------------------------------------
SIGNAL(SIG_UART_RECV)
{
    54e4:	1f 92       	push	r1
    54e6:	0f 92       	push	r0
    54e8:	0f b6       	in	r0, 0x3f	; 63
    54ea:	0f 92       	push	r0
    54ec:	11 24       	eor	r1, r1
    54ee:	8f 93       	push	r24
    54f0:	9f 93       	push	r25
    54f2:	ef 93       	push	r30
    54f4:	ff 93       	push	r31
	unsigned char i;
	char status,data;
	status = USR;
    54f6:	8b b1       	in	r24, 0x0b	; 11
	data = UDR;
    54f8:	9c b1       	in	r25, 0x0c	; 12
	if ((status & ((1<<FE) | (1<<PE) | (1<<DOR))) == 0){
    54fa:	8c 71       	andi	r24, 0x1C	; 28
    54fc:	b9 f4       	brne	.+46     	; 0x552c <__vector_13+0x48>
		if(++UartRxBufferLen == UART_RX_BUFFER_SIZE)
    54fe:	80 91 f7 06 	lds	r24, 0x06F7
    5502:	8f 5f       	subi	r24, 0xFF	; 255
    5504:	80 93 f7 06 	sts	0x06F7, r24
    5508:	80 91 f7 06 	lds	r24, 0x06F7
    550c:	88 30       	cpi	r24, 0x08	; 8
    550e:	11 f4       	brne	.+4      	; 0x5514 <__vector_13+0x30>
			UartRxBufferLen = UART_RX_BUFFER_SIZE;
    5510:	80 93 f7 06 	sts	0x06F7, r24
		i = UartRxBufferStart+UartRxBufferLen;	//Vi tri ky tu cuoi cung trong buffer
    5514:	80 91 f4 06 	lds	r24, 0x06F4
    5518:	e0 91 f7 06 	lds	r30, 0x06F7
    551c:	e8 0f       	add	r30, r24
		if(i > UART_RX_BUFFER_SIZE)
    551e:	e9 30       	cpi	r30, 0x09	; 9
    5520:	08 f0       	brcs	.+2      	; 0x5524 <__vector_13+0x40>
			i -= UART_RX_BUFFER_SIZE;
    5522:	e8 50       	subi	r30, 0x08	; 8
		UartRxBuffer[i-1] = data;
    5524:	f0 e0       	ldi	r31, 0x00	; 0
    5526:	ed 51       	subi	r30, 0x1D	; 29
    5528:	f9 4f       	sbci	r31, 0xF9	; 249
    552a:	90 83       	st	Z, r25
	}
}
    552c:	ff 91       	pop	r31
    552e:	ef 91       	pop	r30
    5530:	9f 91       	pop	r25
    5532:	8f 91       	pop	r24
    5534:	0f 90       	pop	r0
    5536:	0f be       	out	0x3f, r0	; 63
    5538:	0f 90       	pop	r0
    553a:	1f 90       	pop	r1
    553c:	18 95       	reti

0000553e <uartGetByte>:
//--------------------------------------------------------------------------------------
char uartGetByte(void)
{
	//
	char c;
	if(UartRxBufferLen){
    553e:	80 91 f7 06 	lds	r24, 0x06F7
    5542:	88 23       	and	r24, r24
    5544:	b1 f0       	breq	.+44     	; 0x5572 <uartGetByte+0x34>
		UartRxBufferLen--;
    5546:	80 91 f7 06 	lds	r24, 0x06F7
    554a:	81 50       	subi	r24, 0x01	; 1
    554c:	80 93 f7 06 	sts	0x06F7, r24
		c = UartRxBuffer[UartRxBufferStart++];
    5550:	90 91 f4 06 	lds	r25, 0x06F4
    5554:	e4 ee       	ldi	r30, 0xE4	; 228
    5556:	f6 e0       	ldi	r31, 0x06	; 6
    5558:	e9 0f       	add	r30, r25
    555a:	f1 1d       	adc	r31, r1
    555c:	80 81       	ld	r24, Z
    555e:	9f 5f       	subi	r25, 0xFF	; 255
    5560:	90 93 f4 06 	sts	0x06F4, r25
		if(UartRxBufferStart == UART_RX_BUFFER_SIZE)
    5564:	90 91 f4 06 	lds	r25, 0x06F4
    5568:	98 30       	cpi	r25, 0x08	; 8
    556a:	21 f4       	brne	.+8      	; 0x5574 <uartGetByte+0x36>
			UartRxBufferStart = 0;
    556c:	10 92 f4 06 	sts	0x06F4, r1
    5570:	08 95       	ret
		return(c);
	}
	return(-1);
    5572:	8f ef       	ldi	r24, 0xFF	; 255
}
    5574:	08 95       	ret

00005576 <uartSendByte>:
//--------------------------------------------------------------------------------------
void uartSendByte(char c)
{
	unsigned char i;
	if((USR & (1<<UDRE)) && (UartTxBufferLen == 0)){	//Neu uart dang san sang va buffer trong
    5576:	5d 9b       	sbis	0x0b, 5	; 11
    5578:	06 c0       	rjmp	.+12     	; 0x5586 <uartSendByte+0x10>
    557a:	90 91 f6 06 	lds	r25, 0x06F6
    557e:	99 23       	and	r25, r25
    5580:	11 f4       	brne	.+4      	; 0x5586 <uartSendByte+0x10>
		UDR = c;			//Gui luon
    5582:	8c b9       	out	0x0c, r24	; 12
    5584:	08 95       	ret
	}else{
		//Neu uart dang ban
		while(UartTxBufferLen == UART_TX_BUFFER_SIZE);	//Cho neu buffer dang day
    5586:	90 91 f6 06 	lds	r25, 0x06F6
    558a:	98 30       	cpi	r25, 0x08	; 8
    558c:	e1 f3       	breq	.-8      	; 0x5586 <uartSendByte+0x10>
		i = UartTxBufferStart + UartTxBufferLen;
    558e:	90 91 f5 06 	lds	r25, 0x06F5
    5592:	20 91 f6 06 	lds	r18, 0x06F6
    5596:	92 0f       	add	r25, r18
		UartTxBufferLen++;
    5598:	20 91 f6 06 	lds	r18, 0x06F6
    559c:	2f 5f       	subi	r18, 0xFF	; 255
    559e:	20 93 f6 06 	sts	0x06F6, r18
		if(i >= UART_TX_BUFFER_SIZE)
    55a2:	98 30       	cpi	r25, 0x08	; 8
    55a4:	08 f0       	brcs	.+2      	; 0x55a8 <uartSendByte+0x32>
			i -=UART_TX_BUFFER_SIZE;
    55a6:	98 50       	subi	r25, 0x08	; 8
		UartTxBuffer[i] = c;	//Ghi vao cuoi buffer
    55a8:	ec ee       	ldi	r30, 0xEC	; 236
    55aa:	f6 e0       	ldi	r31, 0x06	; 6
    55ac:	e9 0f       	add	r30, r25
    55ae:	f1 1d       	adc	r31, r1
    55b0:	80 83       	st	Z, r24
    55b2:	08 95       	ret

000055b4 <printfP>:
	}
}
//--------------------------------------------------------------------------------------
int printfP(const prog_char *format, ...)
{
    55b4:	2f 92       	push	r2
    55b6:	3f 92       	push	r3
    55b8:	4f 92       	push	r4
    55ba:	5f 92       	push	r5
    55bc:	6f 92       	push	r6
    55be:	7f 92       	push	r7
    55c0:	9f 92       	push	r9
    55c2:	af 92       	push	r10
    55c4:	bf 92       	push	r11
    55c6:	cf 92       	push	r12
    55c8:	df 92       	push	r13
    55ca:	ef 92       	push	r14
    55cc:	ff 92       	push	r15
    55ce:	0f 93       	push	r16
    55d0:	1f 93       	push	r17
    55d2:	df 93       	push	r29
    55d4:	cf 93       	push	r28
    55d6:	cd b7       	in	r28, 0x3d	; 61
    55d8:	de b7       	in	r29, 0x3e	; 62
    55da:	0f 2e       	mov	r0, r31
    55dc:	f4 e1       	ldi	r31, 0x14	; 20
    55de:	6f 2e       	mov	r6, r31
    55e0:	77 24       	eor	r7, r7
    55e2:	f0 2d       	mov	r31, r0
    55e4:	6c 0e       	add	r6, r28
    55e6:	7d 1e       	adc	r7, r29
    55e8:	f3 01       	movw	r30, r6
    55ea:	e1 90       	ld	r14, Z+
    55ec:	f1 90       	ld	r15, Z+
    55ee:	3f 01       	movw	r6, r30

		switch (c = pgm_read_byte(format++) )
		{
			case 'c': c = va_arg(ap,int);
			default:  uartSendByte(c); continue;
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
    55f0:	0f 2e       	mov	r0, r31
    55f2:	fa e0       	ldi	r31, 0x0A	; 10
    55f4:	4f 2e       	mov	r4, r31
    55f6:	55 24       	eor	r5, r5
    55f8:	f0 2d       	mov	r31, r0
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;
    55fa:	22 24       	eor	r2, r2
    55fc:	33 24       	eor	r3, r3
    55fe:	68 94       	set
    5600:	24 f8       	bld	r2, 4
    5602:	18 c0       	rjmp	.+48     	; 0x5634 <printfP+0x80>
	va_start(ap, format);
	for (;;)
	{
		while ((c = pgm_read_byte(format++) ) != '%')
		{	// Until '%' or '\0'
			if (!c)
    5604:	88 23       	and	r24, r24
    5606:	a1 f4       	brne	.+40     	; 0x5630 <printfP+0x7c>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    5608:	80 e0       	ldi	r24, 0x00	; 0
    560a:	90 e0       	ldi	r25, 0x00	; 0
    560c:	cf 91       	pop	r28
    560e:	df 91       	pop	r29
    5610:	1f 91       	pop	r17
    5612:	0f 91       	pop	r16
    5614:	ff 90       	pop	r15
    5616:	ef 90       	pop	r14
    5618:	df 90       	pop	r13
    561a:	cf 90       	pop	r12
    561c:	bf 90       	pop	r11
    561e:	af 90       	pop	r10
    5620:	9f 90       	pop	r9
    5622:	7f 90       	pop	r7
    5624:	6f 90       	pop	r6
    5626:	5f 90       	pop	r5
    5628:	4f 90       	pop	r4
    562a:	3f 90       	pop	r3
    562c:	2f 90       	pop	r2
    562e:	08 95       	ret
			if (!c)
			{
				va_end(ap);
				return(0);
			}
			uartSendByte(c);
    5630:	0e 94 bb 2a 	call	0x5576	; 0x5576 <uartSendByte>
	unsigned int u_val, div_val, base;
	va_list ap;
	va_start(ap, format);
	for (;;)
	{
		while ((c = pgm_read_byte(format++) ) != '%')
    5634:	f7 01       	movw	r30, r14
    5636:	08 94       	sec
    5638:	e1 1c       	adc	r14, r1
    563a:	f1 1c       	adc	r15, r1
    563c:	84 91       	lpm	r24, Z+
    563e:	85 32       	cpi	r24, 0x25	; 37
    5640:	09 f7       	brne	.-62     	; 0x5604 <printfP+0x50>
				return(0);
			}
			uartSendByte(c);
		}

		switch (c = pgm_read_byte(format++) )
    5642:	f7 01       	movw	r30, r14
    5644:	08 94       	sec
    5646:	e1 1c       	adc	r14, r1
    5648:	f1 1c       	adc	r15, r1
    564a:	e4 91       	lpm	r30, Z+
    564c:	e4 36       	cpi	r30, 0x64	; 100
    564e:	81 f0       	breq	.+32     	; 0x5670 <printfP+0xbc>
    5650:	e8 37       	cpi	r30, 0x78	; 120
    5652:	09 f4       	brne	.+2      	; 0x5656 <printfP+0xa2>
    5654:	55 c0       	rjmp	.+170    	; 0x5700 <printfP+0x14c>
    5656:	e3 36       	cpi	r30, 0x63	; 99
    5658:	39 f4       	brne	.+14     	; 0x5668 <printfP+0xb4>
		{
			case 'c': c = va_arg(ap,int);
    565a:	f3 01       	movw	r30, r6
    565c:	82 e0       	ldi	r24, 0x02	; 2
    565e:	90 e0       	ldi	r25, 0x00	; 0
    5660:	68 0e       	add	r6, r24
    5662:	79 1e       	adc	r7, r25
    5664:	80 81       	ld	r24, Z
    5666:	01 c0       	rjmp	.+2      	; 0x566a <printfP+0xb6>
				return(0);
			}
			uartSendByte(c);
		}

		switch (c = pgm_read_byte(format++) )
    5668:	8e 2f       	mov	r24, r30
		{
			case 'c': c = va_arg(ap,int);
			default:  uartSendByte(c); continue;
    566a:	0e 94 bb 2a 	call	0x5576	; 0x5576 <uartSendByte>
    566e:	e2 cf       	rjmp	.-60     	; 0x5634 <printfP+0x80>
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    5670:	f3 01       	movw	r30, r6
    5672:	82 e0       	ldi	r24, 0x02	; 2
    5674:	90 e0       	ldi	r25, 0x00	; 0
    5676:	68 0e       	add	r6, r24
    5678:	79 1e       	adc	r7, r25
    567a:	c0 80       	ld	r12, Z
    567c:	d1 80       	ldd	r13, Z+1	; 0x01
			if (c == 'd')
			{
				if (((int)u_val) < 0)
    567e:	dd 20       	and	r13, r13
    5680:	3c f4       	brge	.+14     	; 0x5690 <printfP+0xdc>
				{
					u_val = - u_val;
    5682:	d0 94       	com	r13
    5684:	c1 94       	neg	r12
    5686:	d1 08       	sbc	r13, r1
    5688:	d3 94       	inc	r13
					uartSendByte('-');
    568a:	8d e2       	ldi	r24, 0x2D	; 45
    568c:	0e 94 bb 2a 	call	0x5576	; 0x5576 <uartSendByte>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    5690:	90 e1       	ldi	r25, 0x10	; 16
    5692:	c9 16       	cp	r12, r25
    5694:	97 e2       	ldi	r25, 0x27	; 39
    5696:	d9 06       	cpc	r13, r25
    5698:	88 f4       	brcc	.+34     	; 0x56bc <printfP+0x108>

		switch (c = pgm_read_byte(format++) )
		{
			case 'c': c = va_arg(ap,int);
			default:  uartSendByte(c); continue;
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
    569a:	00 e1       	ldi	r16, 0x10	; 16
    569c:	17 e2       	ldi	r17, 0x27	; 39
				if (((int)u_val) < 0)
				{
					u_val = - u_val;
					uartSendByte('-');
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    569e:	c8 01       	movw	r24, r16
    56a0:	b2 01       	movw	r22, r4
    56a2:	0e 94 8c 2c 	call	0x5918	; 0x5918 <__udivmodhi4>
    56a6:	8b 01       	movw	r16, r22
    56a8:	62 30       	cpi	r22, 0x02	; 2
    56aa:	71 05       	cpc	r23, r1
    56ac:	68 f0       	brcs	.+26     	; 0x56c8 <printfP+0x114>
    56ae:	c6 16       	cp	r12, r22
    56b0:	d7 06       	cpc	r13, r23
    56b2:	a8 f3       	brcs	.-22     	; 0x569e <printfP+0xea>

		switch (c = pgm_read_byte(format++) )
		{
			case 'c': c = va_arg(ap,int);
			default:  uartSendByte(c); continue;
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
    56b4:	c2 01       	movw	r24, r4
    56b6:	a4 2c       	mov	r10, r4
    56b8:	99 2e       	mov	r9, r25
    56ba:	09 c0       	rjmp	.+18     	; 0x56ce <printfP+0x11a>
    56bc:	c2 01       	movw	r24, r4
    56be:	a4 2c       	mov	r10, r4
    56c0:	99 2e       	mov	r9, r25
    56c2:	00 e1       	ldi	r16, 0x10	; 16
    56c4:	17 e2       	ldi	r17, 0x27	; 39
    56c6:	03 c0       	rjmp	.+6      	; 0x56ce <printfP+0x11a>
    56c8:	c2 01       	movw	r24, r4
    56ca:	a4 2c       	mov	r10, r4
    56cc:	99 2e       	mov	r9, r25
				while (div_val > 1 && div_val > u_val) div_val /= 10;
			}
			do
			{
				//c =pgm_read_byte(HexTable+(u_val/div_val));
				uartSendByte(pgm_read_byte(HexTable+(u_val/div_val)));
    56ce:	c6 01       	movw	r24, r12
    56d0:	b8 01       	movw	r22, r16
    56d2:	0e 94 8c 2c 	call	0x5918	; 0x5918 <__udivmodhi4>
    56d6:	d8 2e       	mov	r13, r24
    56d8:	b9 2e       	mov	r11, r25
    56da:	61 59       	subi	r22, 0x91	; 145
    56dc:	7c 4e       	sbci	r23, 0xEC	; 236
    56de:	fb 01       	movw	r30, r22
    56e0:	84 91       	lpm	r24, Z+
    56e2:	0e 94 bb 2a 	call	0x5576	; 0x5576 <uartSendByte>
				u_val %= div_val;
    56e6:	8d 2d       	mov	r24, r13
    56e8:	9b 2d       	mov	r25, r11
    56ea:	6c 01       	movw	r12, r24
				div_val /= base;
    56ec:	c8 01       	movw	r24, r16
    56ee:	6a 2d       	mov	r22, r10
    56f0:	79 2d       	mov	r23, r9
    56f2:	0e 94 8c 2c 	call	0x5918	; 0x5918 <__udivmodhi4>
    56f6:	8b 01       	movw	r16, r22
			} while (div_val);
    56f8:	61 15       	cp	r22, r1
    56fa:	71 05       	cpc	r23, r1
    56fc:	41 f7       	brne	.-48     	; 0x56ce <printfP+0x11a>
    56fe:	9a cf       	rjmp	.-204    	; 0x5634 <printfP+0x80>
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    5700:	f3 01       	movw	r30, r6
    5702:	c0 80       	ld	r12, Z
    5704:	d1 80       	ldd	r13, Z+1	; 0x01
    5706:	82 e0       	ldi	r24, 0x02	; 2
    5708:	90 e0       	ldi	r25, 0x00	; 0
    570a:	68 0e       	add	r6, r24
    570c:	79 1e       	adc	r7, r25
		{
			case 'c': c = va_arg(ap,int);
			default:  uartSendByte(c); continue;
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;
    570e:	c1 01       	movw	r24, r2
    5710:	a2 2c       	mov	r10, r2
    5712:	99 2e       	mov	r9, r25
    5714:	00 e0       	ldi	r16, 0x00	; 0
    5716:	10 e1       	ldi	r17, 0x10	; 16
    5718:	da cf       	rjmp	.-76     	; 0x56ce <printfP+0x11a>

0000571a <udpSend>:
extern struct ipConfig IpMyConfig;	///< Local IP address/config structure
//#define UDP_DEBUG
//----------------------------------------------------------------------------
//Ham gui di mot goi UDP
void udpSend(unsigned long dstIp, unsigned int dstPort, unsigned int srcPort, unsigned int len, unsigned char* udpData)
{
    571a:	6f 92       	push	r6
    571c:	7f 92       	push	r7
    571e:	8f 92       	push	r8
    5720:	9f 92       	push	r9
    5722:	af 92       	push	r10
    5724:	bf 92       	push	r11
    5726:	cf 92       	push	r12
    5728:	df 92       	push	r13
    572a:	ef 92       	push	r14
    572c:	ff 92       	push	r15
    572e:	0f 93       	push	r16
    5730:	1f 93       	push	r17
    5732:	cf 93       	push	r28
    5734:	df 93       	push	r29
    5736:	5b 01       	movw	r10, r22
    5738:	6c 01       	movw	r12, r24
	struct ntUDPHeader* udpHeader;
	udpHeader = (struct ntUDPHeader*)(udpData - UDP_HEADER_LEN);
    573a:	f7 01       	movw	r30, r14
    573c:	38 97       	sbiw	r30, 0x08	; 8
	len += UDP_HEADER_LEN;
    573e:	b8 01       	movw	r22, r16
    5740:	68 5f       	subi	r22, 0xF8	; 248
    5742:	7f 4f       	sbci	r23, 0xFF	; 255
	udpHeader->desPort = HTONS(dstPort);
    5744:	54 27       	eor	r21, r20
    5746:	45 27       	eor	r20, r21
    5748:	54 27       	eor	r21, r20
    574a:	53 83       	std	Z+3, r21	; 0x03
    574c:	42 83       	std	Z+2, r20	; 0x02
	udpHeader->srcPort  = HTONS(srcPort);
    574e:	32 27       	eor	r19, r18
    5750:	23 27       	eor	r18, r19
    5752:	32 27       	eor	r19, r18
    5754:	31 83       	std	Z+1, r19	; 0x01
    5756:	20 83       	st	Z, r18
	udpHeader->Len = HTONS(len);
    5758:	36 2f       	mov	r19, r22
    575a:	27 2f       	mov	r18, r23
    575c:	35 83       	std	Z+5, r19	; 0x05
    575e:	24 83       	std	Z+4, r18	; 0x04
	udpHeader->Checksum = 0;
    5760:	17 82       	std	Z+7, r1	; 0x07
    5762:	16 82       	std	Z+6, r1	; 0x06
	//ipSend(dstIp, IP_PROTO_UDP, len, (unsigned char*)udpHeader);
	//void ipSend(unsigned long dstIp, unsigned char protocol, unsigned int len, unsigned char* ipData)

	struct ntEthHeader* ethHeader;
	struct ntIPHeader* ipHeader;
	ipHeader = (struct ntIPHeader*)((unsigned char*)udpHeader - IP_HEADER_LEN);
    5764:	e7 01       	movw	r28, r14
    5766:	6c 97       	sbiw	r28, 0x1c	; 28
	ethHeader = (struct ntEthHeader*)((unsigned char*)udpHeader - IP_HEADER_LEN - ETH_HEADER_LEN);
    5768:	0f 2e       	mov	r0, r31
    576a:	f6 ed       	ldi	r31, 0xD6	; 214
    576c:	8f 2e       	mov	r8, r31
    576e:	ff ef       	ldi	r31, 0xFF	; 255
    5770:	9f 2e       	mov	r9, r31
    5772:	f0 2d       	mov	r31, r0
    5774:	8e 0c       	add	r8, r14
    5776:	9f 1c       	adc	r9, r15
	len += IP_HEADER_LEN;
    5778:	0f 2e       	mov	r0, r31
    577a:	fc e1       	ldi	r31, 0x1C	; 28
    577c:	6f 2e       	mov	r6, r31
    577e:	77 24       	eor	r7, r7
    5780:	f0 2d       	mov	r31, r0
    5782:	60 0e       	add	r6, r16
    5784:	71 1e       	adc	r7, r17
	ipHeader->desIPAddr = HTONL(dstIp);
    5786:	2d 2d       	mov	r18, r13
    5788:	33 27       	eor	r19, r19
    578a:	44 27       	eor	r20, r20
    578c:	55 27       	eor	r21, r21
    578e:	ba 2d       	mov	r27, r10
    5790:	aa 27       	eor	r26, r26
    5792:	99 27       	eor	r25, r25
    5794:	88 27       	eor	r24, r24
    5796:	82 2b       	or	r24, r18
    5798:	93 2b       	or	r25, r19
    579a:	a4 2b       	or	r26, r20
    579c:	b5 2b       	or	r27, r21
    579e:	b6 01       	movw	r22, r12
    57a0:	a5 01       	movw	r20, r10
    57a2:	40 70       	andi	r20, 0x00	; 0
    57a4:	50 70       	andi	r21, 0x00	; 0
    57a6:	70 70       	andi	r23, 0x00	; 0
    57a8:	45 2f       	mov	r20, r21
    57aa:	56 2f       	mov	r21, r22
    57ac:	67 2f       	mov	r22, r23
    57ae:	77 27       	eor	r23, r23
    57b0:	9a 01       	movw	r18, r20
    57b2:	ab 01       	movw	r20, r22
    57b4:	28 2b       	or	r18, r24
    57b6:	39 2b       	or	r19, r25
    57b8:	4a 2b       	or	r20, r26
    57ba:	5b 2b       	or	r21, r27
    57bc:	d6 01       	movw	r26, r12
    57be:	c5 01       	movw	r24, r10
    57c0:	80 70       	andi	r24, 0x00	; 0
    57c2:	a0 70       	andi	r26, 0x00	; 0
    57c4:	b0 70       	andi	r27, 0x00	; 0
    57c6:	ba 2f       	mov	r27, r26
    57c8:	a9 2f       	mov	r26, r25
    57ca:	98 2f       	mov	r25, r24
    57cc:	88 27       	eor	r24, r24
    57ce:	82 2b       	or	r24, r18
    57d0:	93 2b       	or	r25, r19
    57d2:	a4 2b       	or	r26, r20
    57d4:	b5 2b       	or	r27, r21
    57d6:	88 8b       	std	Y+16, r24	; 0x10
    57d8:	99 8b       	std	Y+17, r25	; 0x11
    57da:	aa 8b       	std	Y+18, r26	; 0x12
    57dc:	bb 8b       	std	Y+19, r27	; 0x13
	ipHeader->srcIPAddr = HTONL(IpMyConfig.ip);
    57de:	80 91 d9 05 	lds	r24, 0x05D9
    57e2:	90 91 da 05 	lds	r25, 0x05DA
    57e6:	a0 91 db 05 	lds	r26, 0x05DB
    57ea:	b0 91 dc 05 	lds	r27, 0x05DC
    57ee:	eb 2e       	mov	r14, r27
    57f0:	ff 24       	eor	r15, r15
    57f2:	00 27       	eor	r16, r16
    57f4:	11 27       	eor	r17, r17
    57f6:	58 2f       	mov	r21, r24
    57f8:	44 27       	eor	r20, r20
    57fa:	33 27       	eor	r19, r19
    57fc:	22 27       	eor	r18, r18
    57fe:	e2 2a       	or	r14, r18
    5800:	f3 2a       	or	r15, r19
    5802:	04 2b       	or	r16, r20
    5804:	15 2b       	or	r17, r21
    5806:	9c 01       	movw	r18, r24
    5808:	ad 01       	movw	r20, r26
    580a:	20 70       	andi	r18, 0x00	; 0
    580c:	30 70       	andi	r19, 0x00	; 0
    580e:	50 70       	andi	r21, 0x00	; 0
    5810:	23 2f       	mov	r18, r19
    5812:	34 2f       	mov	r19, r20
    5814:	45 2f       	mov	r20, r21
    5816:	55 27       	eor	r21, r21
    5818:	2e 29       	or	r18, r14
    581a:	3f 29       	or	r19, r15
    581c:	40 2b       	or	r20, r16
    581e:	51 2b       	or	r21, r17
    5820:	80 70       	andi	r24, 0x00	; 0
    5822:	a0 70       	andi	r26, 0x00	; 0
    5824:	b0 70       	andi	r27, 0x00	; 0
    5826:	ee 24       	eor	r14, r14
    5828:	f8 2e       	mov	r15, r24
    582a:	09 2f       	mov	r16, r25
    582c:	1a 2f       	mov	r17, r26
    582e:	2e 29       	or	r18, r14
    5830:	3f 29       	or	r19, r15
    5832:	40 2b       	or	r20, r16
    5834:	51 2b       	or	r21, r17
    5836:	2c 87       	std	Y+12, r18	; 0x0c
    5838:	3d 87       	std	Y+13, r19	; 0x0d
    583a:	4e 87       	std	Y+14, r20	; 0x0e
    583c:	5f 87       	std	Y+15, r21	; 0x0f
	ipHeader->Protocol = IP_PROTO_UDP;
    583e:	81 e1       	ldi	r24, 0x11	; 17
    5840:	89 87       	std	Y+9, r24	; 0x09
	ipHeader->Len = HTONS(len);
    5842:	96 2d       	mov	r25, r6
    5844:	87 2d       	mov	r24, r7
    5846:	9b 83       	std	Y+3, r25	; 0x03
    5848:	8a 83       	std	Y+2, r24	; 0x02
	ipHeader->verHdrLen = 0x45;
    584a:	85 e4       	ldi	r24, 0x45	; 69
    584c:	88 83       	st	Y, r24
	ipHeader->ToS = 0;
    584e:	19 82       	std	Y+1, r1	; 0x01
	ipHeader->IDNumber = 0;
    5850:	1d 82       	std	Y+5, r1	; 0x05
    5852:	1c 82       	std	Y+4, r1	; 0x04
	ipHeader->Offset = 0;
    5854:	1f 82       	std	Y+7, r1	; 0x07
    5856:	1e 82       	std	Y+6, r1	; 0x06
	ipHeader->TTL = IP_TIME_TO_LIVE;
    5858:	80 e8       	ldi	r24, 0x80	; 128
    585a:	88 87       	std	Y+8, r24	; 0x08
	ipHeader->Checksum = 0;
    585c:	1b 86       	std	Y+11, r1	; 0x0b
    585e:	1a 86       	std	Y+10, r1	; 0x0a

	ipHeader->Checksum = ipChecksum((unsigned char*)ipHeader, IP_HEADER_LEN);
    5860:	ce 01       	movw	r24, r28
    5862:	64 e1       	ldi	r22, 0x14	; 20
    5864:	70 e0       	ldi	r23, 0x00	; 0
    5866:	0e 94 2d 1b 	call	0x365a	; 0x365a <ipChecksum>
    586a:	9b 87       	std	Y+11, r25	; 0x0b
    586c:	8a 87       	std	Y+10, r24	; 0x0a
	if( (dstIp & IpMyConfig.netmask) == (IpMyConfig.ip & IpMyConfig.netmask) )
    586e:	80 91 d9 05 	lds	r24, 0x05D9
    5872:	90 91 da 05 	lds	r25, 0x05DA
    5876:	a0 91 db 05 	lds	r26, 0x05DB
    587a:	b0 91 dc 05 	lds	r27, 0x05DC
    587e:	a8 26       	eor	r10, r24
    5880:	b9 26       	eor	r11, r25
    5882:	ca 26       	eor	r12, r26
    5884:	db 26       	eor	r13, r27
    5886:	80 91 dd 05 	lds	r24, 0x05DD
    588a:	90 91 de 05 	lds	r25, 0x05DE
    588e:	a0 91 df 05 	lds	r26, 0x05DF
    5892:	b0 91 e0 05 	lds	r27, 0x05E0
    5896:	a8 22       	and	r10, r24
    5898:	b9 22       	and	r11, r25
    589a:	ca 22       	and	r12, r26
    589c:	db 22       	and	r13, r27
    589e:	a1 14       	cp	r10, r1
    58a0:	b1 04       	cpc	r11, r1
    58a2:	c1 04       	cpc	r12, r1
    58a4:	d1 04       	cpc	r13, r1
    58a6:	39 f4       	brne	.+14     	; 0x58b6 <udpSend+0x19c>
	{
		arpIpOut((unsigned char*)ethHeader,0);					// local send
    58a8:	c4 01       	movw	r24, r8
    58aa:	40 e0       	ldi	r20, 0x00	; 0
    58ac:	50 e0       	ldi	r21, 0x00	; 0
    58ae:	ba 01       	movw	r22, r20
    58b0:	0e 94 27 0c 	call	0x184e	; 0x184e <arpIpOut>
    58b4:	0b c0       	rjmp	.+22     	; 0x58cc <udpSend+0x1b2>
	}
	else
	{
		arpIpOut((unsigned char*)ethHeader,IpMyConfig.gateway);	// gateway send
    58b6:	40 91 e1 05 	lds	r20, 0x05E1
    58ba:	50 91 e2 05 	lds	r21, 0x05E2
    58be:	60 91 e3 05 	lds	r22, 0x05E3
    58c2:	70 91 e4 05 	lds	r23, 0x05E4
    58c6:	c4 01       	movw	r24, r8
    58c8:	0e 94 27 0c 	call	0x184e	; 0x184e <arpIpOut>
	//#ifdef IP_DEBUG
	//printf("Sending IP packet\r\nAddr: ");
	//ipPrintAddr(dstIp);printf("\n\rMAC: ");
	//ethPrintAddr(&(ethHeader->desAddr));printf("\n\r");
	//#endif
	ethSendFrame(len, (unsigned char*)ethHeader);
    58cc:	c3 01       	movw	r24, r6
    58ce:	0e 96       	adiw	r24, 0x0e	; 14
    58d0:	b4 01       	movw	r22, r8
    58d2:	0e 94 ec 14 	call	0x29d8	; 0x29d8 <ethSendFrame>
}
    58d6:	df 91       	pop	r29
    58d8:	cf 91       	pop	r28
    58da:	1f 91       	pop	r17
    58dc:	0f 91       	pop	r16
    58de:	ff 90       	pop	r15
    58e0:	ef 90       	pop	r14
    58e2:	df 90       	pop	r13
    58e4:	cf 90       	pop	r12
    58e6:	bf 90       	pop	r11
    58e8:	af 90       	pop	r10
    58ea:	9f 90       	pop	r9
    58ec:	8f 90       	pop	r8
    58ee:	7f 90       	pop	r7
    58f0:	6f 90       	pop	r6
    58f2:	08 95       	ret

000058f4 <UDPProcess>:
//--------------------------------------------------------------------------------------
//Ham xu ly goi UDP nhan duoc, duoc goi boi ham xu ly goi IP (IPProcess)
// Hien chua co ung dung chay UDP nen ham nay trong
void UDPProcess(unsigned int len, struct ntIPHeader* packet)
{
	dhcpIn((len - IP_HEADER_LEN - UDP_HEADER_LEN), (struct netDhcpHeader*)((char*)packet + IP_HEADER_LEN + UDP_HEADER_LEN));
    58f4:	64 5e       	subi	r22, 0xE4	; 228
    58f6:	7f 4f       	sbci	r23, 0xFF	; 255
    58f8:	4c 97       	sbiw	r24, 0x1c	; 28
    58fa:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <dhcpIn>
	#ifdef UDP_DEBUG
	printf("Rx UDP Packet\r\n");
	#endif
}
    58fe:	08 95       	ret

00005900 <__udivmodqi4>:
    5900:	99 1b       	sub	r25, r25
    5902:	79 e0       	ldi	r23, 0x09	; 9
    5904:	04 c0       	rjmp	.+8      	; 0x590e <__udivmodqi4_ep>

00005906 <__udivmodqi4_loop>:
    5906:	99 1f       	adc	r25, r25
    5908:	96 17       	cp	r25, r22
    590a:	08 f0       	brcs	.+2      	; 0x590e <__udivmodqi4_ep>
    590c:	96 1b       	sub	r25, r22

0000590e <__udivmodqi4_ep>:
    590e:	88 1f       	adc	r24, r24
    5910:	7a 95       	dec	r23
    5912:	c9 f7       	brne	.-14     	; 0x5906 <__udivmodqi4_loop>
    5914:	80 95       	com	r24
    5916:	08 95       	ret

00005918 <__udivmodhi4>:
    5918:	aa 1b       	sub	r26, r26
    591a:	bb 1b       	sub	r27, r27
    591c:	51 e1       	ldi	r21, 0x11	; 17
    591e:	07 c0       	rjmp	.+14     	; 0x592e <__udivmodhi4_ep>

00005920 <__udivmodhi4_loop>:
    5920:	aa 1f       	adc	r26, r26
    5922:	bb 1f       	adc	r27, r27
    5924:	a6 17       	cp	r26, r22
    5926:	b7 07       	cpc	r27, r23
    5928:	10 f0       	brcs	.+4      	; 0x592e <__udivmodhi4_ep>
    592a:	a6 1b       	sub	r26, r22
    592c:	b7 0b       	sbc	r27, r23

0000592e <__udivmodhi4_ep>:
    592e:	88 1f       	adc	r24, r24
    5930:	99 1f       	adc	r25, r25
    5932:	5a 95       	dec	r21
    5934:	a9 f7       	brne	.-22     	; 0x5920 <__udivmodhi4_loop>
    5936:	80 95       	com	r24
    5938:	90 95       	com	r25
    593a:	bc 01       	movw	r22, r24
    593c:	cd 01       	movw	r24, r26
    593e:	08 95       	ret

00005940 <__udivmodsi4>:
    5940:	a1 e2       	ldi	r26, 0x21	; 33
    5942:	1a 2e       	mov	r1, r26
    5944:	aa 1b       	sub	r26, r26
    5946:	bb 1b       	sub	r27, r27
    5948:	fd 01       	movw	r30, r26
    594a:	0d c0       	rjmp	.+26     	; 0x5966 <__udivmodsi4_ep>

0000594c <__udivmodsi4_loop>:
    594c:	aa 1f       	adc	r26, r26
    594e:	bb 1f       	adc	r27, r27
    5950:	ee 1f       	adc	r30, r30
    5952:	ff 1f       	adc	r31, r31
    5954:	a2 17       	cp	r26, r18
    5956:	b3 07       	cpc	r27, r19
    5958:	e4 07       	cpc	r30, r20
    595a:	f5 07       	cpc	r31, r21
    595c:	20 f0       	brcs	.+8      	; 0x5966 <__udivmodsi4_ep>
    595e:	a2 1b       	sub	r26, r18
    5960:	b3 0b       	sbc	r27, r19
    5962:	e4 0b       	sbc	r30, r20
    5964:	f5 0b       	sbc	r31, r21

00005966 <__udivmodsi4_ep>:
    5966:	66 1f       	adc	r22, r22
    5968:	77 1f       	adc	r23, r23
    596a:	88 1f       	adc	r24, r24
    596c:	99 1f       	adc	r25, r25
    596e:	1a 94       	dec	r1
    5970:	69 f7       	brne	.-38     	; 0x594c <__udivmodsi4_loop>
    5972:	60 95       	com	r22
    5974:	70 95       	com	r23
    5976:	80 95       	com	r24
    5978:	90 95       	com	r25
    597a:	9b 01       	movw	r18, r22
    597c:	ac 01       	movw	r20, r24
    597e:	bd 01       	movw	r22, r26
    5980:	cf 01       	movw	r24, r30
    5982:	08 95       	ret

00005984 <_exit>:
    5984:	f8 94       	cli

00005986 <__stop_program>:
    5986:	ff cf       	rjmp	.-2      	; 0x5986 <__stop_program>
